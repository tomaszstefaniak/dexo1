{"version":3,"file":"main-4.0.1-449.js","mappings":"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","sources":["webpack://@jup-ag/terminal/./node_modules/memoize-one/dist/memoize-one.esm.js","webpack://@jup-ag/terminal/./node_modules/@mercurial-finance/optimist/dist/optimist.esm.js"],"sourcesContent":["var safeIsNaN = Number.isNaN ||\n    function ponyfill(value) {\n        return typeof value === 'number' && value !== value;\n    };\nfunction isEqual(first, second) {\n    if (first === second) {\n        return true;\n    }\n    if (safeIsNaN(first) && safeIsNaN(second)) {\n        return true;\n    }\n    return false;\n}\nfunction areInputsEqual(newInputs, lastInputs) {\n    if (newInputs.length !== lastInputs.length) {\n        return false;\n    }\n    for (var i = 0; i < newInputs.length; i++) {\n        if (!isEqual(newInputs[i], lastInputs[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction memoizeOne(resultFn, isEqual) {\n    if (isEqual === void 0) { isEqual = areInputsEqual; }\n    var lastThis;\n    var lastArgs = [];\n    var lastResult;\n    var calledOnce = false;\n    function memoized() {\n        var newArgs = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            newArgs[_i] = arguments[_i];\n        }\n        if (calledOnce && lastThis === this && isEqual(newArgs, lastArgs)) {\n            return lastResult;\n        }\n        lastResult = resultFn.apply(this, newArgs);\n        calledOnce = true;\n        lastThis = this;\n        lastArgs = newArgs;\n        return lastResult;\n    }\n    return memoized;\n}\n\nexport default memoizeOne;\n","import { TOKEN_PROGRAM_ID, AccountLayout, u64, MintLayout, Token, ASSOCIATED_TOKEN_PROGRAM_ID, NATIVE_MINT } from '@solana/spl-token';\nimport { bs58 } from '@coral-xyz/anchor/dist/cjs/utils/bytes';\nimport { TransactionExpiredBlockheightExceededError, VersionedTransaction, PublicKey, SystemProgram, Transaction, ComputeBudgetProgram, TransactionInstruction, ComputeBudgetInstruction, PACKET_DATA_SIZE } from '@solana/web3.js';\nimport promiseRetry from 'promise-retry';\nimport { utils } from '@coral-xyz/anchor';\nimport { getAssociatedTokenAddress, createAssociatedTokenAccountIdempotentInstruction, unpackMint } from '@solana/spl-token-0.4';\nimport { Metadata } from '@metaplex-foundation/mpl-token-metadata';\n\nclass TransactionError extends Error {\n  constructor(m, txid, code, programIds, serializedTx) {\n    super(m);\n    this.txid = void 0;\n    this.code = void 0;\n    this.programIds = void 0;\n    this.serializedTx = void 0;\n    this.txid = txid;\n    this.code = code;\n    this.programIds = programIds;\n    this.serializedTx = serializedTx;\n    // Set the prototype explicitly.\n    Object.setPrototypeOf(this, Error.prototype);\n  }\n}\nconst COMMON_TX_ERRORS = {\n  PROGRAM_FAILED_TO_COMPLETE_ERROR: 'Program failed to complete',\n  UNKNOWN_ERROR: 'Unknown error, visit the explorer',\n  TOO_MANY_ACCOUNT_LOCKS: 'Transaction locked too many accounts',\n  INSUFFICIENT_FUNDS_FOR_RENT: 'The account does not have enough SOL to perform the operation',\n  TRANSACTION_TOO_LARGE: 'Transaction too large',\n  TRANSACTION_NOT_CONFIRMED: 'Transaction has expired and was not confirmed. Please try again.',\n  FROZEN_ACCOUNT: 'The token account is frozen',\n  TRANSACTION_EXPIRED_BLOCKHEIGHT_EXCEEDED: 'TransactionExpiredBlockheightExceededError'\n};\nconst SYSTEM_PROGRAM_ID = '11111111111111111111111111111111';\nfunction parseErrorForTransaction({\n  err,\n  logMessages\n}) {\n  const transactionError = err;\n  let errorCode;\n  if (transactionError && typeof transactionError !== 'string') {\n    let error = transactionError;\n    if ('InsufficientFundsForRent' in error) {\n      return {\n        message: COMMON_TX_ERRORS.INSUFFICIENT_FUNDS_FOR_RENT,\n        code: 1,\n        programIds: [TOKEN_PROGRAM_ID.toBase58()]\n      };\n    } else {\n      const instructionError = transactionError.InstructionError;\n      const [_, errorMsg] = instructionError;\n      if (typeof errorMsg === 'string') {\n        if (errorMsg === 'ProgramFailedToComplete') {\n          if (logMessages) {\n            const failedProgramIds = getFailedExceededInstructionsPrograms(logMessages);\n            if (failedProgramIds.length > 0) {\n              return {\n                message: COMMON_TX_ERRORS.PROGRAM_FAILED_TO_COMPLETE_ERROR,\n                programIds: failedProgramIds,\n                code: errorCode\n              };\n            }\n          }\n        }\n      } else {\n        errorCode = errorMsg.Custom ?? instructionError[1];\n        if (logMessages) {\n          const failedProgramId = getFailedProgram(logMessages, errorCode);\n          if (failedProgramId) {\n            if (failedProgramId === SYSTEM_PROGRAM_ID) {\n              return getSystemProgramError(instructionError);\n            }\n            if (failedProgramId === TOKEN_PROGRAM_ID.toBase58()) {\n              switch (errorCode) {\n                case 17:\n                  {\n                    return {\n                      message: COMMON_TX_ERRORS.FROZEN_ACCOUNT,\n                      programIds: [failedProgramId],\n                      code: errorCode\n                    };\n                  }\n              }\n            }\n            return {\n              message: COMMON_TX_ERRORS.UNKNOWN_ERROR,\n              programIds: [failedProgramId],\n              code: errorCode\n            };\n          }\n        }\n      }\n    }\n  }\n  if (transactionError === 'InsufficientFundsForFee') {\n    return {\n      message: COMMON_TX_ERRORS.INSUFFICIENT_FUNDS_FOR_RENT,\n      code: 1,\n      programIds: [TOKEN_PROGRAM_ID.toBase58()]\n    };\n  } else if (transactionError === 'TooManyAccountLocks') {\n    return {\n      message: COMMON_TX_ERRORS.TOO_MANY_ACCOUNT_LOCKS,\n      code: 0,\n      programIds: []\n    };\n  }\n  return {\n    message: typeof transactionError === 'string' ? transactionError || COMMON_TX_ERRORS.UNKNOWN_ERROR : COMMON_TX_ERRORS.UNKNOWN_ERROR,\n    code: errorCode\n  };\n}\nfunction getFailedExceededInstructionsPrograms(logMessages) {\n  let founds = [];\n  for (let i = 0; i < logMessages.length; i++) {\n    const log = logMessages[i];\n    const found = log.match(new RegExp(/Program (\\S+) failed: (?:Program failed to complete|SBF program panicked)/));\n    if (found) {\n      founds.push(found[1]);\n    }\n  }\n  return founds;\n}\nfunction getFailedProgram(logMessages, errorCode) {\n  for (let i = 0; i < logMessages.length; i++) {\n    const log = logMessages[i];\n    const found = log.match(new RegExp(`Program ([1-9A-HJ-NP-Za-km-z]{32,44}) failed: custom program error: 0x${errorCode.toString(16)}`));\n    if (found) {\n      return found[1];\n    }\n  }\n  return;\n}\nfunction getSystemProgramError(instructionError) {\n  const code = instructionError[1].Custom;\n  let message = '';\n  switch (code) {\n    // https://github.com/solana-labs/solana/blob/22a18a68e3ee68ae013d647e62e12128433d7230/sdk/program/src/system_instruction.rs#L12-L26\n    // TODO: Do we need to translate all error codes.\n    case 0:\n      {\n        message = 'An account with the same address already exists';\n        break;\n      }\n    case 1:\n      {\n        message = COMMON_TX_ERRORS.INSUFFICIENT_FUNDS_FOR_RENT;\n        break;\n      }\n    default:\n      {\n        message = COMMON_TX_ERRORS.UNKNOWN_ERROR;\n      }\n  }\n  return {\n    code,\n    programIds: [SYSTEM_PROGRAM_ID],\n    message\n  };\n}\n\nconst wait = time => new Promise(resolve => setTimeout(resolve, time));\n\nconst SEND_OPTIONS = {\n  maxRetries: 0,\n  skipPreflight: true\n};\nasync function forwardToJito(serializedTransaction, jitoTipTx, jitoProxyUrl) {\n  try {\n    const jitoResponse = await fetch(jitoProxyUrl ?? `https://mainnet.block-engine.jito.wtf/api/v1/bundles`, {\n      method: 'POST',\n      headers: {\n        'Content-Type': 'application/json'\n      },\n      body: JSON.stringify({\n        jsonrpc: '2.0',\n        id: 1,\n        method: 'sendBundle',\n        params: [[bs58.encode(serializedTransaction), bs58.encode(jitoTipTx.serialize())]]\n      })\n    });\n    const jitoResult = await jitoResponse.json();\n    if (jitoResult.result) {\n      console.log('Sent to JITO', jitoResult.result);\n      return jitoResult;\n    }\n  } catch (error) {\n    console.log('Failed to send to Jito', error);\n  }\n  return null;\n}\nasync function transactionSenderAndConfirmationWaiter({\n  txid,\n  connection,\n  serializedTransaction,\n  blockhashWithBlockHeight,\n  broadcastMode,\n  jitoTipTx,\n  jitoProxyUrl\n}) {\n  const controller = new AbortController();\n  const abortSignal = controller.signal;\n  const abortableResender = async () => {\n    while (true) {\n      await wait(1_750);\n      if (abortSignal.aborted) return;\n      try {\n        await connection.sendRawTransaction(serializedTransaction, SEND_OPTIONS);\n      } catch (e) {\n        console.warn(`Failed to resend transaction: ${e}`);\n      }\n    }\n  };\n  let jitoResponse = null;\n  try {\n    if (broadcastMode === 'jito' && jitoTipTx) {\n      jitoResponse = await forwardToJito(serializedTransaction, jitoTipTx, jitoProxyUrl);\n    } else {\n      if (broadcastMode === 'mixed' && jitoTipTx) {\n        jitoResponse = await forwardToJito(serializedTransaction, jitoTipTx, jitoProxyUrl);\n      }\n      await connection.sendRawTransaction(serializedTransaction, SEND_OPTIONS), abortableResender();\n    }\n    // this would throw TransactionExpiredBlockheightExceededError\n    await Promise.race([connection.confirmTransaction({\n      ...blockhashWithBlockHeight,\n      signature: txid,\n      abortSignal\n    }, 'confirmed'), new Promise(async resolve => {\n      // in case ws socket died\n      while (!abortSignal.aborted) {\n        await wait(2_000);\n        const tx = await connection.getSignatureStatus(txid, {\n          searchTransactionHistory: false\n        });\n        if (tx?.value?.confirmationStatus === 'confirmed') {\n          resolve(tx);\n        }\n      }\n    })]);\n  } catch (e) {\n    if (e instanceof TransactionExpiredBlockheightExceededError) {\n      // we consume this error and getTransaction would return null\n      return {\n        response: null,\n        jitoResponse\n      };\n    } else {\n      // invalid state from web3.js\n      throw e;\n    }\n  } finally {\n    controller.abort();\n  }\n  // in case rpc is not synced yet, we add some retries\n  const response = await promiseRetry(async retry => {\n    const response = await connection.getTransaction(txid, {\n      commitment: 'confirmed',\n      maxSupportedTransactionVersion: 0\n    });\n    if (!response) {\n      retry(response);\n    }\n    return response;\n  }, {\n    retries: 5,\n    minTimeout: 1e3\n  });\n  return {\n    response,\n    jitoResponse\n  };\n}\n\nfunction getSignature(transaction) {\n  const signature = 'signature' in transaction ? transaction.signature : transaction.signatures[0];\n  if (!signature) {\n    throw new Error('Missing transaction signature, the transaction was not signed by the fee payer');\n  }\n  return utils.bytes.bs58.encode(signature);\n}\nconst handleSendTransaction = async ({\n  connection,\n  signedTransaction,\n  blockhash,\n  lastValidBlockHeight,\n  idl,\n  skipPreflight,\n  idlProgramId,\n  minContextSlot,\n  broadcastMode,\n  jitoTipTx,\n  jitoProxyUrl,\n  debug\n}) => {\n  let serializedTransaction = Buffer.from(signedTransaction.serialize());\n  let signature = getSignature(signedTransaction);\n  const {\n    value: simulatedTransactionResponse\n  } = await connection.simulateTransaction('message' in signedTransaction ? signedTransaction : new VersionedTransaction(signedTransaction.compileMessage()), {\n    replaceRecentBlockhash: true,\n    commitment: 'processed',\n    minContextSlot\n  });\n  const {\n    err,\n    logs\n  } = simulatedTransactionResponse;\n  if (debug) {\n    console.log('Simulated Transaction Logs:', logs);\n  }\n  if (err) {\n    // dont save txid to error cause it is not sent\n    const error = parseErrorWithIdl({\n      err,\n      logMessages: logs\n    }, undefined, idl, idlProgramId);\n    if (skipPreflight) {\n      if (error.message === COMMON_TX_ERRORS.INSUFFICIENT_FUNDS_FOR_RENT || error.message === COMMON_TX_ERRORS.TOO_MANY_ACCOUNT_LOCKS) {\n        error.serializedTx = Buffer.from(signedTransaction.serialize()).toString('base64');\n        return {\n          error,\n          txid: undefined\n        };\n      }\n    } else {\n      error.serializedTx = Buffer.from(signedTransaction.serialize()).toString('base64');\n      return {\n        error,\n        txid: undefined\n      };\n    }\n  }\n  const {\n    response: transactionResponse,\n    jitoResponse\n  } = await transactionSenderAndConfirmationWaiter({\n    txid: signature,\n    connection,\n    serializedTransaction,\n    blockhashWithBlockHeight: {\n      blockhash,\n      lastValidBlockHeight\n    },\n    broadcastMode,\n    jitoTipTx,\n    jitoProxyUrl\n  });\n  if (!transactionResponse) {\n    const error = new TransactionError(COMMON_TX_ERRORS.TRANSACTION_NOT_CONFIRMED);\n    error.serializedTx = Buffer.from(signedTransaction.serialize()).toString('base64');\n    return {\n      error,\n      txid: undefined\n    };\n  }\n  if (transactionResponse.meta?.err) {\n    const error = parseErrorWithIdl(transactionResponse.meta, signature, idl, idlProgramId);\n    error.serializedTx = Buffer.from(signedTransaction.serialize()).toString('base64');\n    return {\n      error,\n      transactionResponse,\n      txid: signature\n    };\n  }\n  return {\n    transactionResponse,\n    jitoResponse,\n    txid: signature\n  };\n};\nconst parseErrorWithIdl = (errorParams, txid, idl, idlProgramId) => {\n  const {\n    code,\n    programIds,\n    message\n  } = parseErrorForTransaction(errorParams);\n  if (idlProgramId && idl) {\n    if (programIds?.includes(idlProgramId.toBase58())) {\n      let error = idl.errors?.find(error => {\n        return error.code === code;\n      });\n      if (error) {\n        // msg might not be exposed by IDL, so we fallback to name\n        return new TransactionError(error.msg ?? error.name, txid, error.code, programIds);\n      }\n    }\n  }\n  return new TransactionError(message, txid, code, programIds);\n};\nconst JITO_TIP_ACCOUNTS = ['96gYZGLnJYVFmbjzopPSU6QiEV5fGqZNyN9nmNhvrZU5', 'HFqU5x63VTqvQss8hp11i4wVV8bD44PvwucfZ2bU7gRe', 'Cw8CFyM9FkoMi7K7Crf6HNQqf4uEMzpKw6QNghXLvLkY', 'ADaUMid9yfUytqMBgopwjb2DTLSokTSzL1zt6iGPaS49', 'DfXygSm4jCyNCybVYYK6DwvWqjKee8pbDmJGcLWNDXjh', 'ADuUkR4vqLUMWXxW9gh6D6L8pMSawimctcNZ5pGwDcEt', 'DttWaMuVvTiduZRnguLF7jNxTgiMBZ1hyAumKUiL2KRL', '3AVi9Tg9Uo68tJfuvoKvqKNWKkC5wPdSSdeBnizKZ6jT'];\nconst getRandomTipAccount = () => new PublicKey(JITO_TIP_ACCOUNTS[Math.floor(Math.random() * JITO_TIP_ACCOUNTS.length)]);\nfunction createJitoTipTx({\n  payer,\n  lamports,\n  blockhash,\n  lastValidBlockHeight\n}) {\n  const tipAccount = getRandomTipAccount();\n  const tipIx = SystemProgram.transfer({\n    fromPubkey: payer,\n    toPubkey: tipAccount,\n    lamports: BigInt(lamports)\n  });\n  const tx = new Transaction({\n    blockhash,\n    lastValidBlockHeight\n  }).add(tipIx);\n  tx.add(ComputeBudgetProgram.setComputeUnitPrice({\n    microLamports: 0\n  }));\n  tx.feePayer = payer;\n  return tx;\n}\n\nfunction extractComputeUnitLimit(tx) {\n  if ('version' in tx) {\n    for (let ix of tx.message.compiledInstructions) {\n      let programId = tx.message.staticAccountKeys[ix.programIdIndex];\n      if (programId && ComputeBudgetProgram.programId.equals(programId)) {\n        if (ix.data[0] === 2) {\n          const decodedTI = new TransactionInstruction({\n            keys: [],\n            programId: ComputeBudgetProgram.programId,\n            data: Buffer.from(ix.data)\n          });\n          return ComputeBudgetInstruction.decodeSetComputeUnitLimit(decodedTI).units;\n        }\n      }\n    }\n  } else {\n    for (let ix of tx.instructions) {\n      if (ComputeBudgetProgram.programId.equals(ix.programId)) {\n        if (ix.data[0] === 2) {\n          return ComputeBudgetInstruction.decodeSetComputeUnitLimit(ix).units;\n        }\n      }\n    }\n  }\n  return null;\n}\nfunction extractComputeUnitPrice(tx) {\n  if ('version' in tx) {\n    for (let ix of tx.message.compiledInstructions) {\n      let programId = tx.message.staticAccountKeys[ix.programIdIndex];\n      if (programId && ComputeBudgetProgram.programId.equals(programId)) {\n        if (ix.data[0] === 3) {\n          const decodedTI = new TransactionInstruction({\n            keys: [],\n            programId: ComputeBudgetProgram.programId,\n            data: Buffer.from(ix.data)\n          });\n          return ComputeBudgetInstruction.decodeSetComputeUnitPrice(decodedTI).microLamports;\n        }\n      }\n    }\n  } else {\n    for (let ix of tx.instructions) {\n      if (ComputeBudgetProgram.programId.equals(ix.programId)) {\n        if (ix.data[0] === 3) {\n          return ComputeBudgetInstruction.decodeSetComputeUnitPrice(ix).microLamports;\n        }\n      }\n    }\n  }\n  return null;\n}\nconst modifyComputeUnitLimitIx = (tx, newComputeUnitLimit) => {\n  if ('version' in tx) {\n    for (let ix of tx.message.compiledInstructions) {\n      let programId = tx.message.staticAccountKeys[ix.programIdIndex];\n      if (programId && ComputeBudgetProgram.programId.equals(programId)) {\n        // need check for data index\n        if (ix.data[0] === 2) {\n          ix.data = Uint8Array.from(ComputeBudgetProgram.setComputeUnitLimit({\n            units: newComputeUnitLimit\n          }).data);\n          return true;\n        }\n      }\n    }\n    // could not inject for VT\n  } else {\n    for (let ix of tx.instructions) {\n      if (ComputeBudgetProgram.programId.equals(ix.programId)) {\n        // need check for data index\n        if (ix.data[0] === 2) {\n          ix.data = ComputeBudgetProgram.setComputeUnitLimit({\n            units: newComputeUnitLimit\n          }).data;\n          return true;\n        }\n      }\n    }\n    // inject if none\n    tx.add(ComputeBudgetProgram.setComputeUnitLimit({\n      units: newComputeUnitLimit\n    }));\n    return true;\n  }\n  return false;\n};\n/**\r\n * Modify priority fee in transaction\r\n * @param tx\r\n * @param newPriorityFee\r\n * @returns {boolean} true if priority fee was modified\r\n **/\nconst modifyComputeUnitPriceIx = (tx, newPriorityFee) => {\n  if ('version' in tx) {\n    for (let ix of tx.message.compiledInstructions) {\n      let programId = tx.message.staticAccountKeys[ix.programIdIndex];\n      if (programId && ComputeBudgetProgram.programId.equals(programId)) {\n        // need check for data index\n        if (ix.data[0] === 3) {\n          ix.data = Uint8Array.from(ComputeBudgetProgram.setComputeUnitPrice({\n            microLamports: newPriorityFee\n          }).data);\n          return true;\n        }\n      }\n    }\n    // could not inject for VT\n  } else {\n    for (let ix of tx.instructions) {\n      if (ComputeBudgetProgram.programId.equals(ix.programId)) {\n        // need check for data index\n        if (ix.data[0] === 3) {\n          ix.data = ComputeBudgetProgram.setComputeUnitPrice({\n            microLamports: newPriorityFee\n          }).data;\n          return true;\n        }\n      }\n    }\n    // inject if none\n    tx.add(ComputeBudgetProgram.setComputeUnitPrice({\n      microLamports: newPriorityFee\n    }));\n    return true;\n  }\n  return false;\n};\n/**\r\n * Estimate and modify priority fee in transaction\r\n * @param connection\r\n * @param tx\r\n * @param newPriorityFee\r\n * @returns {number} estimated priority fee\r\n *  **/\nconst estimatePriorityFee = async (connection, params) => {\n  let writeableAccounts = [];\n  if (params.tx) {\n    if ('version' in params.tx) {\n      const accounts = params.tx.message.staticAccountKeys;\n      for (const [idx, account] of accounts.entries()) {\n        if (params.tx.message.isAccountWritable(idx)) {\n          writeableAccounts.push(account);\n        }\n      }\n    } else {\n      for (const instruction of params.tx.instructions) {\n        for (const account of instruction.keys) {\n          if (account.isWritable) {\n            writeableAccounts.push(account.pubkey);\n          }\n        }\n      }\n    }\n  }\n  if (params.accounts) {\n    writeableAccounts = writeableAccounts.concat(params.accounts);\n  }\n  if (writeableAccounts.length) {\n    let fees = await connection.getRecentPrioritizationFees({\n      lockedWritableAccounts: writeableAccounts\n    });\n    fees = fees.sort((feeA, feeB) => feeB.slot - feeA.slot);\n    fees = fees.slice(0, 20);\n    let last20SortedFees = fees.map(fee => fee.prioritizationFee).sort((feeA, feeB) => feeB - feeA);\n    let priorityFee = Math.max(last20SortedFees[Math.floor(last20SortedFees.length * 85 / 100)], 1); // minimum 1 microLamport\n    return priorityFee;\n  }\n  return 1; // default 1\n};\n\nconst checkTxSize = transaction => {\n  let txLength = (() => {\n    try {\n      return transaction.serialize({\n        requireAllSignatures: false\n      }).length;\n    } catch (e) {\n      return PACKET_DATA_SIZE + 1;\n    }\n  })();\n  if (txLength > PACKET_DATA_SIZE) {\n    return {\n      error: new TransactionError(COMMON_TX_ERRORS.TRANSACTION_TOO_LARGE)\n    };\n  }\n};\n\nconst deserializeAccount = data => {\n  if (data == undefined || data.length == 0) {\n    return undefined;\n  }\n  const accountInfo = AccountLayout.decode(data);\n  accountInfo.mint = new PublicKey(accountInfo.mint);\n  accountInfo.owner = new PublicKey(accountInfo.owner);\n  accountInfo.amount = u64.fromBuffer(accountInfo.amount);\n  if (accountInfo.delegateOption === 0) {\n    accountInfo.delegate = null;\n    accountInfo.delegatedAmount = new u64(0);\n  } else {\n    accountInfo.delegate = new PublicKey(accountInfo.delegate);\n    accountInfo.delegatedAmount = u64.fromBuffer(accountInfo.delegatedAmount);\n  }\n  accountInfo.isInitialized = accountInfo.state !== 0;\n  accountInfo.isFrozen = accountInfo.state === 2;\n  if (accountInfo.isNativeOption === 1) {\n    accountInfo.rentExemptReserve = u64.fromBuffer(accountInfo.isNative);\n    accountInfo.isNative = true;\n  } else {\n    accountInfo.rentExemptReserve = null;\n    accountInfo.isNative = false;\n  }\n  if (accountInfo.closeAuthorityOption === 0) {\n    accountInfo.closeAuthority = null;\n  } else {\n    accountInfo.closeAuthority = new PublicKey(accountInfo.closeAuthority);\n  }\n  return accountInfo;\n};\n\nconst deserializeMint = (data, address) => {\n  if (data.length !== MintLayout.span) {\n    // This is causing problem with mainnet token\n    // throw new Error('Not a valid Mint')\n    return;\n  }\n  const mintInfo = MintLayout.decode(data);\n  mintInfo.address = address;\n  if (mintInfo.mintAuthorityOption === 0) {\n    mintInfo.mintAuthority = null;\n  } else {\n    mintInfo.mintAuthority = new PublicKey(mintInfo.mintAuthority);\n  }\n  mintInfo.supply = u64.fromBuffer(mintInfo.supply);\n  mintInfo.isInitialized = mintInfo.isInitialized !== 0;\n  if (mintInfo.freezeAuthorityOption === 0) {\n    mintInfo.freezeAuthority = null;\n  } else {\n    mintInfo.freezeAuthority = new PublicKey(mintInfo.freezeAuthority);\n  }\n  return mintInfo;\n};\n\nasync function getWSolATA(connection, publicKey) {\n  const wSolAddress = await Token.getAssociatedTokenAddress(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, NATIVE_MINT, publicKey, true);\n  const accountInfo = await connection.getAccountInfo(wSolAddress);\n  return {\n    address: wSolAddress,\n    accountInfo\n  };\n}\nasync function createAndTransferWSOLTransaction({\n  connection,\n  publicKey,\n  blockhash,\n  lastValidBlockHeight,\n  amountToTransferInLamports\n}) {\n  const wSolAccount = await getWSolATA(connection, publicKey);\n  const instructions = [];\n  // If no accountInfo, create one\n  if (!wSolAccount.accountInfo) {\n    // Create ATA account\n    instructions.push(Token.createAssociatedTokenAccountInstruction(ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID, NATIVE_MINT, wSolAccount.address, publicKey, publicKey));\n  }\n  // Fund account and sync\n  instructions.push(SystemProgram.transfer({\n    fromPubkey: publicKey,\n    toPubkey: wSolAccount.address,\n    lamports: amountToTransferInLamports\n  }));\n  instructions.push(\n  // This is not exposed by the types, but indeed it exists\n  Token.createSyncNativeInstruction(TOKEN_PROGRAM_ID, wSolAccount.address));\n  const transaction = new Transaction({\n    feePayer: publicKey,\n    blockhash,\n    lastValidBlockHeight\n  });\n  transaction.add(...instructions);\n  return transaction;\n}\nasync function createUnwrapSolTransaction({\n  connection,\n  publicKey,\n  blockhash,\n  lastValidBlockHeight\n}) {\n  const wSolAccount = await getWSolATA(connection, publicKey);\n  const instructions = [];\n  if (!wSolAccount.accountInfo) {\n    return;\n  }\n  // Close account\n  instructions.push(Token.createCloseAccountInstruction(TOKEN_PROGRAM_ID, wSolAccount.address, publicKey, publicKey, []));\n  const transaction = new Transaction({\n    feePayer: publicKey,\n    blockhash,\n    lastValidBlockHeight\n  });\n  transaction.add(...instructions);\n  return transaction;\n}\n\nconst getATA = async (tokenMint, owner, connection) => {\n  let toAccount;\n  try {\n    toAccount = await getAssociatedTokenAddress(tokenMint, owner, true);\n    const account = await connection.getAccountInfo(toAccount);\n    return {\n      account,\n      toAccount\n    };\n  } catch (e) {\n    /* handle error */\n    console.error('Error::getATA', e);\n    throw e;\n  }\n};\nconst getOrCreateATAInstruction = async (tokenMint, owner, connection, payer = owner) => {\n  try {\n    const {\n      account,\n      toAccount\n    } = await getATA(tokenMint, owner, connection);\n    if (!account) {\n      const ix = createAssociatedTokenAccountIdempotentInstruction(payer, toAccount, owner, tokenMint);\n      return [toAccount, ix];\n    }\n    return [toAccount, undefined];\n  } catch (e) {\n    /* handle error */\n    console.error('Error::getOrCreateATAInstruction', e);\n    throw e;\n  }\n};\n\nconst TOKEN_METADATA_PROGRAM_ID = /*#__PURE__*/new PublicKey('metaqbxxUerdq28cj1RbAWkYQm3ybzjb6a8bt518x1s');\n// This is not an official program but a community deployement\nconst TOKEN_2022_METADATA_PROGRAM_ID = /*#__PURE__*/new PublicKey('META4s4fSmpkTbZoUsgC1oBnWB31vQcmnN8giPw51Zu');\nfunction findMetadataAddress(mint, tokenProgramId) {\n  const metadataProgramId = tokenProgramId.equals(TOKEN_PROGRAM_ID) ? TOKEN_METADATA_PROGRAM_ID : TOKEN_2022_METADATA_PROGRAM_ID;\n  return PublicKey.findProgramAddressSync([Buffer.from('metadata'), metadataProgramId.toBuffer(), mint.toBuffer()], metadataProgramId)[0];\n}\nconst TOKEN_2022_PROGRAM_ID = /*#__PURE__*/new PublicKey('TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxuEb');\nasync function fetchMintInfos(connection, mints) {\n  const results = (await utils.rpc.getMultipleAccounts(connection, mints)).reduce((acc, m, idx) => {\n    if (m) {\n      const {\n        publicKey,\n        account\n      } = m;\n      const isFromATokenProgram = account.owner.equals(TOKEN_PROGRAM_ID) || account.owner.equals(TOKEN_2022_PROGRAM_ID);\n      if (isFromATokenProgram) {\n        try {\n          const mint = unpackMint(publicKey, account, account.owner);\n          acc.push([mints[idx].toString(), {\n            mintAuthority: mint.mintAuthority,\n            supply: new u64(mint.supply.toString()),\n            decimals: mint.decimals,\n            isInitialized: mint.isInitialized,\n            freezeAuthority: mint.freezeAuthority,\n            programId: m.account.owner\n          }]);\n        } catch (error) {\n          console.log('Failed to fetch or decode mint', mints[idx].toString(), error);\n        }\n      }\n    }\n    return acc;\n  }, new Array());\n  return results;\n}\nconst removeEmptyChars = value => value.replace(/\\u0000/g, '');\nasync function fetchTokenMetadatas(connection, tokens) {\n  const metadataAddresses = tokens.map(t => findMetadataAddress(t.mint, t.programId));\n  const tokenMetaAccounts = (await utils.rpc.getMultipleAccounts(connection, metadataAddresses)).reduce((acc, keyedAccount) => {\n    if (keyedAccount) {\n      const metadata = Metadata.deserialize(keyedAccount.account.data)[0];\n      metadata.data.name = removeEmptyChars(metadata.data.name);\n      metadata.data.symbol = removeEmptyChars(metadata.data.symbol);\n      metadata.data.uri = removeEmptyChars(metadata.data.uri);\n      acc.push({\n        publicKey: keyedAccount.publicKey,\n        account: metadata\n      });\n    }\n    return acc;\n  }, new Array());\n  return tokenMetaAccounts;\n}\n\nfunction chunks(array, size) {\n  return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n\nconst getMultipleAccountsInfo = async (connection, keys, options) => {\n  const accountToAccountInfoMap = new Map();\n  await Promise.all(chunks(keys, 99).map(async chunk => {\n    const accountInfos = await connection.getMultipleAccountsInfo(chunk, options);\n    accountInfos.forEach((accountInfo, idx) => {\n      accountToAccountInfoMap.set(chunk[idx].toString(), accountInfo);\n    });\n    return;\n  }));\n  return accountToAccountInfoMap;\n};\n\nexport { COMMON_TX_ERRORS, TOKEN_2022_PROGRAM_ID, TransactionError, checkTxSize, createAndTransferWSOLTransaction, createJitoTipTx, createUnwrapSolTransaction, deserializeAccount, deserializeMint, estimatePriorityFee, extractComputeUnitLimit, extractComputeUnitPrice, fetchMintInfos, fetchTokenMetadatas, findMetadataAddress, forwardToJito, getATA, getMultipleAccountsInfo, getOrCreateATAInstruction, getRandomTipAccount, getSignature, handleSendTransaction, modifyComputeUnitLimitIx, modifyComputeUnitPriceIx, parseErrorForTransaction, parseErrorWithIdl, removeEmptyChars, transactionSenderAndConfirmationWaiter };\n//# sourceMappingURL=optimist.esm.js.map\n"],"names":["safeIsNaN","Number","isNaN","value","areInputsEqual","newInputs","lastInputs","length","i","first","second","resultFn","isEqual","lastThis","lastResult","lastArgs","calledOnce","newArgs","_i","arguments","this","apply","TransactionError","Error","constructor","m","txid","code","programIds","serializedTx","super","Object","setPrototypeOf","prototype","COMMON_TX_ERRORS","PROGRAM_FAILED_TO_COMPLETE_ERROR","UNKNOWN_ERROR","TOO_MANY_ACCOUNT_LOCKS","INSUFFICIENT_FUNDS_FOR_RENT","TRANSACTION_TOO_LARGE","TRANSACTION_NOT_CONFIRMED","FROZEN_ACCOUNT","TRANSACTION_EXPIRED_BLOCKHEIGHT_EXCEEDED","SYSTEM_PROGRAM_ID","parseErrorForTransaction","err","logMessages","transactionError","errorCode","message","TOKEN_PROGRAM_ID","toBase58","instructionError","InstructionError","_","errorMsg","failedProgramIds","founds","found","match","RegExp","push","getFailedExceededInstructionsPrograms","Custom","failedProgramId","toString","getFailedProgram","getSystemProgramError","wait","time","Promise","resolve","setTimeout","SEND_OPTIONS","maxRetries","skipPreflight","async","forwardToJito","serializedTransaction","jitoTipTx","jitoProxyUrl","jitoResponse","fetch","method","headers","body","JSON","stringify","jsonrpc","id","params","bs58","encode","serialize","jitoResult","json","result","console","log","error","transactionSenderAndConfirmationWaiter","connection","blockhashWithBlockHeight","broadcastMode","controller","AbortController","abortSignal","signal","sendRawTransaction","aborted","e","warn","abortableResender","race","confirmTransaction","signature","tx","getSignatureStatus","searchTransactionHistory","confirmationStatus","TransactionExpiredBlockheightExceededError","response","abort","getTransaction","commitment","maxSupportedTransactionVersion","retry","retries","minTimeout","getSignature","transaction","signatures","bytes","handleSendTransaction","signedTransaction","blockhash","lastValidBlockHeight","idl","idlProgramId","minContextSlot","debug","Buffer","from","simulatedTransactionResponse","simulateTransaction","VersionedTransaction","compileMessage","replaceRecentBlockhash","logs","parseErrorWithIdl","undefined","transactionResponse","meta","errorParams","includes","errors","find","msg","name","JITO_TIP_ACCOUNTS","getRandomTipAccount","PublicKey","Math","floor","random","createJitoTipTx","payer","lamports","tipAccount","tipIx","SystemProgram","transfer","fromPubkey","toPubkey","BigInt","Transaction","add","ComputeBudgetProgram","setComputeUnitPrice","microLamports","feePayer","extractComputeUnitLimit","ix","compiledInstructions","programId","staticAccountKeys","programIdIndex","equals","data","decodedTI","TransactionInstruction","keys","ComputeBudgetInstruction","decodeSetComputeUnitLimit","units","instructions","extractComputeUnitPrice","decodeSetComputeUnitPrice","modifyComputeUnitLimitIx","newComputeUnitLimit","setComputeUnitLimit","Uint8Array","modifyComputeUnitPriceIx","newPriorityFee","estimatePriorityFee","writeableAccounts","accounts","idx","account","entries","isAccountWritable","instruction","isWritable","pubkey","concat","fees","getRecentPrioritizationFees","lockedWritableAccounts","sort","feeA","feeB","slot","slice","last20SortedFees","map","fee","prioritizationFee","max","checkTxSize","requireAllSignatures","PACKET_DATA_SIZE","deserializeAccount","accountInfo","AccountLayout","decode","mint","owner","amount","u64","fromBuffer","delegateOption","delegate","delegatedAmount","isInitialized","state","isFrozen","isNativeOption","rentExemptReserve","isNative","closeAuthorityOption","closeAuthority","deserializeMint","address","MintLayout","span","mintInfo","mintAuthorityOption","mintAuthority","supply","freezeAuthorityOption","freezeAuthority","getWSolATA","publicKey","wSolAddress","Token","getAssociatedTokenAddress","ASSOCIATED_TOKEN_PROGRAM_ID","NATIVE_MINT","getAccountInfo","createAndTransferWSOLTransaction","amountToTransferInLamports","wSolAccount","createAssociatedTokenAccountInstruction","createSyncNativeInstruction","createUnwrapSolTransaction","createCloseAccountInstruction","getATA","tokenMint","toAccount","getOrCreateATAInstruction","TOKEN_METADATA_PROGRAM_ID","TOKEN_2022_METADATA_PROGRAM_ID","findMetadataAddress","tokenProgramId","metadataProgramId","findProgramAddressSync","toBuffer","TOKEN_2022_PROGRAM_ID","fetchMintInfos","mints","rpc","getMultipleAccounts","reduce","acc","decimals","Array","removeEmptyChars","replace","fetchTokenMetadatas","tokens","metadataAddresses","t","keyedAccount","metadata","Metadata","deserialize","symbol","uri","getMultipleAccountsInfo","options","accountToAccountInfoMap","Map","array","all","ceil","index","chunk","forEach","set"],"sourceRoot":""}