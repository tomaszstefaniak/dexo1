{"version":3,"file":"main-4.0.1-50.js","mappings":"iHAAO,SAASA,EAAuBC,GACnC,MAAO,YAAaA,CACxB,C,2LCCO,MAAMC,EAAqB,EAAGC,WAAUC,WAAUC,SAAS,CAAEC,WAAY,iBAC5E,MAAMC,GAAa,IAAAC,UAAQ,IAAM,IAAI,EAAAC,WAAWL,EAAUC,IAAS,CAACD,EAAUC,IAC9E,OAAO,gBAAoB,IAAkBK,SAAU,CAAEC,MAAO,CAAEJ,eAAgBJ,EAAS,E,0BCHxF,SAASS,IACZ,MAAM,UAAEC,EAAS,gBAAEC,EAAe,oBAAEC,IAAwB,EAAAC,EAAA,KAC5D,OAAO,IAAAR,UAAQ,IAAMK,GAAaC,GAAmBC,EAC/C,CAAEF,YAAWC,kBAAiBC,4BAC9BE,GAAW,CAACJ,EAAWC,EAAiBC,GAClD,C,wECNO,MAAMG,EAAwB,wB,0MCUrC,MAAMC,UAAoBC,UACtB,WAAAC,CAAYC,EAASC,GACjB,IAAIC,EACJ,MAAM,QAAEC,EAAO,YAAEC,KAAgBC,GAASL,GACpC,KAAEM,GAASN,EACXO,EAAsB,IAAhBD,EAAKE,OAAeL,EAAU,YAAYG,EAAKG,KAAK,WAAWN,IAC3EO,MAAMN,GAAeG,GACF,MAAfH,IACAO,KAAKC,MAAQL,GACjBM,OAAOC,OAAOH,KAAMN,GACpBM,KAAKI,KAAOJ,KAAKZ,YAAYgB,KAC7BJ,KAAKV,SAAW,IACJC,IAAWA,EAAS,CAACF,KAAYC,KAEjD,EAYJ,SAASe,EAASC,GACd,MAAoB,iBAANA,GAAuB,MAALA,CACpC,CAIA,SAASC,EAAiBD,GACtB,OAAOD,EAASC,KAAOE,MAAMC,QAAQH,EACzC,CAcA,SAASI,EAAMhC,GACX,MAAqB,iBAAVA,EACAA,EAAMiC,WAEO,iBAAVjC,EAAqBkC,KAAKC,UAAUnC,GAAS,GAAGA,GAClE,CAYA,SAASoC,EAAUC,EAAQC,EAASC,EAAQvC,GACxC,IAAe,IAAXqC,EACA,QAEgB,IAAXA,EACLA,EAAS,CAAC,EAEa,iBAAXA,IACZA,EAAS,CAAEvB,QAASuB,IAExB,MAAM,KAAEpB,EAAI,OAAEuB,GAAWF,GACnB,KAAEG,GAASF,GACX,WAAEG,EAAU,QAAE5B,EAAU,8BAA8B2B,MAASC,EAAa,sBAAsBA,MAAiB,uBAAuBV,EAAMhC,QAAgBqC,EACtK,MAAO,CACHrC,QACAyC,OACAC,aACAC,IAAK1B,EAAKA,EAAKE,OAAS,GACxBF,OACAuB,YACGH,EACHvB,UAER,CAIA,SAAU8B,EAAWP,EAAQC,EAASC,EAAQvC,GAxE9C,IAAoB4B,EACTD,EADSC,EAyEAS,IAxEoC,mBAAvBT,EAAEiB,OAAOC,YAyElCT,EAAS,CAACA,IAEd,IAAK,MAAMU,KAAKV,EAAQ,CACpB,MAAM1B,EAAUyB,EAAUW,EAAGT,EAASC,EAAQvC,GAC1CW,UACMA,EAEd,CACJ,CAKA,SAAUqC,EAAIhD,EAAOuC,EAAQU,EAAU,CAAC,GACpC,MAAM,KAAEhC,EAAO,GAAE,OAAEuB,EAAS,CAACxC,GAAM,OAAEkD,GAAS,EAAK,KAAEC,GAAO,GAAUF,EAChEG,EAAM,CAAEnC,OAAMuB,SAAQW,QACxBD,IACAlD,EAAQuC,EAAOc,QAAQrD,EAAOoD,IAElC,IAAIE,EAAS,QACb,IAAK,MAAM3C,KAAW4B,EAAOgB,UAAUvD,EAAOoD,GAC1CzC,EAAQI,YAAckC,EAAQnC,QAC9BwC,EAAS,iBACH,CAAC3C,OAASL,GAEpB,IAAK,IAAKkD,EAAGC,EAAGC,KAAMnB,EAAOoB,QAAQ3D,EAAOoD,GAAM,CAC9C,MAAMQ,EAAKZ,EAAIS,EAAGC,EAAG,CACjBzC,UAAYX,IAANkD,EAAkBvC,EAAO,IAAIA,EAAMuC,GACzChB,YAAclC,IAANkD,EAAkBhB,EAAS,IAAIA,EAAQiB,GAC/CP,SACAC,OACArC,QAASmC,EAAQnC,UAErB,IAAK,MAAM+C,KAAKD,EACRC,EAAE,IACFP,EAA4B,MAAnBO,EAAE,GAAGnB,WAAqB,cAAgB,iBAC7C,CAACmB,EAAE,QAAIvD,IAER4C,IACLO,EAAII,EAAE,QACIvD,IAANkD,EACAxD,EAAQyD,EAEHzD,aAAiB8D,IACtB9D,EAAM+D,IAAIP,EAAGC,GAERzD,aAAiBgE,IACtBhE,EAAMiE,IAAIR,GAEL9B,EAAS3B,UACJM,IAANmD,GAAmBD,KAAKxD,KACxBA,EAAMwD,GAAKC,GAI/B,CACA,GAAe,cAAXH,EACA,IAAK,MAAM3C,KAAW4B,EAAO2B,QAAQlE,EAAOoD,GACxCzC,EAAQI,YAAckC,EAAQnC,QAC9BwC,EAAS,mBACH,CAAC3C,OAASL,GAGT,UAAXgD,SACM,MAAChD,EAAWN,GAE1B,CAOA,MAAMmE,EACF,WAAAzD,CAAY0D,GACR,MAAM,KAAE3B,EAAI,OAAE4B,EAAM,UAAEd,EAAS,QAAEW,EAAO,QAAEb,EAAWrD,GAAUA,EAAK,QAAE2D,EAAU,YAAe,GAAOS,EACtG9C,KAAKmB,KAAOA,EACZnB,KAAK+C,OAASA,EACd/C,KAAKqC,QAAUA,EACfrC,KAAK+B,QAAUA,EAEX/B,KAAKiC,UADLA,EACiB,CAACvD,EAAOsC,IAEdM,EADQW,EAAUvD,EAAOsC,GACNA,EAAShB,KAAMtB,GAI5B,IAAM,GAGvBsB,KAAK4C,QADLA,EACe,CAAClE,EAAOsC,IAEZM,EADQsB,EAAQlE,EAAOsC,GACJA,EAAShB,KAAMtB,GAI9B,IAAM,EAE7B,CAIA,MAAAsE,CAAOtE,EAAOc,GACV,OAAOwD,EAAOtE,EAAOsB,KAAMR,EAC/B,CAIA,MAAAyD,CAAOvE,EAAOc,GACV,OAAOyD,EAAOvE,EAAOsB,KAAMR,EAC/B,CAIA,EAAA0D,CAAGxE,GACC,OAAOwE,EAAGxE,EAAOsB,KACrB,CAMA,IAAA6B,CAAKnD,EAAOc,GACR,OAuCR,SAAcd,EAAOuC,EAAQzB,GACzB,MAAMuB,EAASoC,EAASzE,EAAOuC,EAAQ,CAAEW,QAAQ,EAAMC,MAAM,EAAMrC,YACnE,GAAIuB,EAAO,GACP,MAAMA,EAAO,GAGb,OAAOA,EAAO,EAEtB,CA/Cec,CAAKnD,EAAOsB,KAAMR,EAC7B,CAUA,QAAA2D,CAASzE,EAAOiD,EAAU,CAAC,GACvB,OAAOwB,EAASzE,EAAOsB,KAAM2B,EACjC,EAKJ,SAASqB,EAAOtE,EAAOuC,EAAQzB,GAC3B,MAAMuB,EAASoC,EAASzE,EAAOuC,EAAQ,CAAEzB,YACzC,GAAIuB,EAAO,GACP,MAAMA,EAAO,EAErB,CAIA,SAASkC,EAAOvE,EAAOuC,EAAQzB,GAC3B,MAAMuB,EAASoC,EAASzE,EAAOuC,EAAQ,CAAEW,QAAQ,EAAMpC,YACvD,GAAIuB,EAAO,GACP,MAAMA,EAAO,GAGb,OAAOA,EAAO,EAEtB,CAgBA,SAASmC,EAAGxE,EAAOuC,GAEf,OADekC,EAASzE,EAAOuC,GAChB,EACnB,CAKA,SAASkC,EAASzE,EAAOuC,EAAQU,EAAU,CAAC,GACxC,MAAMyB,EAAS1B,EAAIhD,EAAOuC,EAAQU,GAC5B0B,EA5NV,SAAuBC,GACnB,MAAM,KAAEC,EAAI,MAAE7E,GAAU4E,EAAME,OAC9B,OAAOD,OAAOvE,EAAYN,CAC9B,CAyNkB+E,CAAcL,GAC5B,OAAIC,EAAM,GAQC,CAPO,IAAInE,EAAYmE,EAAM,IAAI,YACpC,IAAK,MAAMd,KAAKa,EACRb,EAAE,WACIA,EAAE,GAGpB,SACevD,GAIR,MAACA,EADEqE,EAAM,GAGxB,CAWA,SAASK,EAAOtD,EAAM6B,GAClB,OAAO,IAAIY,EAAO,CAAE1B,KAAMf,EAAM2C,OAAQ,KAAMd,aAClD,CAoJA,SAAS0B,IACL,OAAOD,EAAO,OAAO,KAAM,GAC/B,CACA,SAASE,EAAMC,GACX,OAAO,IAAIhB,EAAO,CACd1B,KAAM,QACN4B,OAAQc,EACR,QAACxB,CAAQ3D,GACL,GAAImF,GAAWrD,MAAMC,QAAQ/B,GACzB,IAAK,MAAOoF,EAAG3B,KAAMzD,EAAM2D,eACjB,CAACyB,EAAG3B,EAAG0B,EAGzB,EACA9B,QAAQrD,GACG8B,MAAMC,QAAQ/B,GAASA,EAAMqF,QAAUrF,EAElDuD,UAAUvD,GACE8B,MAAMC,QAAQ/B,IAClB,0CAA0CgC,EAAMhC,MAGhE,CAYA,SAASsF,IACL,OAAON,EAAO,WAAYhF,GACE,kBAAVA,GAEtB,CAwCA,SAASuF,EAASC,GACd,OAAOR,EAAO,YAAahF,GACfA,aAAiBwF,GACrB,gBAAgBA,EAAM9D,kCAAkCM,EAAMhC,MAE1E,CAkCA,SAASyF,EAAQC,GACb,MAAMC,EAAc3D,EAAM0D,GACpB7B,SAAW6B,EACjB,OAAO,IAAIvB,EAAO,CACd1B,KAAM,UACN4B,OAAc,WAANR,GAAwB,WAANA,GAAwB,YAANA,EAAkB6B,EAAW,KACzEnC,UAAUvD,GACEA,IAAU0F,GACd,0BAA0BC,sBAAgC3D,EAAMhC,MAGhF,CA+BA,SAAS4F,EAASrD,GACd,OAAO,IAAI4B,EAAO,IACX5B,EACHgB,UAAW,CAACvD,EAAOoD,IAAkB,OAAVpD,GAAkBuC,EAAOgB,UAAUvD,EAAOoD,GACrEc,QAAS,CAAClE,EAAOoD,IAAkB,OAAVpD,GAAkBuC,EAAO2B,QAAQlE,EAAOoD,IAEzE,CAIA,SAASyC,IACL,OAAOb,EAAO,UAAWhF,GACK,iBAAVA,IAAuB8F,MAAM9F,IACzC,oCAAoCgC,EAAMhC,MAEtD,CA6CA,SAAS+F,EAASxD,GACd,OAAO,IAAI4B,EAAO,IACX5B,EACHgB,UAAW,CAACvD,EAAOoD,SAAkB9C,IAAVN,GAAuBuC,EAAOgB,UAAUvD,EAAOoD,GAC1Ec,QAAS,CAAClE,EAAOoD,SAAkB9C,IAAVN,GAAuBuC,EAAO2B,QAAQlE,EAAOoD,IAE9E,CAOA,SAAS4C,EAAOC,EAAKC,GACjB,OAAO,IAAI/B,EAAO,CACd1B,KAAM,SACN4B,OAAQ,KACR,QAACV,CAAQ3D,GACL,GAAI2B,EAAS3B,GACT,IAAK,MAAMwD,KAAKxD,EAAO,CACnB,MAAMyD,EAAIzD,EAAMwD,QACV,CAACA,EAAGA,EAAGyC,QACP,CAACzC,EAAGC,EAAGyC,EACjB,CAER,EACA3C,UAAUvD,GACE6B,EAAiB7B,IACrB,qCAAqCgC,EAAMhC,KAEnDqD,QAAQrD,GACG6B,EAAiB7B,GAAS,IAAKA,GAAUA,GAG5D,CAmCA,SAASmG,IACL,OAAOnB,EAAO,UAAWhF,GACI,iBAAVA,GACX,oCAAoCgC,EAAMhC,MAEtD,CAKA,SAAS2E,EAAMyB,GACX,MAAMC,EAjJCrB,EAAO,SAAS,KAAM,IAkJ7B,OAAO,IAAIb,EAAO,CACd1B,KAAM,QACN4B,OAAQ,KACR,QAACV,CAAQ3D,GACL,GAAI8B,MAAMC,QAAQ/B,GAAQ,CACtB,MAAMmB,EAASmF,KAAKC,IAAIH,EAAQjF,OAAQnB,EAAMmB,QAC9C,IAAK,IAAIiE,EAAI,EAAGA,EAAIjE,EAAQiE,SAClB,CAACA,EAAGpF,EAAMoF,GAAIgB,EAAQhB,IAAMiB,EAE1C,CACJ,EACA9C,UAAUvD,GACE8B,MAAMC,QAAQ/B,IAClB,oCAAoCgC,EAAMhC,KAElDqD,QAAQrD,GACG8B,MAAMC,QAAQ/B,GAASA,EAAMqF,QAAUrF,GAG1D,CAOA,SAASyC,EAAK4B,GACV,MAAMmC,EAAOhF,OAAOgF,KAAKnC,GACzB,OAAO,IAAIF,EAAO,CACd1B,KAAM,OACN4B,SACA,QAACV,CAAQ3D,GACL,GAAI2B,EAAS3B,GACT,IAAK,MAAMwD,KAAKgD,OACN,CAAChD,EAAGxD,EAAMwD,GAAIa,EAAOb,GAGvC,EACAD,UAAUvD,GACE6B,EAAiB7B,IACrB,qCAAqCgC,EAAMhC,KAEnDqD,QAAQrD,GACG6B,EAAiB7B,GAAS,IAAKA,GAAUA,GAG5D,CAIA,SAASyG,EAAML,GACX,MAAMT,EAAcS,EAAQM,KAAKhD,GAAMA,EAAEjB,OAAMrB,KAAK,OACpD,OAAO,IAAI+C,EAAO,CACd1B,KAAM,QACN4B,OAAQ,KACR,OAAAhB,CAAQrD,EAAOoD,GACX,IAAK,MAAMuD,KAAKP,EAAS,CACrB,MAAOQ,EAAOC,GAAWF,EAAElC,SAASzE,EAAO,CACvCkD,QAAQ,EACRC,KAAMC,EAAID,OAEd,IAAKyD,EACD,OAAOC,CAEf,CACA,OAAO7G,CACX,EACA,SAAAuD,CAAUvD,EAAOoD,GACb,MAAMxC,EAAW,GACjB,IAAK,MAAM+F,KAAKP,EAAS,CACrB,SAAU1B,GAAU1B,EAAIhD,EAAO2G,EAAGvD,IAC3B0D,GAASpC,EAChB,IAAKoC,EAAM,GACP,MAAO,GAGP,IAAK,MAAOnG,KAAY+D,EAChB/D,GACAC,EAASmG,KAAKpG,EAI9B,CACA,MAAO,CACH,8CAA8CgF,sBAAgC3D,EAAMhC,QACjFY,EAEX,GAER,CAIA,SAASoG,IACL,OAAOhC,EAAO,WAAW,KAAM,GACnC,CAYA,SAAS9B,EAAOX,EAAQ0E,EAAW5D,GAC/B,OAAO,IAAIc,EAAO,IACX5B,EACHc,QAAS,CAACrD,EAAOoD,IACNoB,EAAGxE,EAAOiH,GACX1E,EAAOc,QAAQA,EAAQrD,EAAOoD,GAAMA,GACpCb,EAAOc,QAAQrD,EAAOoD,IAGxC,C,uECh3BO,MAAM8D,GAAoB,IAAAC,eAAc,CAAC,GACzC,SAASC,IACZ,OAAO,IAAAC,YAAWH,EACtB,C,kBCJA,IAAII,EAAQ,EAAQ,OAGpBC,EAAOC,QAAUF,EAFF,6D,0ECAR,SAASG,EAAgB9E,EAAK+E,GACjC,MAAMC,GAAQ,IAAAC,WAAS,KACnB,IACI,MAAM5H,EAAQ6H,aAAaC,QAAQnF,GACnC,GAAI3C,EACA,OAAOkC,KAAK6F,MAAM/H,EAC1B,CACA,MAAO4G,GACmB,oBAAXoB,QACPC,EAAQrB,MAAMA,EAEtB,CACA,OAAOc,CAAY,IAEjB1H,EAAQ2H,EAAM,GACdO,GAAmB,IAAAC,SAAO,GAoBhC,OAnBA,IAAAC,YAAU,KACN,GAAIF,EAAiBG,QACjBH,EAAiBG,SAAU,OAG/B,IACkB,OAAVrI,EACA6H,aAAaS,WAAW3F,GAGxBkF,aAAaU,QAAQ5F,EAAKT,KAAKC,UAAUnC,GAEjD,CACA,MAAO4G,GACmB,oBAAXoB,QACPC,EAAQrB,MAAMA,EAEtB,IACD,CAAC5G,EAAO2C,IACJgF,CACX,C,gEC/BO,MAAMa,E,SAAkC,E,wDCLxC,MAAMC,EAAoB,qBCApBC,EAAe,gBCAf,EAAuB,iBCE7B,SAASC,EAAchJ,GAC1B,OAAQA,GACJ,IAAK,YACL,IAAK,YACL,IAAK,YACL,UAAKW,EACD,OAAOX,EACX,IAAK,SACD,MAAO,YACX,IAAK,SACL,IAAK,eACD,MAAO,YACX,IAAK,MACL,IAAK,OACD,MAAO,YACX,QACI,OAEZ,C,ICVIiJ,EAAkCC,EAAgCC,EAAkCC,EAAmCC,EAAsCC,EAA4BC,EAAqDC,EAA+BC,EAAmCC,EAAgCC,EAAkCC,EAAqCC,EAA8BC,EAAgCC,EAAwCC,EAA4CC,EAAoCC,E,kEAX7lBC,EAAkE,SAAUC,EAAUpC,EAAOqC,EAAMC,GACnG,GAAa,MAATD,IAAiBC,EAAG,MAAM,IAAIxJ,UAAU,iDAC5C,GAAqB,mBAAVkH,EAAuBoC,IAAapC,IAAUsC,GAAKtC,EAAMuC,IAAIH,GAAW,MAAM,IAAItJ,UAAU,4EACvG,MAAgB,MAATuJ,EAAeC,EAAa,MAATD,EAAeC,EAAEE,KAAKJ,GAAYE,EAAIA,EAAEjK,MAAQ2H,EAAMyC,IAAIL,EACxF,EACIM,EAAkE,SAAUN,EAAUpC,EAAO3H,EAAOgK,EAAMC,GAC1G,GAAa,MAATD,EAAc,MAAM,IAAIvJ,UAAU,kCACtC,GAAa,MAATuJ,IAAiBC,EAAG,MAAM,IAAIxJ,UAAU,iDAC5C,GAAqB,mBAAVkH,EAAuBoC,IAAapC,IAAUsC,GAAKtC,EAAMuC,IAAIH,GAAW,MAAM,IAAItJ,UAAU,2EACvG,MAAiB,MAATuJ,EAAeC,EAAEE,KAAKJ,EAAU/J,GAASiK,EAAIA,EAAEjK,MAAQA,EAAQ2H,EAAM5D,IAAIgG,EAAU/J,GAASA,CACxG,EAUO,MAAMsK,UAA8B,KACvC,QAAI5I,GACA,OAAOoI,EAAuBxI,KAAM6H,EAA+B,KAAKzH,IAC5E,CACA,OAAI6I,GACA,MAAO,gDACX,CACA,QAAIC,GACA,OAAOV,EAAuBxI,KAAM6H,EAA+B,KAAKqB,IAC5E,CACA,cAAIC,GACA,OAAOX,EAAuBxI,KAAM8H,EAAmC,IAC3E,CACA,aAAIlJ,GACA,OAAO4J,EAAuBxI,KAAMwH,EAAkC,IAC1E,CACA,cAAI4B,GACA,OAAOZ,EAAuBxI,KAAMyH,EAAmC,IAC3E,CACA,gCAAI4B,GACA,OAAOb,EAAuBxI,KAAM4H,EAAqD,IAC7F,CACA,UAAI0B,GACA,OAAOd,EAAuBxI,KAAM6H,EAA+B,IACvE,CACA,YAAI0B,GACA,OAAO,CACX,CACA,WAAAnK,EAAY,OAAEkK,IACVvJ,QACAuH,EAAiC3E,IAAI3C,MACrCuH,EAA+B9E,IAAIzC,UAAM,GACzCwH,EAAiC/E,IAAIzC,UAAM,GAC3CyH,EAAkChF,IAAIzC,UAAM,GAC5C0H,EAAqCjF,IAAIzC,UAAM,GAC/C2H,EAA2BlF,IAAIzC,UAAM,GACrC4H,EAAoDnF,IAAIzC,UAAM,GAC9D6H,EAA8BpF,IAAIzC,UAAM,GACxC8H,EAAkCrF,IAAIzC,KAAwB,oBAAX0G,QAA8C,oBAAb8C,SAC9E,KAAiBC,YACjB,KAAiBC,WACvBvB,EAA+B1F,IAAIzC,MAAO2J,IAEtC,GAAI,aAAcA,EAAY,CAC1B,MAAMC,EAAUpB,EAAuBxI,KAAM6H,EAA+B,KAAKgC,SAAS,GAEtFrB,EAAuBxI,KAAMuH,EAAgC,OAASiB,EAAuBxI,KAAM0H,EAAsC,MAAQkC,IAAYpB,EAAuBxI,KAAMuH,EAAgC,OAEtNqC,EAEApB,EAAuBxI,KAAMsH,EAAkC,IAAKU,GAAkCa,KAAK7I,KAAM4J,IAIjH5J,KAAK8J,KAAK,QAAS,IAAI,MAEvBtB,EAAuBxI,KAAMsH,EAAkC,IAAKW,GAAqCY,KAAK7I,OAG1H,CAEI,aAAc2J,GACdnB,EAAuBxI,KAAMsH,EAAkC,IAAKY,GAA8BW,KAAK7I,KAC3G,IAEJ+I,EAAuB/I,KAAM6H,EAA+ByB,EAAQ,KACpEP,EAAuB/I,KAAMuH,EAAgC,KAAM,KACnEwB,EAAuB/I,KAAMwH,EAAkC,KAAM,KACrEuB,EAAuB/I,KAAMyH,GAAmC,EAAO,KACvEsB,EAAuB/I,KAAM0H,GAAsC,EAAO,KAC1EqB,EAAuB/I,KAAM2H,EAA4Ba,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAAgBC,GAAG,SAAUxB,EAAuBxI,KAAMmI,EAAgC,MAAO,KACpOK,EAAuBxI,KAAMsH,EAAkC,IAAKY,GAA8BW,KAAK7I,KAC3G,CACA,OAAAiK,GACIlB,EAAuB/I,KAAMuH,EAAgC,KAAM,KACnEwB,EAAuB/I,KAAMwH,EAAkC,KAAM,KACrEuB,EAAuB/I,KAAMyH,GAAmC,EAAO,KACvEsB,EAAuB/I,KAAM0H,GAAsC,EAAO,KAC1E,MAAMwC,EAAM1B,EAAuBxI,KAAM2H,EAA4B,KACjEuC,IACAnB,EAAuB/I,KAAM2H,EAA4B,KAAM,KAC/DuC,IAER,CACA,iBAAMC,GACF,OAAO3B,EAAuBxI,KAAMsH,EAAkC,IAAKS,GAAgCc,KAAK7I,KAAM,CAAEoK,QAAQ,GACpI,CACA,aAAMC,GACF,OAAO7B,EAAuBxI,KAAMsH,EAAkC,IAAKS,GAAgCc,KAAK7I,KACpH,CACA,gBAAMsK,GACF,GAAI,OAAsB9B,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SACvF,IACIhB,EAAuB/I,KAAM0H,GAAsC,EAAM,WACnEc,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAAoBO,YACxG,CACA,MAAOhF,GACHtF,KAAK8J,KAAK,QAAS,IAAI,KAAyBxE,GAAO9F,QAAS8F,GACpE,CACA,QACIyD,EAAuB/I,KAAM0H,GAAsC,EAAO,IAC9E,CAEJc,EAAuBxI,KAAMsH,EAAkC,IAAKW,GAAqCY,KAAK7I,KAClH,CACA,qBAAMuK,CAAgBvM,EAAaM,EAAYqD,EAAU,CAAC,GACtD,IACI,MAAMiI,EAAUpB,EAAuBxI,KAAMuH,EAAgC,KAC7E,IAAKqC,EACD,MAAM,IAAI,KACd,IAAIY,EACJ,GAAI,OAAgChC,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SACjG,GAAIH,EAAQG,SAASU,SAAS,KAC1BD,EAAU,QAET,MAAI,OAAyBhC,EAAuBxI,KAAM6H,EAA+B,KAAKkC,YAC/FH,EAAQG,SAASU,SAAS,KAI1B,MAAM,IAAI,KAHVD,EAAU,GAId,KAEC,MAAI,OAAyBhC,EAAuBxI,KAAM6H,EAA+B,KAAKkC,UAM/F,MAAM,IAAI,KALV,IAAKH,EAAQG,SAASU,SAAS,KAC3B,MAAM,IAAI,KACdD,EAAU,GAId,CACA,MAAME,GC3IkBvM,ED2IUG,EAAWqM,aC1IxCF,SAXe,uCAYjB,EACP,cAAcG,KAAKzM,GHZQ,gBGc3B,eAAeyM,KAAKzM,GHZQ,iBGc5B,iBAAiByM,KAAKzM,IAAa,mBAAmByM,KAAKzM,GHZ9B,kBGc1B,EDmIC,IAAKyL,EAAQiB,OAAOJ,SAASC,GACzB,MAAM,IAAI,KACd,IACI,MAAM,QAAEI,KAAYC,GAAgBpJ,EACpC,IAAIqJ,EAaJ,IAZI,OAAuBhN,IACvB8M,GAASjL,QAAU7B,EAAYiN,KAAKH,GACpCE,EAAwBhN,EAAYkN,cAGpClN,QAAqBgC,KAAKmL,mBAAmBnN,EAAaM,EAAYyM,GACtED,GAASjL,QAAU7B,EAAYoN,eAAeN,GAC9CE,EAAwB,IAAIK,WAAWrN,EAAYkN,UAAU,CACzDI,sBAAsB,EACtBC,kBAAkB,MAGtBf,IAAY,IAA8B,CAC1C,MAAOgB,SAAgBhD,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAA8B0B,uBAAuB,CAClJ7B,UACAc,QACA1M,YAAagN,EACbrJ,QAAS,CACL+J,oBAAqBrE,EAAc0D,EAAYW,qBAAuBpN,EAAWD,YACjFsN,cAAeZ,EAAYY,cAC3BC,WAAYb,EAAYa,WACxBC,eAAgBd,EAAYc,kBAGpC,OAAO,IAAKC,OAAON,EAAOO,UAC9B,CACK,CACD,MAAOP,SAAgBhD,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAAuBlL,gBAAgB,CACpI+K,UACAc,QACA1M,YAAagN,EACbrJ,QAAS,CACL+J,oBAAqBrE,EAAc0D,EAAYW,qBAAuBpN,EAAWD,YACjFwN,eAAgBd,EAAYc,kBAGpC,aAAavN,EAAW0N,mBAAmBR,EAAOS,kBAAmB,IAC9DlB,EACHW,oBAAqBrE,EAAc0D,EAAYW,qBAAuBpN,EAAWD,aAEzF,CACJ,CACA,MAAOiH,GACH,GAAIA,aAAiB,KACjB,MAAMA,EACV,MAAM,IAAI,KAA2BA,GAAO9F,QAAS8F,EACzD,CACJ,CACA,MAAOA,GAEH,MADAtF,KAAK8J,KAAK,QAASxE,GACbA,CACV,CCpMD,IAA6BnH,CDqMhC,EAEJoJ,EAAiC,IAAI2E,QAAW1E,EAAmC,IAAI0E,QAAWzE,EAAoC,IAAIyE,QAAWxE,EAAuC,IAAIwE,QAAWvE,EAA6B,IAAIuE,QAAWtE,EAAsD,IAAIsE,QAAWrE,EAAgC,IAAIqE,QAAWpE,EAAoC,IAAIoE,QAAW/D,EAAiC,IAAI+D,QAAW5E,EAAmC,IAAI6E,QAAWpE,EAAiCqE,eAA8C9I,GAC3kB,IACI,GAAItD,KAAKqM,WAAarM,KAAKoJ,WACvB,OACJ,GAAIZ,EAAuBxI,KAAM8H,EAAmC,OAAS,KAAiB4B,UAC1F,MAAM,IAAI,KAEd,GADAX,EAAuB/I,KAAMyH,GAAmC,EAAM,MACjEe,EAAuBxI,KAAM6H,EAA+B,KAAKgC,SAAShK,OAC3E,UACU2I,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAAiBM,QAAQ/G,EAC7G,CACA,MAAOgC,GACH,MAAM,IAAI,KAAsBA,GAAO9F,QAAS8F,EACpD,CAEJ,MAAMsE,EAAUpB,EAAuBxI,KAAM6H,EAA+B,KAAKgC,SAAS,GAC1F,IAAKD,EACD,MAAM,IAAI,KACdpB,EAAuBxI,KAAMsH,EAAkC,IAAKU,GAAkCa,KAAK7I,KAAM4J,EACrH,CACA,MAAOtE,GAEH,MADAtF,KAAK8J,KAAK,QAASxE,GACbA,CACV,CACA,QACIyD,EAAuB/I,KAAMyH,GAAmC,EAAO,IAC3E,CACJ,EAAGO,EAAmC,SAA0C4B,GAC5E,IAAIhL,EACJ,IAEIA,EAAY,IAAI,EAAA0N,UAAU1C,EAAQ2C,QACtC,CACA,MAAOjH,GACH,MAAM,IAAI,KAAqBA,GAAO9F,QAAS8F,EACnD,CACAyD,EAAuB/I,KAAMuH,EAAgCqC,EAAS,KACtEb,EAAuB/I,KAAMwH,EAAkC5I,EAAW,KAC1E4J,EAAuBxI,KAAMsH,EAAkC,IAAKY,GAA8BW,KAAK7I,MACvGA,KAAK8J,KAAK,UAAWlL,EACzB,EAAGqJ,EAAsC,WACrCc,EAAuB/I,KAAMuH,EAAgC,KAAM,KACnEwB,EAAuB/I,KAAMwH,EAAkC,KAAM,KACrEgB,EAAuBxI,KAAMsH,EAAkC,IAAKY,GAA8BW,KAAK7I,MACvGA,KAAK8J,KAAK,aACd,EAAG5B,EAA+B,WAC9B,MAAMmB,EAA+B,OAAgCb,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAChIvB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAA8BV,6BACxGb,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAAuBV,6BACvGN,EAAuB/I,KAAM4H,GAAqD,QAAYyB,EAA8B,CAAC,WACvH,KACA,IAAI3G,IAAI2G,GAA+B,KACzC,OAAyBb,EAAuBxI,KAAM6H,EAA+B,KAAKkC,UAAYvB,EAAuBxI,KAAMuH,EAAgC,MAAMwC,SAASU,SAAS,MAC3LzK,KAAKnB,gBAAkB2J,EAAuBxI,KAAMsH,EAAkC,IAAKc,GAC3FpI,KAAKlB,oBAAsB0J,EAAuBxI,KAAMsH,EAAkC,IAAKe,YAGxFrI,KAAKnB,uBACLmB,KAAKlB,qBAEZqI,KAAqBqB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,UAAYvB,EAAuBxI,KAAMuH,EAAgC,MAAMwC,SAASU,SAAStD,GACvLnH,KAAKwM,YAAchE,EAAuBxI,KAAMsH,EAAkC,IAAKgB,UAGhFtI,KAAKwM,YAEZpF,KAAgBoB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SACjF/J,KAAKyM,OAASjE,EAAuBxI,KAAMsH,EAAkC,IAAKiB,UAG3EvI,KAAKyM,MAEpB,EAAGrE,EAAyCgE,eAAsDpO,GAC9F,IACI,MAAM4L,EAAUpB,EAAuBxI,KAAMuH,EAAgC,KAC7E,IAAKqC,EACD,MAAM,IAAI,KACd,KAAM,OAAyBpB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,UAC5F,MAAM,IAAI,KACd,IAAKH,EAAQG,SAASU,SAAS,KAC3B,MAAM,IAAI,KACd,IACI,MASMO,SAT2BxC,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAAuBlL,gBAAgB,CAC9I+K,UACA5L,aAAa,OAAuBA,GAC9BA,EAAYkN,YACZ,IAAIG,WAAWrN,EAAYkN,UAAU,CACnCI,sBAAsB,EACtBC,kBAAkB,QAGmB,GAAGU,kBACpD,OAAQ,OAAuBjO,GACzB,EAAA0O,qBAAqBC,YAAY3B,GACjC,EAAA4B,YAAYC,KAAK7B,EAC3B,CACA,MAAO1F,GACH,GAAIA,aAAiB,KACjB,MAAMA,EACV,MAAM,IAAI,KAA2BA,GAAO9F,QAAS8F,EACzD,CACJ,CACA,MAAOA,GAEH,MADAtF,KAAK8J,KAAK,QAASxE,GACbA,CACV,CACJ,EAAG+C,EAA6C+D,eAA0DU,GACtG,IACI,MAAMlD,EAAUpB,EAAuBxI,KAAMuH,EAAgC,KAC7E,IAAKqC,EACD,MAAM,IAAI,KACd,KAAM,OAAyBpB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,UAC5F,MAAM,IAAI,KACd,IAAKH,EAAQG,SAASU,SAAS,KAC3B,MAAM,IAAI,KACd,IACI,MAAMsC,QAA2BvE,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS,KAAuBlL,mBAAmBiO,EAAa1H,KAAKpH,IAAgB,CACnL4L,UACA5L,aAAa,OAAuBA,GAC9BA,EAAYkN,YACZ,IAAIG,WAAWrN,EAAYkN,UAAU,CACnCI,sBAAsB,EACtBC,kBAAkB,UAG9B,OAAOuB,EAAa1H,KAAI,CAACpH,EAAagP,KAClC,MAAMf,EAAoBc,EAAmBC,GAAOf,kBACpD,OAAQ,OAAuBjO,GACzB,EAAA0O,qBAAqBC,YAAYV,GACjC,EAAAW,YAAYC,KAAKZ,EAAmB,GAElD,CACA,MAAO3G,GACH,MAAM,IAAI,KAA2BA,GAAO9F,QAAS8F,EACzD,CACJ,CACA,MAAOA,GAEH,MADAtF,KAAK8J,KAAK,QAASxE,GACbA,CACV,CACJ,EAAGgD,EAAqC8D,eAAkD5M,GACtF,IACI,MAAMoK,EAAUpB,EAAuBxI,KAAMuH,EAAgC,KAC7E,IAAKqC,EACD,MAAM,IAAI,KACd,KAAMzC,KAAqBqB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,UACxF,MAAM,IAAI,KACd,IAAKH,EAAQG,SAASU,SAAStD,GAC3B,MAAM,IAAI,KACd,IAKI,aAJ6BqB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS5C,GAAmBqF,YAAY,CAClI5C,UACApK,aAEkB,GAAGuM,SAC7B,CACA,MAAOzG,GACH,MAAM,IAAI,KAAuBA,GAAO9F,QAAS8F,EACrD,CACJ,CACA,MAAOA,GAEH,MADAtF,KAAK8J,KAAK,QAASxE,GACbA,CACV,CACJ,EAAGiD,EAAgC6D,eAA6C9I,EAAQ,CAAC,GACrF,IACI,KAAM8D,KAAgBoB,EAAuBxI,KAAM6H,EAA+B,KAAKkC,UACnF,MAAM,IAAI,KACd,IAAIyB,EACJ,KACKA,SAAgBhD,EAAuBxI,KAAM6H,EAA+B,KAAKkC,SAAS3C,GAAcqF,OAAOnJ,EACpH,CACA,MAAOgC,GACH,MAAM,IAAI,KAAkBA,GAAO9F,QAAS8F,EAChD,CACA,IAAKkG,EACD,MAAM,IAAI,KAEd,OADAhD,EAAuBxI,KAAMsH,EAAkC,IAAKU,GAAkCa,KAAK7I,KAAMwL,EAAO5B,SACjH4B,CACX,CACA,MAAOlG,GAEH,MADAtF,KAAK8J,KAAK,QAASxE,GACbA,CACV,CACJ,E,IEzYW2H,E,iCCoCX,SAASC,EAAYC,GACjB,MAAMC,GAAM,IAAAvG,aAAO7H,GAInB,YAHoBA,IAAhBoO,EAAIrG,UACJqG,EAAIrG,QAAU,CAAErI,MAAOyO,MAEpBC,EAAIrG,QAAQrI,KACvB,CAQA,SAAS2O,EAAwBC,GAC7B,OAAOA,EAAQC,OAAOrG,GAAiC9B,KAAKkE,GAAW,IAAIN,EAAsB,CAAEM,YACvG,EDnDA,SAAW2D,GACPA,EAAYA,EAAyB,YAAI,GAAK,cAC9CA,EAAYA,EAAwB,WAAI,GAAK,YAChD,CAHD,CAGGA,IAAgBA,EAAc,CAAC,I,2DEF3B,SAASO,GAAmB,SAAEtP,EAAUoP,QAASG,EAAQ,QAAEC,EAAO,eAAEC,EAAc,qBAAEC,EAAoB,eAAEC,EAAc,QAAEC,EAAO,eAAEC,IACtI,MAAMC,GAAkB,IAAAnH,SAAO,IACxBuC,EAAY6E,IAAiB,IAAA3H,WAAS,GACvC4H,GAAqB,IAAArH,SAAO,IAC3BsH,EAAeC,IAAoB,IAAA9H,WAAS,IAC5C1H,EAAWyP,IAAgB,IAAA/H,WAAS,IAAMoH,GAAS9O,WAAa,QAChEyN,EAAWiC,IAAgB,IAAAhI,WAAS,IAAMoH,GAASrB,YAAa,IAKjEkC,GAAa,IAAA1H,QAAOiH,IAC1B,IAAAhH,YAAU,KACNyH,EAAWxH,QAAU+G,EACd,KACHS,EAAWxH,aAAU/H,CAAS,IAEnC,CAAC8O,IACJ,MAAMU,GAAiB,IAAA3H,SAAO,CAACvB,EAAOoI,KAC7BC,EAAe5G,UACZwH,EAAWxH,QACXwH,EAAWxH,QAAQzB,EAAOoI,IAG1B,EAAQpI,MAAMA,EAAOoI,GACjBpI,aAAiB,MAAyC,oBAAXoB,QAA0BgH,GACzEhH,OAAO+H,KAAKf,EAAQzE,IAAK,YAI9B3D,MAGJgI,EAASoB,IAAc,IAAApI,WAAS,IAAMmH,EACxCrI,KAAKsI,IAAY,CAClBA,UACAvE,WAAYuE,EAAQvE,eAEnBoE,QAAO,EAAGpE,gBAAiBA,IAAe,KAAiBM,iBAEhE,IAAA3C,YAAU,KAcN,SAAS6H,EAAuBxF,GAC5BuF,GAAYE,IACR,MAAM5B,EAAQ4B,EAAYC,WAAU,EAAGnB,aAAcA,IAAY1N,OACjE,IAAe,IAAXgN,EACA,OAAO4B,EAEX,MAAM,QAAElB,GAAYkB,EAAY5B,GAChC,MAAO,IACA4B,EAAY7K,MAAM,EAAGiJ,GACxB,CAAEU,UAASvE,iBACRyF,EAAY7K,MAAMiJ,EAAQ,IAC/BO,QAAO,EAAGpE,gBAAiBA,IAAe,KAAiBM,aAAY,GAEjF,CAEA,OA3BAiF,GAAYpB,GAAYG,EACnBrI,KAAI,CAACsI,EAASV,KACf,MAAM1D,EAASgE,EAAQN,GAEvB,OAAO1D,GAAUA,EAAOoE,UAAYA,GAAWpE,EAAOH,aAAeuE,EAAQvE,WACvEG,EACA,CACEoE,QAASA,EACTvE,WAAYuE,EAAQvE,WACvB,IAEJoE,QAAO,EAAGpE,gBAAiBA,IAAe,KAAiBM,gBAehEgE,EAASqB,SAASpB,GAAYA,EAAQ1D,GAAG,mBAAoB2E,EAAwBjB,KAC9E,KACHD,EAASqB,SAASpB,GAAYA,EAAQxD,IAAI,mBAAoByE,EAAwBjB,IAAS,CAClG,GACF,CAACA,EAASD,IACb,MAAMnE,GAAS,IAAA/K,UAAQ,IAAM+O,EAAQyB,MAAMzF,GAAWA,EAAOoE,UAAYA,KAAY,MAAM,CAACA,EAASJ,KAErG,IAAAxG,YAAU,KACN,IAAK4G,EACD,OACJ,MAAMsB,EAAiBpQ,IACnByP,EAAazP,GACboP,EAAgBjH,SAAU,EAC1BkH,GAAc,GACdK,GAAa,GACbJ,EAAmBnH,SAAU,EAC7BqH,GAAiB,EAAM,EAErBa,EAAmB,KACjBtB,EAAe5G,UAEnBsH,EAAa,MACbL,EAAgBjH,SAAU,EAC1BkH,GAAc,GACdK,GAAa,GACbJ,EAAmBnH,SAAU,EAC7BqH,GAAiB,GAAM,EAErBc,EAAe5J,IACjBkJ,EAAezH,QAAQzB,EAAOoI,EAAQ,EAK1C,OAHAA,EAAQ1D,GAAG,UAAWgF,GACtBtB,EAAQ1D,GAAG,aAAciF,GACzBvB,EAAQ1D,GAAG,QAASkF,GACb,KACHxB,EAAQxD,IAAI,UAAW8E,GACvBtB,EAAQxD,IAAI,aAAc+E,GAC1BvB,EAAQxD,IAAI,QAASgF,GACrBD,GAAkB,CACrB,GACF,CAACvB,EAASC,IAEb,MAAMwB,GAA2B,IAAAtI,SAAO,IACxC,IAAAC,YAAU,IACC,KACHqI,EAAyBpI,SAAU,CAAK,GAE7C,CAAC2G,KAEJ,IAAA5G,YAAU,KACFqI,EAAyBpI,SACzBiH,EAAgBjH,SAChBsF,IACCuB,GACCtE,GAAQH,aAAe,KAAiBO,WAAaJ,GAAQH,aAAe,KAAiBiG,WAEnGpB,EAAgBjH,SAAU,EAC1BkH,GAAc,GACdkB,EAAyBpI,SAAU,EACnC,iBACI,UACU6G,GACV,CACA,MACIC,GAEJ,CACA,QACII,GAAc,GACdD,EAAgBjH,SAAU,CAC9B,CACH,CAZD,GAYI,GACL,CAACsF,EAAWuB,EAAsBC,EAAgBvE,IAErD,MAAMiB,GAAkB,IAAA8E,cAAYjD,MAAOpO,EAAaM,EAAYqD,KAChE,IAAK+L,EACD,MAAMc,EAAezH,QAAQ,IAAI,KACrC,IAAKsF,EACD,MAAMmC,EAAezH,QAAQ,IAAI,KAA2B2G,GAChE,aAAaA,EAAQnD,gBAAgBvM,EAAaM,EAAYqD,EAAQ,GACvE,CAAC+L,EAASrB,IAEPxN,GAAkB,IAAAN,UAAQ,IAAMmP,GAAW,oBAAqBA,EAChEtB,MAAOpO,IACL,IAAKqO,EACD,MAAMmC,EAAezH,QAAQ,IAAI,KAA2B2G,GAChE,aAAaA,EAAQ7O,gBAAgBb,EAAY,OAEnDgB,GAAW,CAAC0O,EAASrB,IAErBvN,GAAsB,IAAAP,UAAQ,IAAMmP,GAAW,wBAAyBA,EACxEtB,MAAOU,IACL,IAAKT,EACD,MAAMmC,EAAezH,QAAQ,IAAI,KAA2B2G,GAChE,aAAaA,EAAQ5O,oBAAoBgO,EAAa,OAExD9N,GAAW,CAAC0O,EAASrB,IAErBG,GAAc,IAAAjO,UAAQ,IAAMmP,GAAW,gBAAiBA,EACxDtB,MAAO5M,IACL,IAAK6M,EACD,MAAMmC,EAAezH,QAAQ,IAAI,KAA2B2G,GAChE,aAAaA,EAAQlB,YAAYhN,EAAQ,OAE3CR,GAAW,CAAC0O,EAASrB,IAErBI,GAAS,IAAAlO,UAAQ,IAAMmP,GAAW,WAAYA,EAC9CtB,MAAO9I,SACQoK,EAAQjB,OAAOnJ,QAE9BtE,GAAW,CAAC0O,IACZsB,GAAgB,IAAAK,cAAYjD,UAC9B,GAAI4B,EAAgBjH,SAAWmH,EAAmBnH,SAAWuC,GAAQoE,QAAQrB,UACzE,OACJ,IAAK/C,EACD,MAAMkF,EAAezH,QAAQ,IAAI,KACrC,MAAM,QAAE2G,EAAO,WAAEvE,GAAeG,EAChC,GAAMH,IAAe,KAAiBO,WAAaP,IAAe,KAAiBiG,SAC/E,MAAMZ,EAAezH,QAAQ,IAAI,KAAuB2G,GAC5DM,EAAgBjH,SAAU,EAC1BkH,GAAc,GACd,UACUP,EAAQrD,SAClB,CACA,MAAOiF,GAEH,MADAzB,IACMyB,CACV,CACA,QACIrB,GAAc,GACdD,EAAgBjH,SAAU,CAC9B,IACD,CAAC8G,EAAgBvE,IACd2F,GAAmB,IAAAI,cAAYjD,UACjC,IAAI8B,EAAmBnH,SAElB2G,EAAL,CAEAQ,EAAmBnH,SAAU,EAC7BqH,GAAiB,GACjB,UACUV,EAAQpD,YAClB,CACA,QACI8D,GAAiB,GACjBF,EAAmBnH,SAAU,CACjC,CATU,CASV,GACD,CAAC2G,IACJ,OAAQ,gBAAoB,IAAcjP,SAAU,CAAEC,MAAO,CACrDyL,cAAeyD,EACfN,UACAhE,SACA1K,YACAyN,YACAjD,aACA+E,gBACAoB,OAAQxB,EACR1D,QAAS2E,EACT1E,WAAY2E,EACZ1E,kBACA1L,kBACAC,sBACA0N,cACAC,WACCvO,EACb,CCrOA,IAAIsR,EAOJ,SAASC,GAAYhC,GAEjB,OHPW,UAAwB,SAAEA,EAAQ,gBAAEiC,IAC/C,OAAIjC,EAASkC,MAAMjC,GAAYA,EAAQtN,OAAS,MAC5CsN,EAAQvE,aAAe,KAAiBO,YASjCuD,EAAY2C,YAEnBF,GAEA,WAAW9E,KAAK8E,KAlBxB,SAAmBA,GACf,MAAO,0GAA0G9E,KAAK8E,EAC1H,CAkBSG,CAAUH,GACJzC,EAAY6C,WAGZ7C,EAAY2C,WAE3B,CGhBWG,CAAe,CAAEtC,WAAUiC,sBAPf1Q,IAAfwQ,IACAA,EAAaQ,WAAWC,WAAWC,WAAa,MAE7CV,OAIkDvC,EAAY6C,UACzE,CACA,SAASK,KACL,MAAMC,EAAWJ,WAAWI,SAC5B,GAAKA,EAEL,MAAO,GAAGA,EAASC,aAAaD,EAASE,MAC7C,CACO,SAASC,IAAe,SAAErS,EAAUoP,QAASG,EAAQ,YAAEtD,EAAW,gBAAEqG,EAAkB,aAAY,QAAE1C,IACvG,MAAM,WAAExP,IAAe,EAAAwH,EAAA,KACjB2K,EFxBH,SAAmChD,GACtC,MAAMiD,EAAWxD,GAAY,IAAM,IAAIxK,OACjC,IAAEoG,EAAG,GAAEkB,GAAOkD,GAAY,KAAM,YAC/ByD,EAAkBC,IAAuB,IAAAtK,WAAS,IAAM+G,EAAwBvE,QACvF,IAAAhC,YAAU,KACN,MAAM+J,EAAY,CACd7G,EAAG,YAAY,IAAIsD,IAAYsD,GAAqBD,GAAqB,IAAIA,KAAqBtD,EAAwBC,QAC1HtD,EAAG,cAAc,IAAIsD,IAAYsD,GAAqBD,GAAqBA,EAAiBpD,QAAQuD,GAAoBxD,EAAQqC,MAAMrG,GAAWA,IAAWwH,EAAgBxH,gBAEhL,MAAO,IAAMuH,EAAU/B,SAAS5E,GAAQA,KAAM,GAC/C,CAACF,IACJ,MAAM+G,EA+BV,SAAqB1K,GACjB,MAAM+G,GAAM,IAAAvG,aAAO7H,GAInB,OAHA,IAAA8H,YAAU,KACNsG,EAAIrG,QAAUV,CAAK,IAEhB+G,EAAIrG,OACf,CArCiCiK,CAAYL,GAUzC,OATA,IAAA7J,YAAU,KACN,IAAKiK,EACD,OACJ,MAAME,EAAkB,IAAIvO,IAAIiO,GACR,IAAIjO,IAAIqO,EAAqBxD,QAAQ2D,IAAqBD,EAAgBrI,IAAIsI,MACtFpC,SAASpB,GAAYA,EAAQzD,WAAU,GACxD,CAAC8G,EAAsBJ,KAE1B,IAAA7J,YAAU,IAAM,IAAM6J,EAAiB7B,SAASpB,GAAYA,EAAQzD,aAAY,KACzE,IAAA1L,UAAQ,IAAM,IACdoS,KACAlD,EAASF,QAAO,EAAGnN,WACduQ,EAAiBhB,MAAMmB,GAAoBA,EAAgB1Q,OAASA,MAC/DsQ,EAAS9H,IAAIxI,KACdsQ,EAAS/N,IAAIvC,GACbuG,EAAQwK,KAAK,GAAG/Q,iEAAoEA,qCAEjF,OAIhB,CAACuQ,EAAkBlD,EAAUiD,GACpC,CEVyCU,CAA0B3D,GACzD4D,GAAsB,IAAA9S,UAAQ,KAChC,IAAKkR,GAAYgB,GACb,OAAO,KAEX,MAAMa,EAA8Bb,EAA6B1B,MAAMrB,GAAYA,EAAQtN,OAAS,OACpG,OAAIkR,GAGG,IAAI,KAA0B,CACjCC,iBAAiB,UACjBC,YAAa,CACTC,IAAKtB,MAETuB,0BAA0B,SAC1BC,SC1C2CxT,ED0CHG,GAAYqM,YCzCvDxM,EAGD,UAAUyM,KAAKzM,GACR,SAEF,WAAWyM,KAAKzM,GACd,UAGA,eATA,gBDyCHyT,kBAAkB,YC3Cf,IAAwCzT,CD4C7C,GACH,CAACsS,EAA8BnS,GAAYqM,cACxCkH,GAAkC,IAAAtT,UAAQ,IACjB,MAAvB8S,IAA8F,IAA/DZ,EAA6BqB,QAAQT,GAC7DZ,EAEJ,CAACY,KAAwBZ,IACjC,CAACA,EAA8BY,KAC3BU,EAAYC,IAAiB,EAAA7L,EAAA,GAAgBqK,EAAiBf,GAAYgB,GAAgC,KAAsC,MACjJ/C,GAAU,IAAAnP,UAAQ,IAAMsT,EAAgC9C,MAAMkD,GAAMA,EAAE7R,OAAS2R,KAAe,MAAM,CAACF,EAAiCE,IACtIG,GAAe,IAAA7C,cAAa8C,IAC1BJ,IAAeI,IAEfzE,GAKAA,EAAQtN,OAAS,MACjBsN,EAAQpD,aAEZ0H,EAAcG,GAAe,GAC9B,CAACzE,EAASsE,EAAeD,KAC5B,IAAAjL,YAAU,KACN,GAAK4G,EAWL,OADAA,EAAQ1D,GAAG,aAAciF,GAClB,KACHvB,EAAQxD,IAAI,aAAc+E,EAAiB,EAV/C,SAASA,IACDtB,EAAe5G,SAGfgL,IAAe,MAAuCtC,GAAYgB,IAEtEuB,EAAc,KAClB,CAIC,GACF,CAACtE,EAAS+C,EAA8BuB,EAAeD,IAC1D,MAAMK,GAAyB,IAAAvL,SAAO,GAChCwL,GAA2B,IAAA9T,UAAQ,KACrC,GAAK4L,GAAgBuD,EAErB,OAAOtB,YAEiB,IAAhBjC,SAA+BA,EAAYuD,MACvC0E,EAAuBrL,cACjB2G,EAAQrD,gBAGRqD,EAAQvD,cAEtB,CACH,GACF,CAACA,EAAauD,IACXC,GAAiB,IAAA9G,SAAO,IAC9B,IAAAC,YAAU,KACN,GAAIiL,IAAe,OAAuCtC,GAAYgB,GAetE,OADA/J,OAAO4L,iBAAiB,eAAgBC,GACjC,KACH7L,OAAO8L,oBAAoB,eAAgBD,EAAmB,EAZlE,SAASA,IACL5E,EAAe5G,SAAU,CAC7B,CALI4G,EAAe5G,SAAU,CAgB5B,GACF,CAAC0J,EAA8BsB,IAClC,MAAMU,GAAqB,IAAApD,cAAY,KAC/B3B,GAAWA,EAAQtN,OAAS,MAE5B8R,EAAa,KACjB,GACD,CAACxE,EAASwE,IACPQ,GAAe,IAAArD,cAAa0C,IAC9BK,EAAuBrL,SAAU,EACjCmL,EAAaH,EAAW,GACzB,CAACG,IACJ,OAAQ,gBAAoB1E,EAAoB,CAAEF,QAASuE,EAAiCnE,QAASA,EAASC,eAAgBA,EAAgBC,qBAAsByE,EAA0BxE,eAAgB4E,EAAoB3E,QAASA,EAASC,eAAgB2E,GAAgBxU,EACxR,C,0MEnIO,MAAMyU,UAAoBC,MAE7B,WAAAxT,CAAYI,EAAS8F,GACjBvF,MAAMP,GACNQ,KAAKsF,MAAQA,CACjB,EAEG,MAAMuN,UAA4BF,EACrC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,qBAChB,EAEG,MAAM2S,UAAwBJ,EACjC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,iBAChB,EAEG,MAAM4S,UAA0BL,EACnC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,mBAChB,EAEG,MAAM6S,UAA8BN,EACvC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,uBAChB,EAEG,MAAM8S,UAAgCP,EACzC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,yBAChB,EAEG,MAAM+S,UAAiCR,EAC1C,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,0BAChB,EAEG,MAAMgT,UAA2BT,EACpC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,oBAChB,EAEG,MAAMiT,UAA6BV,EACtC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,sBAChB,EAEG,MAAMkT,UAA2BX,EACpC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,oBAChB,EAEG,MAAMmT,UAAgCZ,EACzC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,yBAChB,EAEG,MAAMoT,UAAmCb,EAC5C,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,4BAChB,EAEG,MAAMqT,UAAmCd,EAC5C,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,4BAChB,EAEG,MAAMsT,UAA+Bf,EACxC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,wBAChB,EAEG,MAAMuT,UAA0BhB,EACnC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,mBAChB,EAEG,MAAMwT,UAA2BjB,EACpC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,oBAChB,EAEG,MAAMyT,UAAiClB,EAC1C,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,0BAChB,EAEG,MAAM0T,UAAgCnB,EACzC,WAAAvT,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,yBAChB,E,+DC1GG,MAAM2T,UAA+B,KACxC,WAAA3U,GACIW,SAAS+S,WACT9S,KAAKI,KAAO,wBAChB,E,kFCJJ,MAAM4T,EAAc,GACdC,EAAkB,CACpB9J,aAAa,EACbf,YAAY,EACZiD,WAAW,EACX8B,eAAe,EACf,MAAAoB,GACI2E,EAAwB,OAAQ,SACpC,EACA7J,QAAO,IACI8J,QAAQC,OAAOF,EAAwB,OAAQ,YAE1D5J,WAAU,IACC6J,QAAQC,OAAOF,EAAwB,OAAQ,eAE1D3J,gBAAe,IACJ4J,QAAQC,OAAOF,EAAwB,OAAQ,oBAE1DrV,gBAAe,IACJsV,QAAQC,OAAOF,EAAwB,OAAQ,oBAE1DpV,oBAAmB,IACRqV,QAAQC,OAAOF,EAAwB,OAAQ,wBAE1D1H,YAAW,IACA2H,QAAQC,OAAOF,EAAwB,OAAQ,gBAE1DzH,OAAM,IACK0H,QAAQC,OAAOF,EAAwB,OAAQ,YAqB9D,SAASA,EAAwBG,EAAQC,GACrC,MAAMhP,EAAQ,IAAIsN,MAAM,qBAAqByB,MAAWC,8IAGxD,OADA3N,EAAQrB,MAAMA,GACPA,CACX,CAvBApF,OAAOqU,eAAeN,EAAiB,UAAW,CAC9CnL,IAAG,KACCoL,EAAwB,OAAQ,WACzBF,KAGf9T,OAAOqU,eAAeN,EAAiB,SAAU,CAC7CnL,IAAG,KACCoL,EAAwB,OAAQ,UACzB,QAGfhU,OAAOqU,eAAeN,EAAiB,YAAa,CAChDnL,IAAG,KACCoL,EAAwB,OAAQ,aACzB,QASR,MAAMM,GAAgB,IAAA3O,eAAcoO,GACpC,SAASlV,IACZ,OAAO,IAAAgH,YAAWyO,EACtB,C,sGCxDO,MAAMC,UAAgC,KACzC,qBAAMlK,CAAgBvM,EAAaM,EAAYqD,EAAU,CAAC,GACtD,IAAImI,GAAO,EACX,IACI,IAAI,OAAuB9L,GAAc,CACrC,IAAKgC,KAAKqJ,6BACN,MAAM,IAAI,KAA2B,iEACzC,IAAKrJ,KAAKqJ,6BAA6BT,IAAI5K,EAAY0W,SACnD,MAAM,IAAI,KAA2B,+BAA+B1W,EAAY0W,0CACpF,IAEI,MAAMC,GADN3W,QAAoBgC,KAAKnB,gBAAgBb,IACNkN,YACnC,aAAa5M,EAAW0N,mBAAmB2I,EAAgBhT,EAC/D,CACA,MAAO2D,GAEH,GAAIA,aAAiB,KAEjB,MADAwE,GAAO,EACDxE,EAEV,MAAM,IAAI,KAA2BA,GAAO9F,QAAS8F,EACzD,CACJ,MAEI,IACI,MAAM,QAAEwF,KAAYC,GAAgBpJ,EACpC3D,QAAoBgC,KAAKmL,mBAAmBnN,EAAaM,EAAYyM,GACrED,GAASjL,QAAU7B,EAAYoN,eAAeN,GAE9C,MAAM6J,GADN3W,QAAoBgC,KAAKnB,gBAAgBb,IACNkN,YACnC,aAAa5M,EAAW0N,mBAAmB2I,EAAgB5J,EAC/D,CACA,MAAOzF,GAEH,GAAIA,aAAiB,KAEjB,MADAwE,GAAO,EACDxE,EAEV,MAAM,IAAI,KAA2BA,GAAO9F,QAAS8F,EACzD,CAER,CACA,MAAOA,GAIH,MAHIwE,GACA9J,KAAK8J,KAAK,QAASxE,GAEjBA,CACV,CACJ,CACA,yBAAMxG,CAAoBgO,GACtB,IAAK,MAAM9O,KAAe8O,EACtB,IAAI,OAAuB9O,GAAc,CACrC,IAAKgC,KAAKqJ,6BACN,MAAM,IAAI,KAA2B,iEACzC,IAAKrJ,KAAKqJ,6BAA6BT,IAAI5K,EAAY0W,SACnD,MAAM,IAAI,KAA2B,+BAA+B1W,EAAY0W,yCACxF,CAEJ,MAAM3H,EAAqB,GAC3B,IAAK,MAAM/O,KAAe8O,EACtBC,EAAmBtH,WAAWzF,KAAKnB,gBAAgBb,IAEvD,OAAO+O,CACX,EAEG,MAAM6H,UAAuCH,GAE7C,MAAMI,UAA6CD,G,+BC6CnD,SAASE,EAAwBxR,GAmBpC,IAAI9D,EAAU,GAAG8D,EAAMyR,0DACvBvV,GAAW,GAAG8D,EAAMiJ,UAChBjJ,EAAM0R,YACNxV,GAAW,OAAO8D,EAAM0R,aAE5B,MAAMC,EAAS,GAyBf,GAxBI3R,EAAMmO,KACNwD,EAAOxP,KAAK,QAAQnC,EAAMmO,OAE1BnO,EAAMoR,SACNO,EAAOxP,KAAK,YAAYnC,EAAMoR,WAE9BpR,EAAM4R,SACND,EAAOxP,KAAK,aAAanC,EAAM4R,WAE/B5R,EAAM6R,OACNF,EAAOxP,KAAK,UAAUnC,EAAM6R,SAE5B7R,EAAM8R,UACNH,EAAOxP,KAAK,cAAcnC,EAAM8R,YAEhC9R,EAAM+R,gBACNJ,EAAOxP,KAAK,oBAAoBnC,EAAM+R,kBAEtC/R,EAAMgS,WACNL,EAAOxP,KAAK,eAAenC,EAAMgS,aAEjChS,EAAMiS,WACNN,EAAOxP,KAAK,eAAenC,EAAMiS,aAEjCjS,EAAMkS,UAAW,CACjBP,EAAOxP,KAAK,cACZ,IAAK,MAAMgQ,KAAYnS,EAAMkS,UACzBP,EAAOxP,KAAK,KAAKgQ,IAEzB,CAIA,OAHIR,EAAOpV,SACPL,GAAW,OAAOyV,EAAOnV,KAAK,SAE3BN,CACX,C,kBA/FgB,IAAIkW,OAAO,sf,+FC7EpB,SAASC,EAAwCrM,GACpD,OAAQ,OAAmBA,EAAOS,UAC9B,OAAkBT,EAAOS,WACxB,OAAgCT,EAAOS,UAAY,OAAyBT,EAAOS,SAC5F,C,mYCNW6L,E,sDACX,SAAWA,GACPA,EAA8B,QAAI,eAClCA,EAA8B,QAAI,UAClCA,EAA6B,OAAI,QACpC,CAJD,CAIGA,IAAyBA,EAAuB,CAAC,G,gDCJ7C,MAAMC,EAA+B,+B,yFCWjCC,E,uBACX,SAAWA,GAMPA,EAA4B,UAAI,YAChCA,EAA8B,YAAI,cAKlCA,EAA2B,SAAI,WAK/BA,EAA8B,YAAI,aACrC,CAlBD,CAkBGA,IAAqBA,EAAmB,CAAC,IACrC,MAAMC,UAA0B,EACnC,aAAI1J,GACA,QAASrM,KAAKpB,SAClB,CACA,iBAAMuL,SACInK,KAAKqK,SACf,CACA,wBAAMc,CAAmBnN,EAAaM,EAAYqD,EAAU,CAAC,GACzD,MAAM/C,EAAYoB,KAAKpB,UACvB,IAAKA,EACD,MAAM,IAAI,KAQd,OAPAZ,EAAYgY,SAAWhY,EAAYgY,UAAYpX,EAC/CZ,EAAYiY,gBACRjY,EAAYiY,wBACD3X,EAAW4X,mBAAmB,CACjC7X,WAAYsD,EAAQ+J,oBACpBG,eAAgBlK,EAAQkK,kBACxBsK,UACLnY,CACX,EAEG,SAASoY,EAA8BC,GAE1C,GAAsB,oBAAX3P,QAA8C,oBAAb8C,SACxC,OACJ,MAAM8M,EAAY,GAClB,SAASC,IAEL,GADiBF,IAEb,IAAK,MAAMG,KAAWF,EAClBE,GAGZ,CAEA,MAAMC,EAENC,YAAYH,EAAkB,KAC9BD,EAAU7Q,MAAK,IAAMkR,cAAcF,KAIX,YAAxBjN,SAASL,aACLK,SAAS8I,iBAAiB,mBAAoBiE,EAAkB,CAAEK,MAAM,IACxEN,EAAU7Q,MAAK,IAAM+D,SAASgJ,oBAAoB,mBAAoB+D,MAKlD,aAAxB/M,SAASL,aACLzC,OAAO4L,iBAAiB,OAAQiE,EAAkB,CAAEK,MAAM,IAC1DN,EAAU7Q,MAAK,IAAMiB,OAAO8L,oBAAoB,OAAQ+D,MAG5DA,GACJ,CAUO,SAASM,IAEZ,IAAK5G,UACD,OAAO,EACX,MAAMC,EAAYD,UAAUC,UAAU4G,cAGhCC,EAAQ7G,EAAUzF,SAAS,WAAayF,EAAUzF,SAAS,QAI3DuM,EAAW9G,EAAUzF,SAAS,UACpC,OAAOsM,GAASC,CACpB,C","sources":["webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-base/lib/esm/transaction.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/ConnectionProvider.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/useAnchorWallet.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-features/lib/esm/signTransaction.js","webpack://@jup-ag/terminal/./node_modules/@solana/web3.js/node_modules/superstruct/dist/index.mjs","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/useConnection.js","webpack://@jup-ag/terminal/./node_modules/@solana/web3.js/node_modules/bs58/index.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/useLocalStorage.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/types.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-features/lib/esm/signMessage.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-features/lib/esm/signIn.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-chains/lib/esm/index.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-util/lib/esm/commitment.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-wallet-adapter-base/lib/esm/adapter.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-util/lib/esm/endpoint.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/getEnvironment.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-wallet-adapter-react/lib/esm/useStandardWalletAdapters.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProviderBase.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/WalletProvider.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/getInferredClusterFromEndpoint.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-base/lib/esm/errors.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/errors.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-react/lib/esm/useWallet.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-base/lib/esm/signer.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-util/lib/esm/signIn.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-base/lib/esm/standard.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-base/lib/esm/types.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-standard-features/lib/esm/signAndSendTransaction.js","webpack://@jup-ag/terminal/./node_modules/@solana/wallet-adapter-base/lib/esm/adapter.js"],"sourcesContent":["export function isVersionedTransaction(transaction) {\n    return 'version' in transaction;\n}\n//# sourceMappingURL=transaction.js.map","import { Connection } from '@solana/web3.js';\nimport React, { useMemo } from 'react';\nimport { ConnectionContext } from './useConnection.js';\nexport const ConnectionProvider = ({ children, endpoint, config = { commitment: 'confirmed' }, }) => {\n    const connection = useMemo(() => new Connection(endpoint, config), [endpoint, config]);\n    return React.createElement(ConnectionContext.Provider, { value: { connection } }, children);\n};\n//# sourceMappingURL=ConnectionProvider.js.map","import { useMemo } from 'react';\nimport { useWallet } from './useWallet.js';\nexport function useAnchorWallet() {\n    const { publicKey, signTransaction, signAllTransactions } = useWallet();\n    return useMemo(() => publicKey && signTransaction && signAllTransactions\n        ? { publicKey, signTransaction, signAllTransactions }\n        : undefined, [publicKey, signTransaction, signAllTransactions]);\n}\n//# sourceMappingURL=useAnchorWallet.js.map","/** Name of the feature. */\nexport const SolanaSignTransaction = 'solana:signTransaction';\n//# sourceMappingURL=signTransaction.js.map","/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n    constructor(failure, failures) {\n        let cached;\n        const { message, explanation, ...rest } = failure;\n        const { path } = failure;\n        const msg = path.length === 0 ? message : `At path: ${path.join('.')} -- ${message}`;\n        super(explanation ?? msg);\n        if (explanation != null)\n            this.cause = msg;\n        Object.assign(this, rest);\n        this.name = this.constructor.name;\n        this.failures = () => {\n            return (cached ?? (cached = [failure, ...failures()]));\n        };\n    }\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n    return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isObject(x) {\n    return typeof x === 'object' && x != null;\n}\n/**\n * Check if a value is a non-array object.\n */\nfunction isNonArrayObject(x) {\n    return isObject(x) && !Array.isArray(x);\n}\n/**\n * Check if a value is a plain object.\n */\nfunction isPlainObject(x) {\n    if (Object.prototype.toString.call(x) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(x);\n    return prototype === null || prototype === Object.prototype;\n}\n/**\n * Return a value as a printable string.\n */\nfunction print(value) {\n    if (typeof value === 'symbol') {\n        return value.toString();\n    }\n    return typeof value === 'string' ? JSON.stringify(value) : `${value}`;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\nfunction shiftIterator(input) {\n    const { done, value } = input.next();\n    return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\nfunction toFailure(result, context, struct, value) {\n    if (result === true) {\n        return;\n    }\n    else if (result === false) {\n        result = {};\n    }\n    else if (typeof result === 'string') {\n        result = { message: result };\n    }\n    const { path, branch } = context;\n    const { type } = struct;\n    const { refinement, message = `Expected a value of type \\`${type}\\`${refinement ? ` with refinement \\`${refinement}\\`` : ''}, but received: \\`${print(value)}\\``, } = result;\n    return {\n        value,\n        type,\n        refinement,\n        key: path[path.length - 1],\n        path,\n        branch,\n        ...result,\n        message,\n    };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\nfunction* toFailures(result, context, struct, value) {\n    if (!isIterable(result)) {\n        result = [result];\n    }\n    for (const r of result) {\n        const failure = toFailure(r, context, struct, value);\n        if (failure) {\n            yield failure;\n        }\n    }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\nfunction* run(value, struct, options = {}) {\n    const { path = [], branch = [value], coerce = false, mask = false } = options;\n    const ctx = { path, branch, mask };\n    if (coerce) {\n        value = struct.coercer(value, ctx);\n    }\n    let status = 'valid';\n    for (const failure of struct.validator(value, ctx)) {\n        failure.explanation = options.message;\n        status = 'not_valid';\n        yield [failure, undefined];\n    }\n    for (let [k, v, s] of struct.entries(value, ctx)) {\n        const ts = run(v, s, {\n            path: k === undefined ? path : [...path, k],\n            branch: k === undefined ? branch : [...branch, v],\n            coerce,\n            mask,\n            message: options.message,\n        });\n        for (const t of ts) {\n            if (t[0]) {\n                status = t[0].refinement != null ? 'not_refined' : 'not_valid';\n                yield [t[0], undefined];\n            }\n            else if (coerce) {\n                v = t[1];\n                if (k === undefined) {\n                    value = v;\n                }\n                else if (value instanceof Map) {\n                    value.set(k, v);\n                }\n                else if (value instanceof Set) {\n                    value.add(v);\n                }\n                else if (isObject(value)) {\n                    if (v !== undefined || k in value)\n                        value[k] = v;\n                }\n            }\n        }\n    }\n    if (status !== 'not_valid') {\n        for (const failure of struct.refiner(value, ctx)) {\n            failure.explanation = options.message;\n            status = 'not_refined';\n            yield [failure, undefined];\n        }\n    }\n    if (status === 'valid') {\n        yield [undefined, value];\n    }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\nclass Struct {\n    constructor(props) {\n        const { type, schema, validator, refiner, coercer = (value) => value, entries = function* () { }, } = props;\n        this.type = type;\n        this.schema = schema;\n        this.entries = entries;\n        this.coercer = coercer;\n        if (validator) {\n            this.validator = (value, context) => {\n                const result = validator(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.validator = () => [];\n        }\n        if (refiner) {\n            this.refiner = (value, context) => {\n                const result = refiner(value, context);\n                return toFailures(result, context, this, value);\n            };\n        }\n        else {\n            this.refiner = () => [];\n        }\n    }\n    /**\n     * Assert that a value passes the struct's validation, throwing if it doesn't.\n     */\n    assert(value, message) {\n        return assert(value, this, message);\n    }\n    /**\n     * Create a value with the struct's coercion logic, then validate it.\n     */\n    create(value, message) {\n        return create(value, this, message);\n    }\n    /**\n     * Check if a value passes the struct's validation.\n     */\n    is(value) {\n        return is(value, this);\n    }\n    /**\n     * Mask a value, coercing and validating it, but returning only the subset of\n     * properties defined by the struct's schema. Masking applies recursively to\n     * props of `object` structs only.\n     */\n    mask(value, message) {\n        return mask(value, this, message);\n    }\n    /**\n     * Validate a value with the struct's validation logic, returning a tuple\n     * representing the result.\n     *\n     * You may optionally pass `true` for the `coerce` argument to coerce\n     * the value before attempting to validate it. If you do, the result will\n     * contain the coerced result when successful. Also, `mask` will turn on\n     * masking of the unknown `object` props recursively if passed.\n     */\n    validate(value, options = {}) {\n        return validate(value, this, options);\n    }\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\nfunction assert(value, struct, message) {\n    const result = validate(value, struct, { message });\n    if (result[0]) {\n        throw result[0];\n    }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\nfunction create(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\nfunction mask(value, struct, message) {\n    const result = validate(value, struct, { coerce: true, mask: true, message });\n    if (result[0]) {\n        throw result[0];\n    }\n    else {\n        return result[1];\n    }\n}\n/**\n * Check if a value passes a struct.\n */\nfunction is(value, struct) {\n    const result = validate(value, struct);\n    return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\nfunction validate(value, struct, options = {}) {\n    const tuples = run(value, struct, options);\n    const tuple = shiftIterator(tuples);\n    if (tuple[0]) {\n        const error = new StructError(tuple[0], function* () {\n            for (const t of tuples) {\n                if (t[0]) {\n                    yield t[0];\n                }\n            }\n        });\n        return [error, undefined];\n    }\n    else {\n        const v = tuple[1];\n        return [undefined, v];\n    }\n}\n\nfunction assign(...Structs) {\n    const isType = Structs[0].type === 'type';\n    const schemas = Structs.map((s) => s.schema);\n    const schema = Object.assign({}, ...schemas);\n    return isType ? type(schema) : object(schema);\n}\n/**\n * Define a new struct type with a custom validation function.\n */\nfunction define(name, validator) {\n    return new Struct({ type: name, schema: null, validator });\n}\n/**\n * Create a new struct based on an existing struct, but the value is allowed to\n * be `undefined`. `log` will be called if the value is not `undefined`.\n */\nfunction deprecated(struct, log) {\n    return new Struct({\n        ...struct,\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n        validator(value, ctx) {\n            if (value === undefined) {\n                return true;\n            }\n            else {\n                log(value, ctx);\n                return struct.validator(value, ctx);\n            }\n        },\n    });\n}\n/**\n * Create a struct with dynamic validation logic.\n *\n * The callback will receive the value currently being validated, and must\n * return a struct object to validate it with. This can be useful to model\n * validation logic that changes based on its input.\n */\nfunction dynamic(fn) {\n    return new Struct({\n        type: 'dynamic',\n        schema: null,\n        *entries(value, ctx) {\n            const struct = fn(value, ctx);\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            const struct = fn(value, ctx);\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a struct with lazily evaluated validation logic.\n *\n * The first time validation is run with the struct, the callback will be called\n * and must return a struct object to use. This is useful for cases where you\n * want to have self-referential structs for nested data structures to avoid a\n * circular definition problem.\n */\nfunction lazy(fn) {\n    let struct;\n    return new Struct({\n        type: 'lazy',\n        schema: null,\n        *entries(value, ctx) {\n            struct ?? (struct = fn());\n            yield* struct.entries(value, ctx);\n        },\n        validator(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.validator(value, ctx);\n        },\n        coercer(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.coercer(value, ctx);\n        },\n        refiner(value, ctx) {\n            struct ?? (struct = fn());\n            return struct.refiner(value, ctx);\n        },\n    });\n}\n/**\n * Create a new struct based on an existing object struct, but excluding\n * specific properties.\n *\n * Like TypeScript's `Omit` utility.\n */\nfunction omit(struct, keys) {\n    const { schema } = struct;\n    const subschema = { ...schema };\n    for (const key of keys) {\n        delete subschema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Create a new struct based on an existing object struct, but with all of its\n * properties allowed to be `undefined`.\n *\n * Like TypeScript's `Partial` utility.\n */\nfunction partial(struct) {\n    const isStruct = struct instanceof Struct;\n    const schema = isStruct ? { ...struct.schema } : { ...struct };\n    for (const key in schema) {\n        schema[key] = optional(schema[key]);\n    }\n    if (isStruct && struct.type === 'type') {\n        return type(schema);\n    }\n    return object(schema);\n}\n/**\n * Create a new struct based on an existing object struct, but only including\n * specific properties.\n *\n * Like TypeScript's `Pick` utility.\n */\nfunction pick(struct, keys) {\n    const { schema } = struct;\n    const subschema = {};\n    for (const key of keys) {\n        subschema[key] = schema[key];\n    }\n    switch (struct.type) {\n        case 'type':\n            return type(subschema);\n        default:\n            return object(subschema);\n    }\n}\n/**\n * Define a new struct type with a custom validation function.\n *\n * @deprecated This function has been renamed to `define`.\n */\nfunction struct(name, validator) {\n    console.warn('superstruct@0.11 - The `struct` helper has been renamed to `define`.');\n    return define(name, validator);\n}\n\n/**\n * Ensure that any value passes validation.\n */\nfunction any() {\n    return define('any', () => true);\n}\nfunction array(Element) {\n    return new Struct({\n        type: 'array',\n        schema: Element,\n        *entries(value) {\n            if (Element && Array.isArray(value)) {\n                for (const [i, v] of value.entries()) {\n                    yield [i, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array value, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a bigint.\n */\nfunction bigint() {\n    return define('bigint', (value) => {\n        return typeof value === 'bigint';\n    });\n}\n/**\n * Ensure that a value is a boolean.\n */\nfunction boolean() {\n    return define('boolean', (value) => {\n        return typeof value === 'boolean';\n    });\n}\n/**\n * Ensure that a value is a valid `Date`.\n *\n * Note: this also ensures that the value is *not* an invalid `Date` object,\n * which can occur when parsing a date fails but still returns a `Date`.\n */\nfunction date() {\n    return define('date', (value) => {\n        return ((value instanceof Date && !isNaN(value.getTime())) ||\n            `Expected a valid \\`Date\\` object, but received: ${print(value)}`);\n    });\n}\nfunction enums(values) {\n    const schema = {};\n    const description = values.map((v) => print(v)).join();\n    for (const key of values) {\n        schema[key] = key;\n    }\n    return new Struct({\n        type: 'enums',\n        schema,\n        validator(value) {\n            return (values.includes(value) ||\n                `Expected one of \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a function.\n */\nfunction func() {\n    return define('func', (value) => {\n        return (typeof value === 'function' ||\n            `Expected a function, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an instance of a specific class.\n */\nfunction instance(Class) {\n    return define('instance', (value) => {\n        return (value instanceof Class ||\n            `Expected a \\`${Class.name}\\` instance, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is an integer.\n */\nfunction integer() {\n    return define('integer', (value) => {\n        return ((typeof value === 'number' && !isNaN(value) && Number.isInteger(value)) ||\n            `Expected an integer, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value matches all of a set of types.\n */\nfunction intersection(Structs) {\n    return new Struct({\n        type: 'intersection',\n        schema: null,\n        *entries(value, ctx) {\n            for (const S of Structs) {\n                yield* S.entries(value, ctx);\n            }\n        },\n        *validator(value, ctx) {\n            for (const S of Structs) {\n                yield* S.validator(value, ctx);\n            }\n        },\n        *refiner(value, ctx) {\n            for (const S of Structs) {\n                yield* S.refiner(value, ctx);\n            }\n        },\n    });\n}\nfunction literal(constant) {\n    const description = print(constant);\n    const t = typeof constant;\n    return new Struct({\n        type: 'literal',\n        schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n        validator(value) {\n            return (value === constant ||\n                `Expected the literal \\`${description}\\`, but received: ${print(value)}`);\n        },\n    });\n}\nfunction map(Key, Value) {\n    return new Struct({\n        type: 'map',\n        schema: null,\n        *entries(value) {\n            if (Key && Value && value instanceof Map) {\n                for (const [k, v] of value.entries()) {\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Map ? new Map(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Map ||\n                `Expected a \\`Map\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that no value ever passes validation.\n */\nfunction never() {\n    return define('never', () => false);\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\nfunction nullable(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === null || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === null || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is a number.\n */\nfunction number() {\n    return define('number', (value) => {\n        return ((typeof value === 'number' && !isNaN(value)) ||\n            `Expected a number, but received: ${print(value)}`);\n    });\n}\nfunction object(schema) {\n    const knowns = schema ? Object.keys(schema) : [];\n    const Never = never();\n    return new Struct({\n        type: 'object',\n        schema: schema ? schema : null,\n        *entries(value) {\n            if (schema && isObject(value)) {\n                const unknowns = new Set(Object.keys(value));\n                for (const key of knowns) {\n                    unknowns.delete(key);\n                    yield [key, value[key], schema[key]];\n                }\n                for (const key of unknowns) {\n                    yield [key, value[key], Never];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value, ctx) {\n            if (!isNonArrayObject(value)) {\n                return value;\n            }\n            const coerced = { ...value };\n            // The `object` struct has special behaviour enabled by the mask flag.\n            // When masking, properties that are not in the schema are deleted from\n            // the coerced object instead of eventually failing validaiton.\n            if (ctx.mask && schema) {\n                for (const key in coerced) {\n                    if (schema[key] === undefined) {\n                        delete coerced[key];\n                    }\n                }\n            }\n            return coerced;\n        },\n    });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\nfunction optional(struct) {\n    return new Struct({\n        ...struct,\n        validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n        refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx),\n    });\n}\n/**\n * Ensure that a value is an object with keys and values of specific types, but\n * without ensuring any specific shape of properties.\n *\n * Like TypeScript's `Record` utility.\n */\nfunction record(Key, Value) {\n    return new Struct({\n        type: 'record',\n        schema: null,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k in value) {\n                    const v = value[k];\n                    yield [k, k, Key];\n                    yield [k, v, Value];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value is a `RegExp`.\n *\n * Note: this does not test the value against the regular expression! For that\n * you need to use the `pattern()` refinement.\n */\nfunction regexp() {\n    return define('regexp', (value) => {\n        return value instanceof RegExp;\n    });\n}\nfunction set(Element) {\n    return new Struct({\n        type: 'set',\n        schema: null,\n        *entries(value) {\n            if (Element && value instanceof Set) {\n                for (const v of value) {\n                    yield [v, v, Element];\n                }\n            }\n        },\n        coercer(value) {\n            return value instanceof Set ? new Set(value) : value;\n        },\n        validator(value) {\n            return (value instanceof Set ||\n                `Expected a \\`Set\\` object, but received: ${print(value)}`);\n        },\n    });\n}\n/**\n * Ensure that a value is a string.\n */\nfunction string() {\n    return define('string', (value) => {\n        return (typeof value === 'string' ||\n            `Expected a string, but received: ${print(value)}`);\n    });\n}\n/**\n * Ensure that a value is a tuple of a specific length, and that each of its\n * elements is of a specific type.\n */\nfunction tuple(Structs) {\n    const Never = never();\n    return new Struct({\n        type: 'tuple',\n        schema: null,\n        *entries(value) {\n            if (Array.isArray(value)) {\n                const length = Math.max(Structs.length, value.length);\n                for (let i = 0; i < length; i++) {\n                    yield [i, value[i], Structs[i] || Never];\n                }\n            }\n        },\n        validator(value) {\n            return (Array.isArray(value) ||\n                `Expected an array, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return Array.isArray(value) ? value.slice() : value;\n        },\n    });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\nfunction type(schema) {\n    const keys = Object.keys(schema);\n    return new Struct({\n        type: 'type',\n        schema,\n        *entries(value) {\n            if (isObject(value)) {\n                for (const k of keys) {\n                    yield [k, value[k], schema[k]];\n                }\n            }\n        },\n        validator(value) {\n            return (isNonArrayObject(value) ||\n                `Expected an object, but received: ${print(value)}`);\n        },\n        coercer(value) {\n            return isNonArrayObject(value) ? { ...value } : value;\n        },\n    });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\nfunction union(Structs) {\n    const description = Structs.map((s) => s.type).join(' | ');\n    return new Struct({\n        type: 'union',\n        schema: null,\n        coercer(value, ctx) {\n            for (const S of Structs) {\n                const [error, coerced] = S.validate(value, {\n                    coerce: true,\n                    mask: ctx.mask,\n                });\n                if (!error) {\n                    return coerced;\n                }\n            }\n            return value;\n        },\n        validator(value, ctx) {\n            const failures = [];\n            for (const S of Structs) {\n                const [...tuples] = run(value, S, ctx);\n                const [first] = tuples;\n                if (!first[0]) {\n                    return [];\n                }\n                else {\n                    for (const [failure] of tuples) {\n                        if (failure) {\n                            failures.push(failure);\n                        }\n                    }\n                }\n            }\n            return [\n                `Expected the value to satisfy a union of \\`${description}\\`, but received: ${print(value)}`,\n                ...failures,\n            ];\n        },\n    });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\nfunction unknown() {\n    return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction coerce(struct, condition, coercer) {\n    return new Struct({\n        ...struct,\n        coercer: (value, ctx) => {\n            return is(value, condition)\n                ? struct.coercer(coercer(value, ctx), ctx)\n                : struct.coercer(value, ctx);\n        },\n    });\n}\n/**\n * Augment a struct to replace `undefined` values with a default.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction defaulted(struct, fallback, options = {}) {\n    return coerce(struct, unknown(), (x) => {\n        const f = typeof fallback === 'function' ? fallback() : fallback;\n        if (x === undefined) {\n            return f;\n        }\n        if (!options.strict && isPlainObject(x) && isPlainObject(f)) {\n            const ret = { ...x };\n            let changed = false;\n            for (const key in f) {\n                if (ret[key] === undefined) {\n                    ret[key] = f[key];\n                    changed = true;\n                }\n            }\n            if (changed) {\n                return ret;\n            }\n        }\n        return x;\n    });\n}\n/**\n * Augment a struct to trim string inputs.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\nfunction trimmed(struct) {\n    return coerce(struct, string(), (x) => x.trim());\n}\n\n/**\n * Ensure that a string, array, map, or set is empty.\n */\nfunction empty(struct) {\n    return refine(struct, 'empty', (value) => {\n        const size = getSize(value);\n        return (size === 0 ||\n            `Expected an empty ${struct.type} but received one with a size of \\`${size}\\``);\n    });\n}\nfunction getSize(value) {\n    if (value instanceof Map || value instanceof Set) {\n        return value.size;\n    }\n    else {\n        return value.length;\n    }\n}\n/**\n * Ensure that a number or date is below a threshold.\n */\nfunction max(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'max', (value) => {\n        return exclusive\n            ? value < threshold\n            : value <= threshold ||\n                `Expected a ${struct.type} less than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a number or date is above a threshold.\n */\nfunction min(struct, threshold, options = {}) {\n    const { exclusive } = options;\n    return refine(struct, 'min', (value) => {\n        return exclusive\n            ? value > threshold\n            : value >= threshold ||\n                `Expected a ${struct.type} greater than ${exclusive ? '' : 'or equal to '}${threshold} but received \\`${value}\\``;\n    });\n}\n/**\n * Ensure that a string, array, map or set is not empty.\n */\nfunction nonempty(struct) {\n    return refine(struct, 'nonempty', (value) => {\n        const size = getSize(value);\n        return (size > 0 || `Expected a nonempty ${struct.type} but received an empty one`);\n    });\n}\n/**\n * Ensure that a string matches a regular expression.\n */\nfunction pattern(struct, regexp) {\n    return refine(struct, 'pattern', (value) => {\n        return (regexp.test(value) ||\n            `Expected a ${struct.type} matching \\`/${regexp.source}/\\` but received \"${value}\"`);\n    });\n}\n/**\n * Ensure that a string, array, number, date, map, or set has a size (or length, or time) between `min` and `max`.\n */\nfunction size(struct, min, max = min) {\n    const expected = `Expected a ${struct.type}`;\n    const of = min === max ? `of \\`${min}\\`` : `between \\`${min}\\` and \\`${max}\\``;\n    return refine(struct, 'size', (value) => {\n        if (typeof value === 'number' || value instanceof Date) {\n            return ((min <= value && value <= max) ||\n                `${expected} ${of} but received \\`${value}\\``);\n        }\n        else if (value instanceof Map || value instanceof Set) {\n            const { size } = value;\n            return ((min <= size && size <= max) ||\n                `${expected} with a size ${of} but received one with a size of \\`${size}\\``);\n        }\n        else {\n            const { length } = value;\n            return ((min <= length && length <= max) ||\n                `${expected} with a length ${of} but received one with a length of \\`${length}\\``);\n        }\n    });\n}\n/**\n * Augment a `Struct` to add an additional refinement to the validation.\n *\n * The refiner function is guaranteed to receive a value of the struct's type,\n * because the struct's existing validation will already have passed. This\n * allows you to layer additional validation on top of existing structs.\n */\nfunction refine(struct, name, refiner) {\n    return new Struct({\n        ...struct,\n        *refiner(value, ctx) {\n            yield* struct.refiner(value, ctx);\n            const result = refiner(value, ctx);\n            const failures = toFailures(result, ctx, struct, value);\n            for (const failure of failures) {\n                yield { ...failure, refinement: name };\n            }\n        },\n    });\n}\n\nexport { Struct, StructError, any, array, assert, assign, bigint, boolean, coerce, create, date, defaulted, define, deprecated, dynamic, empty, enums, func, instance, integer, intersection, is, lazy, literal, map, mask, max, min, never, nonempty, nullable, number, object, omit, optional, partial, pattern, pick, record, refine, regexp, set, size, string, struct, trimmed, tuple, type, union, unknown, validate };\n//# sourceMappingURL=index.mjs.map\n","import { createContext, useContext } from 'react';\nexport const ConnectionContext = createContext({});\nexport function useConnection() {\n    return useContext(ConnectionContext);\n}\n//# sourceMappingURL=useConnection.js.map","var basex = require('base-x')\nvar ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n","import { useEffect, useRef, useState } from 'react';\nexport function useLocalStorage(key, defaultState) {\n    const state = useState(() => {\n        try {\n            const value = localStorage.getItem(key);\n            if (value)\n                return JSON.parse(value);\n        }\n        catch (error) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n        return defaultState;\n    });\n    const value = state[0];\n    const isFirstRenderRef = useRef(true);\n    useEffect(() => {\n        if (isFirstRenderRef.current) {\n            isFirstRenderRef.current = false;\n            return;\n        }\n        try {\n            if (value === null) {\n                localStorage.removeItem(key);\n            }\n            else {\n                localStorage.setItem(key, JSON.stringify(value));\n            }\n        }\n        catch (error) {\n            if (typeof window !== 'undefined') {\n                console.error(error);\n            }\n        }\n    }, [value, key]);\n    return state;\n}\n//# sourceMappingURL=useLocalStorage.js.map","import { isWalletAdapterCompatibleStandardWallet, } from '@solana/wallet-adapter-base';\n/**\n * @deprecated Use `isWalletAdapterCompatibleStandardWallet` from `@solana/wallet-adapter-base` instead.\n *\n * @group Deprecated\n */\nexport const isWalletAdapterCompatibleWallet = isWalletAdapterCompatibleStandardWallet;\n//# sourceMappingURL=types.js.map","/** Name of the feature. */\nexport const SolanaSignMessage = 'solana:signMessage';\n//# sourceMappingURL=signMessage.js.map","/** Name of the feature. */\nexport const SolanaSignIn = 'solana:signIn';\n//# sourceMappingURL=signIn.js.map","/** Solana Mainnet (beta) cluster, e.g. https://api.mainnet-beta.solana.com */\nexport const SOLANA_MAINNET_CHAIN = 'solana:mainnet';\n/** Solana Devnet cluster, e.g. https://api.devnet.solana.com */\nexport const SOLANA_DEVNET_CHAIN = 'solana:devnet';\n/** Solana Testnet cluster, e.g. https://api.testnet.solana.com */\nexport const SOLANA_TESTNET_CHAIN = 'solana:testnet';\n/** Solana Localnet cluster, e.g. http://localhost:8899 */\nexport const SOLANA_LOCALNET_CHAIN = 'solana:localnet';\n/** Array of all Solana clusters */\nexport const SOLANA_CHAINS = [\n    SOLANA_MAINNET_CHAIN,\n    SOLANA_DEVNET_CHAIN,\n    SOLANA_TESTNET_CHAIN,\n    SOLANA_LOCALNET_CHAIN,\n];\n/**\n * Check if a chain corresponds with one of the Solana clusters.\n */\nexport function isSolanaChain(chain) {\n    return SOLANA_CHAINS.includes(chain);\n}\n//# sourceMappingURL=index.js.map","/**\n * TODO: docs\n */\nexport function getCommitment(commitment) {\n    switch (commitment) {\n        case 'processed':\n        case 'confirmed':\n        case 'finalized':\n        case undefined:\n            return commitment;\n        case 'recent':\n            return 'processed';\n        case 'single':\n        case 'singleGossip':\n            return 'confirmed';\n        case 'max':\n        case 'root':\n            return 'finalized';\n        default:\n            return undefined;\n    }\n}\n//# sourceMappingURL=commitment.js.map","var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n};\nvar _StandardWalletAdapter_instances, _StandardWalletAdapter_account, _StandardWalletAdapter_publicKey, _StandardWalletAdapter_connecting, _StandardWalletAdapter_disconnecting, _StandardWalletAdapter_off, _StandardWalletAdapter_supportedTransactionVersions, _StandardWalletAdapter_wallet, _StandardWalletAdapter_readyState, _StandardWalletAdapter_connect, _StandardWalletAdapter_connected, _StandardWalletAdapter_disconnected, _StandardWalletAdapter_reset, _StandardWalletAdapter_changed, _StandardWalletAdapter_signTransaction, _StandardWalletAdapter_signAllTransactions, _StandardWalletAdapter_signMessage, _StandardWalletAdapter_signIn;\nimport { BaseWalletAdapter, isVersionedTransaction, WalletAccountError, WalletConfigError, WalletConnectionError, WalletDisconnectedError, WalletDisconnectionError, WalletError, WalletNotConnectedError, WalletNotReadyError, WalletPublicKeyError, WalletReadyState, WalletSendTransactionError, WalletSignInError, WalletSignMessageError, WalletSignTransactionError, } from '@solana/wallet-adapter-base';\nimport { SolanaSignAndSendTransaction, SolanaSignIn, SolanaSignMessage, SolanaSignTransaction, } from '@solana/wallet-standard-features';\nimport { getChainForEndpoint, getCommitment } from '@solana/wallet-standard-util';\nimport { PublicKey, Transaction, VersionedTransaction } from '@solana/web3.js';\nimport { StandardConnect, StandardDisconnect, StandardEvents, } from '@wallet-standard/features';\nimport { arraysEqual } from '@wallet-standard/wallet';\nimport bs58 from 'bs58';\n/** TODO: docs */\nexport class StandardWalletAdapter extends BaseWalletAdapter {\n    get name() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").name;\n    }\n    get url() {\n        return 'https://github.com/solana-labs/wallet-standard';\n    }\n    get icon() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").icon;\n    }\n    get readyState() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\");\n    }\n    get publicKey() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_publicKey, \"f\");\n    }\n    get connecting() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_connecting, \"f\");\n    }\n    get supportedTransactionVersions() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_supportedTransactionVersions, \"f\");\n    }\n    get wallet() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\");\n    }\n    get standard() {\n        return true;\n    }\n    constructor({ wallet }) {\n        super();\n        _StandardWalletAdapter_instances.add(this);\n        _StandardWalletAdapter_account.set(this, void 0);\n        _StandardWalletAdapter_publicKey.set(this, void 0);\n        _StandardWalletAdapter_connecting.set(this, void 0);\n        _StandardWalletAdapter_disconnecting.set(this, void 0);\n        _StandardWalletAdapter_off.set(this, void 0);\n        _StandardWalletAdapter_supportedTransactionVersions.set(this, void 0);\n        _StandardWalletAdapter_wallet.set(this, void 0);\n        _StandardWalletAdapter_readyState.set(this, typeof window === 'undefined' || typeof document === 'undefined'\n            ? WalletReadyState.Unsupported\n            : WalletReadyState.Installed);\n        _StandardWalletAdapter_changed.set(this, (properties) => {\n            // If accounts have changed on the wallet, reflect this on the adapter.\n            if ('accounts' in properties) {\n                const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n                // If the adapter isn't connected, or is disconnecting, or the first account hasn't changed, do nothing.\n                if (__classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\") && !__classPrivateFieldGet(this, _StandardWalletAdapter_disconnecting, \"f\") && account !== __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")) {\n                    // If there's a connected account, connect the adapter. Otherwise, disconnect it.\n                    if (account) {\n                        // Connect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n                    }\n                    else {\n                        // Emit an error because the wallet spontaneously disconnected.\n                        this.emit('error', new WalletDisconnectedError());\n                        // Disconnect the adapter.\n                        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n                    }\n                }\n            }\n            // After reflecting account changes, if features have changed on the wallet, reflect this on the adapter.\n            if ('features' in properties) {\n                __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n            }\n        });\n        __classPrivateFieldSet(this, _StandardWalletAdapter_wallet, wallet, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_off, __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[StandardEvents].on('change', __classPrivateFieldGet(this, _StandardWalletAdapter_changed, \"f\")), \"f\");\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    }\n    destroy() {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n        __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n        const off = __classPrivateFieldGet(this, _StandardWalletAdapter_off, \"f\");\n        if (off) {\n            __classPrivateFieldSet(this, _StandardWalletAdapter_off, null, \"f\");\n            off();\n        }\n    }\n    async autoConnect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this, { silent: true });\n    }\n    async connect() {\n        return __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connect).call(this);\n    }\n    async disconnect() {\n        if (StandardDisconnect in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n            try {\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, true, \"f\");\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[StandardDisconnect].disconnect();\n            }\n            catch (error) {\n                this.emit('error', new WalletDisconnectionError(error?.message, error));\n            }\n            finally {\n                __classPrivateFieldSet(this, _StandardWalletAdapter_disconnecting, false, \"f\");\n            }\n        }\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_disconnected).call(this);\n    }\n    async sendTransaction(transaction, connection, options = {}) {\n        try {\n            const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n            if (!account)\n                throw new WalletNotConnectedError();\n            let feature;\n            if (SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (account.features.includes(SolanaSignAndSendTransaction)) {\n                    feature = SolanaSignAndSendTransaction;\n                }\n                else if (SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features &&\n                    account.features.includes(SolanaSignTransaction)) {\n                    feature = SolanaSignTransaction;\n                }\n                else {\n                    throw new WalletAccountError();\n                }\n            }\n            else if (SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n                if (!account.features.includes(SolanaSignTransaction))\n                    throw new WalletAccountError();\n                feature = SolanaSignTransaction;\n            }\n            else {\n                throw new WalletConfigError();\n            }\n            const chain = getChainForEndpoint(connection.rpcEndpoint);\n            if (!account.chains.includes(chain))\n                throw new WalletSendTransactionError();\n            try {\n                const { signers, ...sendOptions } = options;\n                let serializedTransaction;\n                if (isVersionedTransaction(transaction)) {\n                    signers?.length && transaction.sign(signers);\n                    serializedTransaction = transaction.serialize();\n                }\n                else {\n                    transaction = (await this.prepareTransaction(transaction, connection, sendOptions));\n                    signers?.length && transaction.partialSign(...signers);\n                    serializedTransaction = new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false,\n                    }));\n                }\n                if (feature === SolanaSignAndSendTransaction) {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignAndSendTransaction].signAndSendTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),\n                            skipPreflight: sendOptions.skipPreflight,\n                            maxRetries: sendOptions.maxRetries,\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n                    return bs58.encode(output.signature);\n                }\n                else {\n                    const [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].signTransaction({\n                        account,\n                        chain,\n                        transaction: serializedTransaction,\n                        options: {\n                            preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),\n                            minContextSlot: sendOptions.minContextSlot,\n                        },\n                    });\n                    return await connection.sendRawTransaction(output.signedTransaction, {\n                        ...sendOptions,\n                        preflightCommitment: getCommitment(sendOptions.preflightCommitment || connection.commitment),\n                    });\n                }\n            }\n            catch (error) {\n                if (error instanceof WalletError)\n                    throw error;\n                throw new WalletSendTransactionError(error?.message, error);\n            }\n        }\n        catch (error) {\n            this.emit('error', error);\n            throw error;\n        }\n    }\n}\n_StandardWalletAdapter_account = new WeakMap(), _StandardWalletAdapter_publicKey = new WeakMap(), _StandardWalletAdapter_connecting = new WeakMap(), _StandardWalletAdapter_disconnecting = new WeakMap(), _StandardWalletAdapter_off = new WeakMap(), _StandardWalletAdapter_supportedTransactionVersions = new WeakMap(), _StandardWalletAdapter_wallet = new WeakMap(), _StandardWalletAdapter_readyState = new WeakMap(), _StandardWalletAdapter_changed = new WeakMap(), _StandardWalletAdapter_instances = new WeakSet(), _StandardWalletAdapter_connect = async function _StandardWalletAdapter_connect(input) {\n    try {\n        if (this.connected || this.connecting)\n            return;\n        if (__classPrivateFieldGet(this, _StandardWalletAdapter_readyState, \"f\") !== WalletReadyState.Installed)\n            throw new WalletNotReadyError();\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, true, \"f\");\n        if (!__classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts.length) {\n            try {\n                await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[StandardConnect].connect(input);\n            }\n            catch (error) {\n                throw new WalletConnectionError(error?.message, error);\n            }\n        }\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").accounts[0];\n        if (!account)\n            throw new WalletAccountError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, account);\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n    finally {\n        __classPrivateFieldSet(this, _StandardWalletAdapter_connecting, false, \"f\");\n    }\n}, _StandardWalletAdapter_connected = function _StandardWalletAdapter_connected(account) {\n    let publicKey;\n    try {\n        // Use account.address instead of account.publicKey since address could be a PDA\n        publicKey = new PublicKey(account.address);\n    }\n    catch (error) {\n        throw new WalletPublicKeyError(error?.message, error);\n    }\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, account, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, publicKey, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit('connect', publicKey);\n}, _StandardWalletAdapter_disconnected = function _StandardWalletAdapter_disconnected() {\n    __classPrivateFieldSet(this, _StandardWalletAdapter_account, null, \"f\");\n    __classPrivateFieldSet(this, _StandardWalletAdapter_publicKey, null, \"f\");\n    __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_reset).call(this);\n    this.emit('disconnect');\n}, _StandardWalletAdapter_reset = function _StandardWalletAdapter_reset() {\n    const supportedTransactionVersions = SolanaSignAndSendTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features\n        ? __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignAndSendTransaction].supportedTransactionVersions\n        : __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].supportedTransactionVersions;\n    __classPrivateFieldSet(this, _StandardWalletAdapter_supportedTransactionVersions, arraysEqual(supportedTransactionVersions, ['legacy'])\n        ? null\n        : new Set(supportedTransactionVersions), \"f\");\n    if (SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(SolanaSignTransaction)) {\n        this.signTransaction = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signTransaction);\n        this.signAllTransactions = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signAllTransactions);\n    }\n    else {\n        delete this.signTransaction;\n        delete this.signAllTransactions;\n    }\n    if (SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features && __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\")?.features.includes(SolanaSignMessage)) {\n        this.signMessage = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signMessage);\n    }\n    else {\n        delete this.signMessage;\n    }\n    if (SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features) {\n        this.signIn = __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_signIn);\n    }\n    else {\n        delete this.signIn;\n    }\n}, _StandardWalletAdapter_signTransaction = async function _StandardWalletAdapter_signTransaction(transaction) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account)\n            throw new WalletNotConnectedError();\n        if (!(SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new WalletConfigError();\n        if (!account.features.includes(SolanaSignTransaction))\n            throw new WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].signTransaction({\n                account,\n                transaction: isVersionedTransaction(transaction)\n                    ? transaction.serialize()\n                    : new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false,\n                    })),\n            });\n            const serializedTransaction = signedTransactions[0].signedTransaction;\n            return (isVersionedTransaction(transaction)\n                ? VersionedTransaction.deserialize(serializedTransaction)\n                : Transaction.from(serializedTransaction));\n        }\n        catch (error) {\n            if (error instanceof WalletError)\n                throw error;\n            throw new WalletSignTransactionError(error?.message, error);\n        }\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signAllTransactions = async function _StandardWalletAdapter_signAllTransactions(transactions) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account)\n            throw new WalletNotConnectedError();\n        if (!(SolanaSignTransaction in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new WalletConfigError();\n        if (!account.features.includes(SolanaSignTransaction))\n            throw new WalletAccountError();\n        try {\n            const signedTransactions = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignTransaction].signTransaction(...transactions.map((transaction) => ({\n                account,\n                transaction: isVersionedTransaction(transaction)\n                    ? transaction.serialize()\n                    : new Uint8Array(transaction.serialize({\n                        requireAllSignatures: false,\n                        verifySignatures: false,\n                    })),\n            })));\n            return transactions.map((transaction, index) => {\n                const signedTransaction = signedTransactions[index].signedTransaction;\n                return (isVersionedTransaction(transaction)\n                    ? VersionedTransaction.deserialize(signedTransaction)\n                    : Transaction.from(signedTransaction));\n            });\n        }\n        catch (error) {\n            throw new WalletSignTransactionError(error?.message, error);\n        }\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signMessage = async function _StandardWalletAdapter_signMessage(message) {\n    try {\n        const account = __classPrivateFieldGet(this, _StandardWalletAdapter_account, \"f\");\n        if (!account)\n            throw new WalletNotConnectedError();\n        if (!(SolanaSignMessage in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new WalletConfigError();\n        if (!account.features.includes(SolanaSignMessage))\n            throw new WalletAccountError();\n        try {\n            const signedMessages = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignMessage].signMessage({\n                account,\n                message,\n            });\n            return signedMessages[0].signature;\n        }\n        catch (error) {\n            throw new WalletSignMessageError(error?.message, error);\n        }\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n}, _StandardWalletAdapter_signIn = async function _StandardWalletAdapter_signIn(input = {}) {\n    try {\n        if (!(SolanaSignIn in __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features))\n            throw new WalletConfigError();\n        let output;\n        try {\n            [output] = await __classPrivateFieldGet(this, _StandardWalletAdapter_wallet, \"f\").features[SolanaSignIn].signIn(input);\n        }\n        catch (error) {\n            throw new WalletSignInError(error?.message, error);\n        }\n        if (!output)\n            throw new WalletSignInError();\n        __classPrivateFieldGet(this, _StandardWalletAdapter_instances, \"m\", _StandardWalletAdapter_connected).call(this, output.account);\n        return output;\n    }\n    catch (error) {\n        this.emit('error', error);\n        throw error;\n    }\n};\n//# sourceMappingURL=adapter.js.map","import { SOLANA_DEVNET_CHAIN, SOLANA_LOCALNET_CHAIN, SOLANA_MAINNET_CHAIN, SOLANA_TESTNET_CHAIN, } from '@solana/wallet-standard-chains';\n/** TODO: docs */\nexport const MAINNET_ENDPOINT = 'https://api.mainnet-beta.solana.com';\n/** TODO: docs */\nexport const DEVNET_ENDPOINT = 'https://api.devnet.solana.com';\n/** TODO: docs */\nexport const TESTNET_ENDPOINT = 'https://api.testnet.solana.com';\n/** TODO: docs */\nexport const LOCALNET_ENDPOINT = 'http://localhost:8899';\n/**\n * TODO: docs\n */\nexport function getChainForEndpoint(endpoint) {\n    if (endpoint.includes(MAINNET_ENDPOINT))\n        return SOLANA_MAINNET_CHAIN;\n    if (/\\bdevnet\\b/i.test(endpoint))\n        return SOLANA_DEVNET_CHAIN;\n    if (/\\btestnet\\b/i.test(endpoint))\n        return SOLANA_TESTNET_CHAIN;\n    if (/\\blocalhost\\b/i.test(endpoint) || /\\b127\\.0\\.0\\.1\\b/.test(endpoint))\n        return SOLANA_LOCALNET_CHAIN;\n    return SOLANA_MAINNET_CHAIN;\n}\n/**\n * TODO: docs\n */\nexport function getEndpointForChain(chain, endpoint) {\n    if (endpoint)\n        return endpoint;\n    if (chain === SOLANA_MAINNET_CHAIN)\n        return MAINNET_ENDPOINT;\n    if (chain === SOLANA_DEVNET_CHAIN)\n        return DEVNET_ENDPOINT;\n    if (chain === SOLANA_TESTNET_CHAIN)\n        return TESTNET_ENDPOINT;\n    if (chain === SOLANA_LOCALNET_CHAIN)\n        return LOCALNET_ENDPOINT;\n    return MAINNET_ENDPOINT;\n}\n//# sourceMappingURL=endpoint.js.map","import { SolanaMobileWalletAdapterWalletName } from '@solana-mobile/wallet-adapter-mobile';\nimport { WalletReadyState } from '@solana/wallet-adapter-base';\nexport var Environment;\n(function (Environment) {\n    Environment[Environment[\"DESKTOP_WEB\"] = 0] = \"DESKTOP_WEB\";\n    Environment[Environment[\"MOBILE_WEB\"] = 1] = \"MOBILE_WEB\";\n})(Environment || (Environment = {}));\nfunction isWebView(userAgentString) {\n    return /(WebView|Version\\/.+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+)|; wv\\).+(Chrome)\\/(\\d+)\\.(\\d+)\\.(\\d+)\\.(\\d+))/i.test(userAgentString);\n}\nexport default function getEnvironment({ adapters, userAgentString }) {\n    if (adapters.some((adapter) => adapter.name !== SolanaMobileWalletAdapterWalletName &&\n        adapter.readyState === WalletReadyState.Installed)) {\n        /**\n         * There are only two ways a browser extension adapter should be able to reach `Installed` status:\n         *\n         *     1. Its browser extension is installed.\n         *     2. The app is running on a mobile wallet's in-app browser.\n         *\n         * In either case, we consider the environment to be desktop-like.\n         */\n        return Environment.DESKTOP_WEB;\n    }\n    if (userAgentString &&\n        // Step 1: Check whether we're on a platform that supports MWA at all.\n        /android/i.test(userAgentString) &&\n        // Step 2: Determine that we are *not* running in a WebView.\n        !isWebView(userAgentString)) {\n        return Environment.MOBILE_WEB;\n    }\n    else {\n        return Environment.DESKTOP_WEB;\n    }\n}\n//# sourceMappingURL=getEnvironment.js.map","import { isWalletAdapterCompatibleWallet, StandardWalletAdapter } from '@solana/wallet-standard-wallet-adapter-base';\nimport { DEPRECATED_getWallets } from '@wallet-standard/app';\nimport { useEffect, useMemo, useRef, useState } from 'react';\nexport function useStandardWalletAdapters(adapters) {\n    const warnings = useConstant(() => new Set());\n    const { get, on } = useConstant(() => DEPRECATED_getWallets());\n    const [standardAdapters, setStandardAdapters] = useState(() => wrapWalletsWithAdapters(get()));\n    useEffect(() => {\n        const listeners = [\n            on('register', (...wallets) => setStandardAdapters((standardAdapters) => [...standardAdapters, ...wrapWalletsWithAdapters(wallets)])),\n            on('unregister', (...wallets) => setStandardAdapters((standardAdapters) => standardAdapters.filter((standardAdapter) => wallets.some((wallet) => wallet === standardAdapter.wallet)))),\n        ];\n        return () => listeners.forEach((off) => off());\n    }, [on]);\n    const prevStandardAdapters = usePrevious(standardAdapters);\n    useEffect(() => {\n        if (!prevStandardAdapters)\n            return;\n        const currentAdapters = new Set(standardAdapters);\n        const removedAdapters = new Set(prevStandardAdapters.filter((previousAdapter) => !currentAdapters.has(previousAdapter)));\n        removedAdapters.forEach((adapter) => adapter.destroy());\n    }, [prevStandardAdapters, standardAdapters]);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    useEffect(() => () => standardAdapters.forEach((adapter) => adapter.destroy()), []);\n    return useMemo(() => [\n        ...standardAdapters,\n        ...adapters.filter(({ name }) => {\n            if (standardAdapters.some((standardAdapter) => standardAdapter.name === name)) {\n                if (!warnings.has(name)) {\n                    warnings.add(name);\n                    console.warn(`${name} was registered as a Standard Wallet. The Wallet Adapter for ${name} can be removed from your app.`);\n                }\n                return false;\n            }\n            return true;\n        }),\n    ], [standardAdapters, adapters, warnings]);\n}\nfunction useConstant(fn) {\n    const ref = useRef(undefined);\n    if (ref.current === undefined) {\n        ref.current = { value: fn() };\n    }\n    return ref.current.value;\n}\nfunction usePrevious(state) {\n    const ref = useRef(undefined);\n    useEffect(() => {\n        ref.current = state;\n    });\n    return ref.current;\n}\nfunction wrapWalletsWithAdapters(wallets) {\n    return wallets.filter(isWalletAdapterCompatibleWallet).map((wallet) => new StandardWalletAdapter({ wallet }));\n}\n//# sourceMappingURL=useStandardWalletAdapters.js.map","import { WalletNotConnectedError, WalletNotReadyError, WalletReadyState, } from '@solana/wallet-adapter-base';\nimport React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { WalletNotSelectedError } from './errors.js';\nimport { WalletContext } from './useWallet.js';\nexport function WalletProviderBase({ children, wallets: adapters, adapter, isUnloadingRef, onAutoConnectRequest, onConnectError, onError, onSelectWallet, }) {\n    const isConnectingRef = useRef(false);\n    const [connecting, setConnecting] = useState(false);\n    const isDisconnectingRef = useRef(false);\n    const [disconnecting, setDisconnecting] = useState(false);\n    const [publicKey, setPublicKey] = useState(() => adapter?.publicKey ?? null);\n    const [connected, setConnected] = useState(() => adapter?.connected ?? false);\n    /**\n     * Store the error handlers as refs so that a change in the\n     * custom error handler does not recompute other dependencies.\n     */\n    const onErrorRef = useRef(onError);\n    useEffect(() => {\n        onErrorRef.current = onError;\n        return () => {\n            onErrorRef.current = undefined;\n        };\n    }, [onError]);\n    const handleErrorRef = useRef((error, adapter) => {\n        if (!isUnloadingRef.current) {\n            if (onErrorRef.current) {\n                onErrorRef.current(error, adapter);\n            }\n            else {\n                console.error(error, adapter);\n                if (error instanceof WalletNotReadyError && typeof window !== 'undefined' && adapter) {\n                    window.open(adapter.url, '_blank');\n                }\n            }\n        }\n        return error;\n    });\n    // Wrap adapters to conform to the `Wallet` interface\n    const [wallets, setWallets] = useState(() => adapters\n        .map((adapter) => ({\n        adapter,\n        readyState: adapter.readyState,\n    }))\n        .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported));\n    // When the adapters change, start to listen for changes to their `readyState`\n    useEffect(() => {\n        // When the adapters change, wrap them to conform to the `Wallet` interface\n        setWallets((wallets) => adapters\n            .map((adapter, index) => {\n            const wallet = wallets[index];\n            // If the wallet hasn't changed, return the same instance\n            return wallet && wallet.adapter === adapter && wallet.readyState === adapter.readyState\n                ? wallet\n                : {\n                    adapter: adapter,\n                    readyState: adapter.readyState,\n                };\n        })\n            .filter(({ readyState }) => readyState !== WalletReadyState.Unsupported));\n        function handleReadyStateChange(readyState) {\n            setWallets((prevWallets) => {\n                const index = prevWallets.findIndex(({ adapter }) => adapter === this);\n                if (index === -1)\n                    return prevWallets;\n                // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n                const { adapter } = prevWallets[index];\n                return [\n                    ...prevWallets.slice(0, index),\n                    { adapter, readyState },\n                    ...prevWallets.slice(index + 1),\n                ].filter(({ readyState }) => readyState !== WalletReadyState.Unsupported);\n            });\n        }\n        adapters.forEach((adapter) => adapter.on('readyStateChange', handleReadyStateChange, adapter));\n        return () => {\n            adapters.forEach((adapter) => adapter.off('readyStateChange', handleReadyStateChange, adapter));\n        };\n    }, [adapter, adapters]);\n    const wallet = useMemo(() => wallets.find((wallet) => wallet.adapter === adapter) ?? null, [adapter, wallets]);\n    // Setup and teardown event listeners when the adapter changes\n    useEffect(() => {\n        if (!adapter)\n            return;\n        const handleConnect = (publicKey) => {\n            setPublicKey(publicKey);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(true);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleDisconnect = () => {\n            if (isUnloadingRef.current)\n                return;\n            setPublicKey(null);\n            isConnectingRef.current = false;\n            setConnecting(false);\n            setConnected(false);\n            isDisconnectingRef.current = false;\n            setDisconnecting(false);\n        };\n        const handleError = (error) => {\n            handleErrorRef.current(error, adapter);\n        };\n        adapter.on('connect', handleConnect);\n        adapter.on('disconnect', handleDisconnect);\n        adapter.on('error', handleError);\n        return () => {\n            adapter.off('connect', handleConnect);\n            adapter.off('disconnect', handleDisconnect);\n            adapter.off('error', handleError);\n            handleDisconnect();\n        };\n    }, [adapter, isUnloadingRef]);\n    // When the adapter changes, clear the `autoConnect` tracking flag\n    const didAttemptAutoConnectRef = useRef(false);\n    useEffect(() => {\n        return () => {\n            didAttemptAutoConnectRef.current = false;\n        };\n    }, [adapter]);\n    // If auto-connect is enabled, request to connect when the adapter changes and is ready\n    useEffect(() => {\n        if (didAttemptAutoConnectRef.current ||\n            isConnectingRef.current ||\n            connected ||\n            !onAutoConnectRequest ||\n            !(wallet?.readyState === WalletReadyState.Installed || wallet?.readyState === WalletReadyState.Loadable))\n            return;\n        isConnectingRef.current = true;\n        setConnecting(true);\n        didAttemptAutoConnectRef.current = true;\n        (async function () {\n            try {\n                await onAutoConnectRequest();\n            }\n            catch {\n                onConnectError();\n                // Drop the error. It will be caught by `handleError` anyway.\n            }\n            finally {\n                setConnecting(false);\n                isConnectingRef.current = false;\n            }\n        })();\n    }, [connected, onAutoConnectRequest, onConnectError, wallet]);\n    // Send a transaction using the provided connection\n    const sendTransaction = useCallback(async (transaction, connection, options) => {\n        if (!adapter)\n            throw handleErrorRef.current(new WalletNotSelectedError());\n        if (!connected)\n            throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n        return await adapter.sendTransaction(transaction, connection, options);\n    }, [adapter, connected]);\n    // Sign a transaction if the wallet supports it\n    const signTransaction = useMemo(() => adapter && 'signTransaction' in adapter\n        ? async (transaction) => {\n            if (!connected)\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.signTransaction(transaction);\n        }\n        : undefined, [adapter, connected]);\n    // Sign multiple transactions if the wallet supports it\n    const signAllTransactions = useMemo(() => adapter && 'signAllTransactions' in adapter\n        ? async (transactions) => {\n            if (!connected)\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.signAllTransactions(transactions);\n        }\n        : undefined, [adapter, connected]);\n    // Sign an arbitrary message if the wallet supports it\n    const signMessage = useMemo(() => adapter && 'signMessage' in adapter\n        ? async (message) => {\n            if (!connected)\n                throw handleErrorRef.current(new WalletNotConnectedError(), adapter);\n            return await adapter.signMessage(message);\n        }\n        : undefined, [adapter, connected]);\n    // Sign in if the wallet supports it\n    const signIn = useMemo(() => adapter && 'signIn' in adapter\n        ? async (input) => {\n            return await adapter.signIn(input);\n        }\n        : undefined, [adapter]);\n    const handleConnect = useCallback(async () => {\n        if (isConnectingRef.current || isDisconnectingRef.current || wallet?.adapter.connected)\n            return;\n        if (!wallet)\n            throw handleErrorRef.current(new WalletNotSelectedError());\n        const { adapter, readyState } = wallet;\n        if (!(readyState === WalletReadyState.Installed || readyState === WalletReadyState.Loadable))\n            throw handleErrorRef.current(new WalletNotReadyError(), adapter);\n        isConnectingRef.current = true;\n        setConnecting(true);\n        try {\n            await adapter.connect();\n        }\n        catch (e) {\n            onConnectError();\n            throw e;\n        }\n        finally {\n            setConnecting(false);\n            isConnectingRef.current = false;\n        }\n    }, [onConnectError, wallet]);\n    const handleDisconnect = useCallback(async () => {\n        if (isDisconnectingRef.current)\n            return;\n        if (!adapter)\n            return;\n        isDisconnectingRef.current = true;\n        setDisconnecting(true);\n        try {\n            await adapter.disconnect();\n        }\n        finally {\n            setDisconnecting(false);\n            isDisconnectingRef.current = false;\n        }\n    }, [adapter]);\n    return (React.createElement(WalletContext.Provider, { value: {\n            autoConnect: !!onAutoConnectRequest,\n            wallets,\n            wallet,\n            publicKey,\n            connected,\n            connecting,\n            disconnecting,\n            select: onSelectWallet,\n            connect: handleConnect,\n            disconnect: handleDisconnect,\n            sendTransaction,\n            signTransaction,\n            signAllTransactions,\n            signMessage,\n            signIn,\n        } }, children));\n}\n//# sourceMappingURL=WalletProviderBase.js.map","import { createDefaultAddressSelector, createDefaultAuthorizationResultCache, createDefaultWalletNotFoundHandler, SolanaMobileWalletAdapter, SolanaMobileWalletAdapterWalletName, } from '@solana-mobile/wallet-adapter-mobile';\nimport { useStandardWalletAdapters } from '@solana/wallet-standard-wallet-adapter-react';\nimport React, { useCallback, useEffect, useMemo, useRef } from 'react';\nimport getEnvironment, { Environment } from './getEnvironment.js';\nimport getInferredClusterFromEndpoint from './getInferredClusterFromEndpoint.js';\nimport { useConnection } from './useConnection.js';\nimport { useLocalStorage } from './useLocalStorage.js';\nimport { WalletProviderBase } from './WalletProviderBase.js';\nlet _userAgent;\nfunction getUserAgent() {\n    if (_userAgent === undefined) {\n        _userAgent = globalThis.navigator?.userAgent ?? null;\n    }\n    return _userAgent;\n}\nfunction getIsMobile(adapters) {\n    const userAgentString = getUserAgent();\n    return getEnvironment({ adapters, userAgentString }) === Environment.MOBILE_WEB;\n}\nfunction getUriForAppIdentity() {\n    const location = globalThis.location;\n    if (!location)\n        return;\n    return `${location.protocol}//${location.host}`;\n}\nexport function WalletProvider({ children, wallets: adapters, autoConnect, localStorageKey = 'walletName', onError, }) {\n    const { connection } = useConnection();\n    const adaptersWithStandardAdapters = useStandardWalletAdapters(adapters);\n    const mobileWalletAdapter = useMemo(() => {\n        if (!getIsMobile(adaptersWithStandardAdapters)) {\n            return null;\n        }\n        const existingMobileWalletAdapter = adaptersWithStandardAdapters.find((adapter) => adapter.name === SolanaMobileWalletAdapterWalletName);\n        if (existingMobileWalletAdapter) {\n            return existingMobileWalletAdapter;\n        }\n        return new SolanaMobileWalletAdapter({\n            addressSelector: createDefaultAddressSelector(),\n            appIdentity: {\n                uri: getUriForAppIdentity(),\n            },\n            authorizationResultCache: createDefaultAuthorizationResultCache(),\n            cluster: getInferredClusterFromEndpoint(connection?.rpcEndpoint),\n            onWalletNotFound: createDefaultWalletNotFoundHandler(),\n        });\n    }, [adaptersWithStandardAdapters, connection?.rpcEndpoint]);\n    const adaptersWithMobileWalletAdapter = useMemo(() => {\n        if (mobileWalletAdapter == null || adaptersWithStandardAdapters.indexOf(mobileWalletAdapter) !== -1) {\n            return adaptersWithStandardAdapters;\n        }\n        return [mobileWalletAdapter, ...adaptersWithStandardAdapters];\n    }, [adaptersWithStandardAdapters, mobileWalletAdapter]);\n    const [walletName, setWalletName] = useLocalStorage(localStorageKey, getIsMobile(adaptersWithStandardAdapters) ? SolanaMobileWalletAdapterWalletName : null);\n    const adapter = useMemo(() => adaptersWithMobileWalletAdapter.find((a) => a.name === walletName) ?? null, [adaptersWithMobileWalletAdapter, walletName]);\n    const changeWallet = useCallback((nextWalletName) => {\n        if (walletName === nextWalletName)\n            return;\n        if (adapter &&\n            // Selecting a wallet other than the mobile wallet adapter is not\n            // sufficient reason to call `disconnect` on the mobile wallet adapter.\n            // Calling `disconnect` on the mobile wallet adapter causes the entire\n            // authorization store to be wiped.\n            adapter.name !== SolanaMobileWalletAdapterWalletName) {\n            adapter.disconnect();\n        }\n        setWalletName(nextWalletName);\n    }, [adapter, setWalletName, walletName]);\n    useEffect(() => {\n        if (!adapter)\n            return;\n        function handleDisconnect() {\n            if (isUnloadingRef.current)\n                return;\n            // Leave the adapter selected in the event of a disconnection.\n            if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters))\n                return;\n            setWalletName(null);\n        }\n        adapter.on('disconnect', handleDisconnect);\n        return () => {\n            adapter.off('disconnect', handleDisconnect);\n        };\n    }, [adapter, adaptersWithStandardAdapters, setWalletName, walletName]);\n    const hasUserSelectedAWallet = useRef(false);\n    const handleAutoConnectRequest = useMemo(() => {\n        if (!autoConnect || !adapter)\n            return;\n        return async () => {\n            // If autoConnect is true or returns true, use the default autoConnect behavior.\n            if (autoConnect === true || (await autoConnect(adapter))) {\n                if (hasUserSelectedAWallet.current) {\n                    await adapter.connect();\n                }\n                else {\n                    await adapter.autoConnect();\n                }\n            }\n        };\n    }, [autoConnect, adapter]);\n    const isUnloadingRef = useRef(false);\n    useEffect(() => {\n        if (walletName === SolanaMobileWalletAdapterWalletName && getIsMobile(adaptersWithStandardAdapters)) {\n            isUnloadingRef.current = false;\n            return;\n        }\n        function handleBeforeUnload() {\n            isUnloadingRef.current = true;\n        }\n        /**\n         * Some wallets fire disconnection events when the window unloads. Since there's no way to\n         * distinguish between a disconnection event received because a user initiated it, and one\n         * that was received because they've closed the window, we have to track window unload\n         * events themselves. Downstream components use this information to decide whether to act\n         * upon or drop wallet events and errors.\n         */\n        window.addEventListener('beforeunload', handleBeforeUnload);\n        return () => {\n            window.removeEventListener('beforeunload', handleBeforeUnload);\n        };\n    }, [adaptersWithStandardAdapters, walletName]);\n    const handleConnectError = useCallback(() => {\n        if (adapter && adapter.name !== SolanaMobileWalletAdapterWalletName) {\n            // If any error happens while connecting, unset the adapter.\n            changeWallet(null);\n        }\n    }, [adapter, changeWallet]);\n    const selectWallet = useCallback((walletName) => {\n        hasUserSelectedAWallet.current = true;\n        changeWallet(walletName);\n    }, [changeWallet]);\n    return (React.createElement(WalletProviderBase, { wallets: adaptersWithMobileWalletAdapter, adapter: adapter, isUnloadingRef: isUnloadingRef, onAutoConnectRequest: handleAutoConnectRequest, onConnectError: handleConnectError, onError: onError, onSelectWallet: selectWallet }, children));\n}\n//# sourceMappingURL=WalletProvider.js.map","export default function getInferredClusterFromEndpoint(endpoint) {\n    if (!endpoint) {\n        return 'mainnet-beta';\n    }\n    if (/devnet/i.test(endpoint)) {\n        return 'devnet';\n    }\n    else if (/testnet/i.test(endpoint)) {\n        return 'testnet';\n    }\n    else {\n        return 'mainnet-beta';\n    }\n}\n//# sourceMappingURL=getInferredClusterFromEndpoint.js.map","export class WalletError extends Error {\n    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types\n    constructor(message, error) {\n        super(message);\n        this.error = error;\n    }\n}\nexport class WalletNotReadyError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotReadyError';\n    }\n}\nexport class WalletLoadError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletLoadError';\n    }\n}\nexport class WalletConfigError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletConfigError';\n    }\n}\nexport class WalletConnectionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletConnectionError';\n    }\n}\nexport class WalletDisconnectedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletDisconnectedError';\n    }\n}\nexport class WalletDisconnectionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletDisconnectionError';\n    }\n}\nexport class WalletAccountError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletAccountError';\n    }\n}\nexport class WalletPublicKeyError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletPublicKeyError';\n    }\n}\nexport class WalletKeypairError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletKeypairError';\n    }\n}\nexport class WalletNotConnectedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotConnectedError';\n    }\n}\nexport class WalletSendTransactionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSendTransactionError';\n    }\n}\nexport class WalletSignTransactionError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignTransactionError';\n    }\n}\nexport class WalletSignMessageError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignMessageError';\n    }\n}\nexport class WalletSignInError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletSignInError';\n    }\n}\nexport class WalletTimeoutError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletTimeoutError';\n    }\n}\nexport class WalletWindowBlockedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletWindowBlockedError';\n    }\n}\nexport class WalletWindowClosedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletWindowClosedError';\n    }\n}\n//# sourceMappingURL=errors.js.map","import { WalletError } from '@solana/wallet-adapter-base';\nexport class WalletNotSelectedError extends WalletError {\n    constructor() {\n        super(...arguments);\n        this.name = 'WalletNotSelectedError';\n    }\n}\n//# sourceMappingURL=errors.js.map","import { createContext, useContext } from 'react';\nconst EMPTY_ARRAY = [];\nconst DEFAULT_CONTEXT = {\n    autoConnect: false,\n    connecting: false,\n    connected: false,\n    disconnecting: false,\n    select() {\n        logMissingProviderError('call', 'select');\n    },\n    connect() {\n        return Promise.reject(logMissingProviderError('call', 'connect'));\n    },\n    disconnect() {\n        return Promise.reject(logMissingProviderError('call', 'disconnect'));\n    },\n    sendTransaction() {\n        return Promise.reject(logMissingProviderError('call', 'sendTransaction'));\n    },\n    signTransaction() {\n        return Promise.reject(logMissingProviderError('call', 'signTransaction'));\n    },\n    signAllTransactions() {\n        return Promise.reject(logMissingProviderError('call', 'signAllTransactions'));\n    },\n    signMessage() {\n        return Promise.reject(logMissingProviderError('call', 'signMessage'));\n    },\n    signIn() {\n        return Promise.reject(logMissingProviderError('call', 'signIn'));\n    },\n};\nObject.defineProperty(DEFAULT_CONTEXT, 'wallets', {\n    get() {\n        logMissingProviderError('read', 'wallets');\n        return EMPTY_ARRAY;\n    },\n});\nObject.defineProperty(DEFAULT_CONTEXT, 'wallet', {\n    get() {\n        logMissingProviderError('read', 'wallet');\n        return null;\n    },\n});\nObject.defineProperty(DEFAULT_CONTEXT, 'publicKey', {\n    get() {\n        logMissingProviderError('read', 'publicKey');\n        return null;\n    },\n});\nfunction logMissingProviderError(action, property) {\n    const error = new Error(`You have tried to ${action} \"${property}\" on a WalletContext without providing one. ` +\n        'Make sure to render a WalletProvider as an ancestor of the component that uses WalletContext.');\n    console.error(error);\n    return error;\n}\nexport const WalletContext = createContext(DEFAULT_CONTEXT);\nexport function useWallet() {\n    return useContext(WalletContext);\n}\n//# sourceMappingURL=useWallet.js.map","import { BaseWalletAdapter, } from './adapter.js';\nimport { WalletSendTransactionError, WalletSignTransactionError } from './errors.js';\nimport { isVersionedTransaction } from './transaction.js';\nexport class BaseSignerWalletAdapter extends BaseWalletAdapter {\n    async sendTransaction(transaction, connection, options = {}) {\n        let emit = true;\n        try {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSendTransactionError(`Sending versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSendTransactionError(`Sending transaction version ${transaction.version} isn't supported by this wallet`);\n                try {\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, options);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n            else {\n                try {\n                    const { signers, ...sendOptions } = options;\n                    transaction = await this.prepareTransaction(transaction, connection, sendOptions);\n                    signers?.length && transaction.partialSign(...signers);\n                    transaction = await this.signTransaction(transaction);\n                    const rawTransaction = transaction.serialize();\n                    return await connection.sendRawTransaction(rawTransaction, sendOptions);\n                }\n                catch (error) {\n                    // If the error was thrown by `signTransaction`, rethrow it and don't emit a duplicate event\n                    if (error instanceof WalletSignTransactionError) {\n                        emit = false;\n                        throw error;\n                    }\n                    throw new WalletSendTransactionError(error?.message, error);\n                }\n            }\n        }\n        catch (error) {\n            if (emit) {\n                this.emit('error', error);\n            }\n            throw error;\n        }\n    }\n    async signAllTransactions(transactions) {\n        for (const transaction of transactions) {\n            if (isVersionedTransaction(transaction)) {\n                if (!this.supportedTransactionVersions)\n                    throw new WalletSignTransactionError(`Signing versioned transactions isn't supported by this wallet`);\n                if (!this.supportedTransactionVersions.has(transaction.version))\n                    throw new WalletSignTransactionError(`Signing transaction version ${transaction.version} isn't supported by this wallet`);\n            }\n        }\n        const signedTransactions = [];\n        for (const transaction of transactions) {\n            signedTransactions.push(await this.signTransaction(transaction));\n        }\n        return signedTransactions;\n    }\n}\nexport class BaseMessageSignerWalletAdapter extends BaseSignerWalletAdapter {\n}\nexport class BaseSignInMessageSignerWalletAdapter extends BaseMessageSignerWalletAdapter {\n}\n//# sourceMappingURL=signer.js.map","import { verifyMessageSignature } from './signMessage.js';\nimport { arraysEqual } from './util.js';\n/**\n * TODO: docs\n */\nexport function verifySignIn(input, output) {\n    const { signedMessage, signature, account: { publicKey }, } = output;\n    const message = deriveSignInMessage(input, output);\n    return (!!message && verifyMessageSignature({ message, signedMessage, signature, publicKey: publicKey }));\n}\n/**\n * TODO: docs\n */\nexport function deriveSignInMessage(input, output) {\n    const text = deriveSignInMessageText(input, output);\n    if (!text)\n        return null;\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */\nexport function deriveSignInMessageText(input, output) {\n    const parsed = parseSignInMessage(output.signedMessage);\n    if (!parsed)\n        return null;\n    if (input.domain && input.domain !== parsed.domain)\n        return null;\n    if (input.address && input.address !== parsed.address)\n        return null;\n    if (input.statement !== parsed.statement)\n        return null;\n    if (input.uri !== parsed.uri)\n        return null;\n    if (input.version !== parsed.version)\n        return null;\n    if (input.chainId !== parsed.chainId)\n        return null;\n    if (input.nonce !== parsed.nonce)\n        return null;\n    if (input.issuedAt !== parsed.issuedAt)\n        return null;\n    if (input.expirationTime !== parsed.expirationTime)\n        return null;\n    if (input.notBefore !== parsed.notBefore)\n        return null;\n    if (input.requestId !== parsed.requestId)\n        return null;\n    if (input.resources) {\n        if (!parsed.resources)\n            return null;\n        if (!arraysEqual(input.resources, parsed.resources))\n            return null;\n    }\n    else if (parsed.resources)\n        return null;\n    return createSignInMessageText(parsed);\n}\n/**\n * TODO: docs\n */\nexport function parseSignInMessage(message) {\n    const text = new TextDecoder().decode(message);\n    return parseSignInMessageText(text);\n}\n// TODO: implement https://github.com/solana-labs/solana/blob/master/docs/src/proposals/off-chain-message-signing.md\nconst DOMAIN = '(?<domain>[^\\\\n]+?) wants you to sign in with your Solana account:\\\\n';\nconst ADDRESS = '(?<address>[^\\\\n]+)(?:\\\\n|$)';\nconst STATEMENT = '(?:\\\\n(?<statement>[\\\\S\\\\s]*?)(?:\\\\n|$))??';\nconst URI = '(?:\\\\nURI: (?<uri>[^\\\\n]+))?';\nconst VERSION = '(?:\\\\nVersion: (?<version>[^\\\\n]+))?';\nconst CHAIN_ID = '(?:\\\\nChain ID: (?<chainId>[^\\\\n]+))?';\nconst NONCE = '(?:\\\\nNonce: (?<nonce>[^\\\\n]+))?';\nconst ISSUED_AT = '(?:\\\\nIssued At: (?<issuedAt>[^\\\\n]+))?';\nconst EXPIRATION_TIME = '(?:\\\\nExpiration Time: (?<expirationTime>[^\\\\n]+))?';\nconst NOT_BEFORE = '(?:\\\\nNot Before: (?<notBefore>[^\\\\n]+))?';\nconst REQUEST_ID = '(?:\\\\nRequest ID: (?<requestId>[^\\\\n]+))?';\nconst RESOURCES = '(?:\\\\nResources:(?<resources>(?:\\\\n- [^\\\\n]+)*))?';\nconst FIELDS = `${URI}${VERSION}${CHAIN_ID}${NONCE}${ISSUED_AT}${EXPIRATION_TIME}${NOT_BEFORE}${REQUEST_ID}${RESOURCES}`;\nconst MESSAGE = new RegExp(`^${DOMAIN}${ADDRESS}${STATEMENT}${FIELDS}\\\\n*$`);\n/**\n * TODO: docs\n */\nexport function parseSignInMessageText(text) {\n    const match = MESSAGE.exec(text);\n    if (!match)\n        return null;\n    const groups = match.groups;\n    if (!groups)\n        return null;\n    return {\n        domain: groups.domain,\n        address: groups.address,\n        statement: groups.statement,\n        uri: groups.uri,\n        version: groups.version,\n        nonce: groups.nonce,\n        chainId: groups.chainId,\n        issuedAt: groups.issuedAt,\n        expirationTime: groups.expirationTime,\n        notBefore: groups.notBefore,\n        requestId: groups.requestId,\n        resources: groups.resources?.split('\\n- ').slice(1),\n    };\n}\n/**\n * TODO: docs\n */\nexport function createSignInMessage(input) {\n    const text = createSignInMessageText(input);\n    return new TextEncoder().encode(text);\n}\n/**\n * TODO: docs\n */\nexport function createSignInMessageText(input) {\n    // ${domain} wants you to sign in with your Solana account:\n    // ${address}\n    //\n    // ${statement}\n    //\n    // URI: ${uri}\n    // Version: ${version}\n    // Chain ID: ${chain}\n    // Nonce: ${nonce}\n    // Issued At: ${issued-at}\n    // Expiration Time: ${expiration-time}\n    // Not Before: ${not-before}\n    // Request ID: ${request-id}\n    // Resources:\n    // - ${resources[0]}\n    // - ${resources[1]}\n    // ...\n    // - ${resources[n]}\n    let message = `${input.domain} wants you to sign in with your Solana account:\\n`;\n    message += `${input.address}`;\n    if (input.statement) {\n        message += `\\n\\n${input.statement}`;\n    }\n    const fields = [];\n    if (input.uri) {\n        fields.push(`URI: ${input.uri}`);\n    }\n    if (input.version) {\n        fields.push(`Version: ${input.version}`);\n    }\n    if (input.chainId) {\n        fields.push(`Chain ID: ${input.chainId}`);\n    }\n    if (input.nonce) {\n        fields.push(`Nonce: ${input.nonce}`);\n    }\n    if (input.issuedAt) {\n        fields.push(`Issued At: ${input.issuedAt}`);\n    }\n    if (input.expirationTime) {\n        fields.push(`Expiration Time: ${input.expirationTime}`);\n    }\n    if (input.notBefore) {\n        fields.push(`Not Before: ${input.notBefore}`);\n    }\n    if (input.requestId) {\n        fields.push(`Request ID: ${input.requestId}`);\n    }\n    if (input.resources) {\n        fields.push(`Resources:`);\n        for (const resource of input.resources) {\n            fields.push(`- ${resource}`);\n        }\n    }\n    if (fields.length) {\n        message += `\\n\\n${fields.join('\\n')}`;\n    }\n    return message;\n}\n//# sourceMappingURL=signIn.js.map","import { SolanaSignAndSendTransaction, SolanaSignTransaction, } from '@solana/wallet-standard-features';\nimport { StandardConnect, StandardEvents, } from '@wallet-standard/features';\nexport function isWalletAdapterCompatibleStandardWallet(wallet) {\n    return (StandardConnect in wallet.features &&\n        StandardEvents in wallet.features &&\n        (SolanaSignAndSendTransaction in wallet.features || SolanaSignTransaction in wallet.features));\n}\n//# sourceMappingURL=standard.js.map","export var WalletAdapterNetwork;\n(function (WalletAdapterNetwork) {\n    WalletAdapterNetwork[\"Mainnet\"] = \"mainnet-beta\";\n    WalletAdapterNetwork[\"Testnet\"] = \"testnet\";\n    WalletAdapterNetwork[\"Devnet\"] = \"devnet\";\n})(WalletAdapterNetwork || (WalletAdapterNetwork = {}));\n//# sourceMappingURL=types.js.map","/** Name of the feature. */\nexport const SolanaSignAndSendTransaction = 'solana:signAndSendTransaction';\n//# sourceMappingURL=signAndSendTransaction.js.map","import EventEmitter from 'eventemitter3';\nimport { WalletNotConnectedError } from './errors.js';\nexport { EventEmitter };\n/**\n * A wallet's readiness describes a series of states that the wallet can be in,\n * depending on what kind of wallet it is. An installable wallet (eg. a browser\n * extension like Phantom) might be `Installed` if we've found the Phantom API\n * in the global scope, or `NotDetected` otherwise. A loadable, zero-install\n * runtime (eg. Torus Wallet) might simply signal that it's `Loadable`. Use this\n * metadata to personalize the wallet list for each user (eg. to show their\n * installed wallets first).\n */\nexport var WalletReadyState;\n(function (WalletReadyState) {\n    /**\n     * User-installable wallets can typically be detected by scanning for an API\n     * that they've injected into the global context. If such an API is present,\n     * we consider the wallet to have been installed.\n     */\n    WalletReadyState[\"Installed\"] = \"Installed\";\n    WalletReadyState[\"NotDetected\"] = \"NotDetected\";\n    /**\n     * Loadable wallets are always available to you. Since you can load them at\n     * any time, it's meaningless to say that they have been detected.\n     */\n    WalletReadyState[\"Loadable\"] = \"Loadable\";\n    /**\n     * If a wallet is not supported on a given platform (eg. server-rendering, or\n     * mobile) then it will stay in the `Unsupported` state.\n     */\n    WalletReadyState[\"Unsupported\"] = \"Unsupported\";\n})(WalletReadyState || (WalletReadyState = {}));\nexport class BaseWalletAdapter extends EventEmitter {\n    get connected() {\n        return !!this.publicKey;\n    }\n    async autoConnect() {\n        await this.connect();\n    }\n    async prepareTransaction(transaction, connection, options = {}) {\n        const publicKey = this.publicKey;\n        if (!publicKey)\n            throw new WalletNotConnectedError();\n        transaction.feePayer = transaction.feePayer || publicKey;\n        transaction.recentBlockhash =\n            transaction.recentBlockhash ||\n                (await connection.getLatestBlockhash({\n                    commitment: options.preflightCommitment,\n                    minContextSlot: options.minContextSlot,\n                })).blockhash;\n        return transaction;\n    }\n}\nexport function scopePollingDetectionStrategy(detect) {\n    // Early return when server-side rendering\n    if (typeof window === 'undefined' || typeof document === 'undefined')\n        return;\n    const disposers = [];\n    function detectAndDispose() {\n        const detected = detect();\n        if (detected) {\n            for (const dispose of disposers) {\n                dispose();\n            }\n        }\n    }\n    // Strategy #1: Try detecting every second.\n    const interval = \n    // TODO: #334 Replace with idle callback strategy.\n    setInterval(detectAndDispose, 1000);\n    disposers.push(() => clearInterval(interval));\n    // Strategy #2: Detect as soon as the DOM becomes 'ready'/'interactive'.\n    if (\n    // Implies that `DOMContentLoaded` has not yet fired.\n    document.readyState === 'loading') {\n        document.addEventListener('DOMContentLoaded', detectAndDispose, { once: true });\n        disposers.push(() => document.removeEventListener('DOMContentLoaded', detectAndDispose));\n    }\n    // Strategy #3: Detect after the `window` has fully loaded.\n    if (\n    // If the `complete` state has been reached, we're too late.\n    document.readyState !== 'complete') {\n        window.addEventListener('load', detectAndDispose, { once: true });\n        disposers.push(() => window.removeEventListener('load', detectAndDispose));\n    }\n    // Strategy #4: Detect synchronously, now.\n    detectAndDispose();\n}\n/**\n * Users on iOS can be redirected into a wallet's in-app browser automatically,\n * if that wallet has a universal link configured to do so\n * But should not be redirected from within a webview, eg. if they're already\n * inside a wallet's browser\n * This function can be used to identify users who are on iOS and can be redirected\n *\n * @returns true if the user can be redirected\n */\nexport function isIosAndRedirectable() {\n    // SSR: return false\n    if (!navigator)\n        return false;\n    const userAgent = navigator.userAgent.toLowerCase();\n    // if on iOS the user agent will contain either iPhone or iPad\n    // caveat: if requesting desktop site then this won't work\n    const isIos = userAgent.includes('iphone') || userAgent.includes('ipad');\n    // if in a webview then it will not include Safari\n    // note that other iOS browsers also include Safari\n    // so we will redirect only if Safari is also included\n    const isSafari = userAgent.includes('safari');\n    return isIos && isSafari;\n}\n//# sourceMappingURL=adapter.js.map"],"names":["isVersionedTransaction","transaction","ConnectionProvider","children","endpoint","config","commitment","connection","useMemo","Connection","Provider","value","useAnchorWallet","publicKey","signTransaction","signAllTransactions","useWallet","undefined","SolanaSignTransaction","StructError","TypeError","constructor","failure","failures","cached","message","explanation","rest","path","msg","length","join","super","this","cause","Object","assign","name","isObject","x","isNonArrayObject","Array","isArray","print","toString","JSON","stringify","toFailure","result","context","struct","branch","type","refinement","key","toFailures","Symbol","iterator","r","run","options","coerce","mask","ctx","coercer","status","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Struct","props","schema","assert","create","is","validate","tuples","tuple","input","done","next","shiftIterator","define","any","array","Element","i","slice","boolean","instance","Class","literal","constant","description","nullable","number","isNaN","optional","record","Key","Value","string","Structs","Never","Math","max","keys","union","map","S","error","coerced","first","push","unknown","condition","ConnectionContext","createContext","useConnection","useContext","basex","module","exports","useLocalStorage","defaultState","state","useState","localStorage","getItem","parse","window","console","isFirstRenderRef","useRef","useEffect","current","removeItem","setItem","isWalletAdapterCompatibleWallet","SolanaSignMessage","SolanaSignIn","getCommitment","_StandardWalletAdapter_instances","_StandardWalletAdapter_account","_StandardWalletAdapter_publicKey","_StandardWalletAdapter_connecting","_StandardWalletAdapter_disconnecting","_StandardWalletAdapter_off","_StandardWalletAdapter_supportedTransactionVersions","_StandardWalletAdapter_wallet","_StandardWalletAdapter_readyState","_StandardWalletAdapter_connect","_StandardWalletAdapter_connected","_StandardWalletAdapter_disconnected","_StandardWalletAdapter_reset","_StandardWalletAdapter_changed","_StandardWalletAdapter_signTransaction","_StandardWalletAdapter_signAllTransactions","_StandardWalletAdapter_signMessage","_StandardWalletAdapter_signIn","__classPrivateFieldGet","receiver","kind","f","has","call","get","__classPrivateFieldSet","StandardWalletAdapter","url","icon","readyState","connecting","supportedTransactionVersions","wallet","standard","document","Unsupported","Installed","properties","account","accounts","emit","features","on","destroy","off","autoConnect","silent","connect","disconnect","sendTransaction","feature","includes","chain","rpcEndpoint","test","chains","signers","sendOptions","serializedTransaction","sign","serialize","prepareTransaction","partialSign","Uint8Array","requireAllSignatures","verifySignatures","output","signAndSendTransaction","preflightCommitment","skipPreflight","maxRetries","minContextSlot","encode","signature","sendRawTransaction","signedTransaction","WeakMap","WeakSet","async","connected","PublicKey","address","signMessage","signIn","VersionedTransaction","deserialize","Transaction","from","transactions","signedTransactions","index","Environment","useConstant","fn","ref","wrapWalletsWithAdapters","wallets","filter","WalletProviderBase","adapters","adapter","isUnloadingRef","onAutoConnectRequest","onConnectError","onError","onSelectWallet","isConnectingRef","setConnecting","isDisconnectingRef","disconnecting","setDisconnecting","setPublicKey","setConnected","onErrorRef","handleErrorRef","open","setWallets","handleReadyStateChange","prevWallets","findIndex","forEach","find","handleConnect","handleDisconnect","handleError","didAttemptAutoConnectRef","Loadable","useCallback","e","select","_userAgent","getIsMobile","userAgentString","some","DESKTOP_WEB","isWebView","MOBILE_WEB","getEnvironment","globalThis","navigator","userAgent","getUriForAppIdentity","location","protocol","host","WalletProvider","localStorageKey","adaptersWithStandardAdapters","warnings","standardAdapters","setStandardAdapters","listeners","standardAdapter","prevStandardAdapters","usePrevious","currentAdapters","previousAdapter","warn","useStandardWalletAdapters","mobileWalletAdapter","existingMobileWalletAdapter","addressSelector","appIdentity","uri","authorizationResultCache","cluster","onWalletNotFound","adaptersWithMobileWalletAdapter","indexOf","walletName","setWalletName","a","changeWallet","nextWalletName","hasUserSelectedAWallet","handleAutoConnectRequest","addEventListener","handleBeforeUnload","removeEventListener","handleConnectError","selectWallet","WalletError","Error","WalletNotReadyError","arguments","WalletLoadError","WalletConfigError","WalletConnectionError","WalletDisconnectedError","WalletDisconnectionError","WalletAccountError","WalletPublicKeyError","WalletKeypairError","WalletNotConnectedError","WalletSendTransactionError","WalletSignTransactionError","WalletSignMessageError","WalletSignInError","WalletTimeoutError","WalletWindowBlockedError","WalletWindowClosedError","WalletNotSelectedError","EMPTY_ARRAY","DEFAULT_CONTEXT","logMissingProviderError","Promise","reject","action","property","defineProperty","WalletContext","BaseSignerWalletAdapter","version","rawTransaction","BaseMessageSignerWalletAdapter","BaseSignInMessageSignerWalletAdapter","createSignInMessageText","domain","statement","fields","chainId","nonce","issuedAt","expirationTime","notBefore","requestId","resources","resource","RegExp","isWalletAdapterCompatibleStandardWallet","WalletAdapterNetwork","SolanaSignAndSendTransaction","WalletReadyState","BaseWalletAdapter","feePayer","recentBlockhash","getLatestBlockhash","blockhash","scopePollingDetectionStrategy","detect","disposers","detectAndDispose","dispose","interval","setInterval","clearInterval","once","isIosAndRedirectable","toLowerCase","isIos","isSafari"],"sourceRoot":""}