{"version":3,"file":"main-4.0.1-336.js","mappings":"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","sources":["webpack://@jup-ag/terminal/./node_modules/@coral-xyz/anchor/dist/browser/index.js"],"sourcesContent":["import BN from 'bn.js';\nexport { default as BN } from 'bn.js';\nimport { PublicKey, Transaction, TransactionInstruction, SendTransactionError, NONCE_ACCOUNT_LENGTH, SystemProgram } from '@solana/web3.js';\nimport * as web3_js from '@solana/web3.js';\nexport { web3_js as web3 };\nimport { Buffer as Buffer$1 } from 'buffer';\nimport bs58$1 from 'bs58';\nimport camelCase from 'camelcase';\nimport * as borsh from '@coral-xyz/borsh';\nimport { sha256 as sha256$1 } from '@noble/hashes/sha256';\nimport { inflate } from 'pako';\nimport EventEmitter from 'eventemitter3';\n\n/**\n * Splits an array into chunks\n *\n * @param array Array of objects to chunk.\n * @param size The max size of a chunk.\n * @returns A two dimensional array where each T[] length is < the provided size.\n */\nfunction chunks(array, size) {\n    return Array.apply(0, new Array(Math.ceil(array.length / size))).map((_, index) => array.slice(index * size, (index + 1) * size));\n}\n/**\n * Check if a transaction object is a VersionedTransaction or not\n *\n * @param tx\n * @returns bool\n */\nconst isVersionedTransaction = (tx) => {\n    return \"version\" in tx;\n};\n\nfunction encode$3(data) {\n    return data.reduce((str, byte) => str + byte.toString(16).padStart(2, \"0\"), \"0x\");\n}\nfunction decode$3(data) {\n    if (data.indexOf(\"0x\") === 0) {\n        data = data.substr(2);\n    }\n    if (data.length % 2 === 1) {\n        data = \"0\" + data;\n    }\n    let key = data.match(/.{2}/g);\n    if (key === null) {\n        return Buffer$1.from([]);\n    }\n    return Buffer$1.from(key.map((byte) => parseInt(byte, 16)));\n}\n\nvar hex = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    encode: encode$3,\n    decode: decode$3\n});\n\nfunction decode$2(array) {\n    const decoder = new TextDecoder(\"utf-8\") // Browser https://caniuse.com/textencoder.\n        ; // Node.\n    return decoder.decode(array);\n}\nfunction encode$2(input) {\n    const encoder = new TextEncoder() // Browser.\n        ; // Node.\n    return encoder.encode(input);\n}\n\nvar utf8 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    decode: decode$2,\n    encode: encode$2\n});\n\nfunction encode$1(data) {\n    return bs58$1.encode(data);\n}\nfunction decode$1(data) {\n    return bs58$1.decode(data);\n}\n\nvar bs58 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    encode: encode$1,\n    decode: decode$1\n});\n\nfunction encode(data) {\n    return data.toString(\"base64\");\n}\nfunction decode(data) {\n    return Buffer$1.from(data, \"base64\");\n}\n\nvar base64 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    encode: encode,\n    decode: decode\n});\n\nvar index$1 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    hex: hex,\n    utf8: utf8,\n    bs58: bs58,\n    base64: base64\n});\n\nfunction isCompositeAccounts(accountItem) {\n    return \"accounts\" in accountItem;\n}\n// Deterministic IDL address as a function of the program id.\nasync function idlAddress(programId) {\n    const base = (await PublicKey.findProgramAddress([], programId))[0];\n    return await PublicKey.createWithSeed(base, seed(), programId);\n}\n// Seed for generating the idlAddress.\nfunction seed() {\n    return \"anchor:idl\";\n}\nconst IDL_ACCOUNT_LAYOUT = borsh.struct([\n    borsh.publicKey(\"authority\"),\n    borsh.vecU8(\"data\"),\n]);\nfunction decodeIdlAccount(data) {\n    return IDL_ACCOUNT_LAYOUT.decode(data);\n}\n/**\n * Convert the given IDL to camelCase.\n *\n * The IDL is generated from Rust which has different conventions compared to\n * JS/TS, e.g. instruction names in Rust are snake_case.\n *\n * The conversion happens automatically for programs, however, if you are using\n * internals such as `BorshInstructionCoder` and you only have the original\n * (not camelCase) IDL, you might need to use this function.\n *\n * @param idl IDL to convert to camelCase\n * @returns camelCase version of the IDL\n */\nfunction convertIdlToCamelCase(idl) {\n    const KEYS_TO_CONVERT = [\"name\", \"path\", \"account\", \"relations\", \"generic\"];\n    // `my_account.field` is getting converted to `myAccountField` but we\n    // need `myAccount.field`.\n    const toCamelCase = (s) => s.split(\".\").map(camelCase).join(\".\");\n    const recursivelyConvertNamesToCamelCase = (obj) => {\n        for (const key in obj) {\n            const val = obj[key];\n            if (KEYS_TO_CONVERT.includes(key)) {\n                obj[key] = Array.isArray(val) ? val.map(toCamelCase) : toCamelCase(val);\n            }\n            else if (typeof val === \"object\") {\n                recursivelyConvertNamesToCamelCase(val);\n            }\n        }\n    };\n    const camelCasedIdl = structuredClone(idl);\n    recursivelyConvertNamesToCamelCase(camelCasedIdl);\n    return camelCasedIdl;\n}\n/** Conveniently handle all defined field kinds with proper type support. */\nfunction handleDefinedFields(fields, unitCb, namedCb, tupleCb) {\n    // Unit\n    if (!(fields === null || fields === void 0 ? void 0 : fields.length))\n        return unitCb();\n    // Named\n    if (fields[0].name) {\n        return namedCb(fields);\n    }\n    // Tuple\n    return tupleCb(fields);\n}\n\nfunction parseIdlErrors(idl) {\n    const errors = new Map();\n    if (idl.errors) {\n        idl.errors.forEach((e) => {\n            var _a;\n            let msg = (_a = e.msg) !== null && _a !== void 0 ? _a : e.name;\n            errors.set(e.code, msg);\n        });\n    }\n    return errors;\n}\nfunction toInstruction(idlIx, ...args) {\n    if (idlIx.args.length != args.length) {\n        throw new Error(\"Invalid argument length\");\n    }\n    const ix = {};\n    let idx = 0;\n    idlIx.args.forEach((ixArg) => {\n        ix[ixArg.name] = args[idx];\n        idx += 1;\n    });\n    return ix;\n}\n// Throws error if any account required for the `ix` is not given.\nfunction validateAccounts(ixAccounts, accounts = {}) {\n    ixAccounts.forEach((acc) => {\n        if (isCompositeAccounts(acc)) {\n            validateAccounts(acc.accounts, accounts[acc.name]);\n        }\n        else {\n            if (!accounts[acc.name]) {\n                throw new Error(`Account \\`${acc.name}\\` not provided.`);\n            }\n        }\n    });\n}\n// Translates an address to a Pubkey.\nfunction translateAddress(address) {\n    return address instanceof PublicKey ? address : new PublicKey(address);\n}\n\n/**\n * A `StructFailure` represents a single specific failure in validation.\n */\n\n/**\n * `StructError` objects are thrown (or returned) when validation fails.\n *\n * Validation logic is design to exit early for maximum performance. The error\n * represents the first error encountered during validation. For more detail,\n * the `error.failures` property is a generator function that can be run to\n * continue validation and receive all the failures in the data.\n */\nclass StructError extends TypeError {\n  constructor(failure, failures) {\n    let cached;\n    const {\n      message,\n      ...rest\n    } = failure;\n    const {\n      path\n    } = failure;\n    const msg = path.length === 0 ? message : \"At path: \" + path.join('.') + \" -- \" + message;\n    super(msg);\n    this.value = void 0;\n    this.key = void 0;\n    this.type = void 0;\n    this.refinement = void 0;\n    this.path = void 0;\n    this.branch = void 0;\n    this.failures = void 0;\n    Object.assign(this, rest);\n    this.name = this.constructor.name;\n\n    this.failures = () => {\n      var _cached;\n\n      return (_cached = cached) != null ? _cached : cached = [failure, ...failures()];\n    };\n  }\n\n}\n\n/**\n * Check if a value is an iterator.\n */\nfunction isIterable(x) {\n  return isObject(x) && typeof x[Symbol.iterator] === 'function';\n}\n/**\n * Check if a value is a plain object.\n */\n\n\nfunction isObject(x) {\n  return typeof x === 'object' && x != null;\n}\n/**\n * Return a value as a printable string.\n */\n\nfunction print(value) {\n  return typeof value === 'string' ? JSON.stringify(value) : \"\" + value;\n}\n/**\n * Shifts (removes and returns) the first value from the `input` iterator.\n * Like `Array.prototype.shift()` but for an `Iterator`.\n */\n\nfunction shiftIterator(input) {\n  const {\n    done,\n    value\n  } = input.next();\n  return done ? undefined : value;\n}\n/**\n * Convert a single validation result to a failure.\n */\n\nfunction toFailure(result, context, struct, value) {\n  if (result === true) {\n    return;\n  } else if (result === false) {\n    result = {};\n  } else if (typeof result === 'string') {\n    result = {\n      message: result\n    };\n  }\n\n  const {\n    path,\n    branch\n  } = context;\n  const {\n    type\n  } = struct;\n  const {\n    refinement,\n    message = \"Expected a value of type `\" + type + \"`\" + (refinement ? \" with refinement `\" + refinement + \"`\" : '') + \", but received: `\" + print(value) + \"`\"\n  } = result;\n  return {\n    value,\n    type,\n    refinement,\n    key: path[path.length - 1],\n    path,\n    branch,\n    ...result,\n    message\n  };\n}\n/**\n * Convert a validation result to an iterable of failures.\n */\n\nfunction* toFailures(result, context, struct, value) {\n  if (!isIterable(result)) {\n    result = [result];\n  }\n\n  for (const r of result) {\n    const failure = toFailure(r, context, struct, value);\n\n    if (failure) {\n      yield failure;\n    }\n  }\n}\n/**\n * Check a value against a struct, traversing deeply into nested values, and\n * returning an iterator of failures or success.\n */\n\nfunction* run(value, struct, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const {\n    path = [],\n    branch = [value],\n    coerce = false,\n    mask = false\n  } = options;\n  const ctx = {\n    path,\n    branch\n  };\n\n  if (coerce) {\n    value = struct.coercer(value, ctx);\n\n    if (mask && struct.type !== 'type' && isObject(struct.schema) && isObject(value) && !Array.isArray(value)) {\n      for (const key in value) {\n        if (struct.schema[key] === undefined) {\n          delete value[key];\n        }\n      }\n    }\n  }\n\n  let valid = true;\n\n  for (const failure of struct.validator(value, ctx)) {\n    valid = false;\n    yield [failure, undefined];\n  }\n\n  for (let [k, v, s] of struct.entries(value, ctx)) {\n    const ts = run(v, s, {\n      path: k === undefined ? path : [...path, k],\n      branch: k === undefined ? branch : [...branch, v],\n      coerce,\n      mask\n    });\n\n    for (const t of ts) {\n      if (t[0]) {\n        valid = false;\n        yield [t[0], undefined];\n      } else if (coerce) {\n        v = t[1];\n\n        if (k === undefined) {\n          value = v;\n        } else if (value instanceof Map) {\n          value.set(k, v);\n        } else if (value instanceof Set) {\n          value.add(v);\n        } else if (isObject(value)) {\n          value[k] = v;\n        }\n      }\n    }\n  }\n\n  if (valid) {\n    for (const failure of struct.refiner(value, ctx)) {\n      valid = false;\n      yield [failure, undefined];\n    }\n  }\n\n  if (valid) {\n    yield [undefined, value];\n  }\n}\n\n/**\n * `Struct` objects encapsulate the validation logic for a specific type of\n * values. Once constructed, you use the `assert`, `is` or `validate` helpers to\n * validate unknown input data against the struct.\n */\n\nclass Struct {\n  constructor(props) {\n    this.TYPE = void 0;\n    this.type = void 0;\n    this.schema = void 0;\n    this.coercer = void 0;\n    this.validator = void 0;\n    this.refiner = void 0;\n    this.entries = void 0;\n    const {\n      type,\n      schema,\n      validator,\n      refiner,\n      coercer = value => value,\n      entries = function* () {}\n    } = props;\n    this.type = type;\n    this.schema = schema;\n    this.entries = entries;\n    this.coercer = coercer;\n\n    if (validator) {\n      this.validator = (value, context) => {\n        const result = validator(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.validator = () => [];\n    }\n\n    if (refiner) {\n      this.refiner = (value, context) => {\n        const result = refiner(value, context);\n        return toFailures(result, context, this, value);\n      };\n    } else {\n      this.refiner = () => [];\n    }\n  }\n  /**\n   * Assert that a value passes the struct's validation, throwing if it doesn't.\n   */\n\n\n  assert(value) {\n    return assert(value, this);\n  }\n  /**\n   * Create a value with the struct's coercion logic, then validate it.\n   */\n\n\n  create(value) {\n    return create(value, this);\n  }\n  /**\n   * Check if a value passes the struct's validation.\n   */\n\n\n  is(value) {\n    return is(value, this);\n  }\n  /**\n   * Mask a value, coercing and validating it, but returning only the subset of\n   * properties defined by the struct's schema.\n   */\n\n\n  mask(value) {\n    return mask(value, this);\n  }\n  /**\n   * Validate a value with the struct's validation logic, returning a tuple\n   * representing the result.\n   *\n   * You may optionally pass `true` for the `withCoercion` argument to coerce\n   * the value before attempting to validate it. If you do, the result will\n   * contain the coerced result when successful.\n   */\n\n\n  validate(value, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    return validate(value, this, options);\n  }\n\n}\n/**\n * Assert that a value passes a struct, throwing if it doesn't.\n */\n\nfunction assert(value, struct) {\n  const result = validate(value, struct);\n\n  if (result[0]) {\n    throw result[0];\n  }\n}\n/**\n * Create a value with the coercion logic of struct and validate it.\n */\n\nfunction create(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Mask a value, returning only the subset of properties defined by a struct.\n */\n\nfunction mask(value, struct) {\n  const result = validate(value, struct, {\n    coerce: true,\n    mask: true\n  });\n\n  if (result[0]) {\n    throw result[0];\n  } else {\n    return result[1];\n  }\n}\n/**\n * Check if a value passes a struct.\n */\n\nfunction is(value, struct) {\n  const result = validate(value, struct);\n  return !result[0];\n}\n/**\n * Validate a value against a struct, returning an error if invalid, or the\n * value (with potential coercion) if valid.\n */\n\nfunction validate(value, struct, options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  const tuples = run(value, struct, options);\n  const tuple = shiftIterator(tuples);\n\n  if (tuple[0]) {\n    const error = new StructError(tuple[0], function* () {\n      for (const t of tuples) {\n        if (t[0]) {\n          yield t[0];\n        }\n      }\n    });\n    return [error, undefined];\n  } else {\n    const v = tuple[1];\n    return [undefined, v];\n  }\n}\n/**\n * Define a new struct type with a custom validation function.\n */\n\nfunction define(name, validator) {\n  return new Struct({\n    type: name,\n    schema: null,\n    validator\n  });\n}\n\n/**\n * Ensure that any value passes validation.\n */\n\nfunction any() {\n  return define('any', () => true);\n}\nfunction array(Element) {\n  return new Struct({\n    type: 'array',\n    schema: Element,\n\n    *entries(value) {\n      if (Element && Array.isArray(value)) {\n        for (const [i, v] of value.entries()) {\n          yield [i, v, Element];\n        }\n      }\n    },\n\n    coercer(value) {\n      return Array.isArray(value) ? value.slice() : value;\n    },\n\n    validator(value) {\n      return Array.isArray(value) || \"Expected an array value, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value is a boolean.\n */\n\nfunction boolean() {\n  return define('boolean', value => {\n    return typeof value === 'boolean';\n  });\n}\nfunction literal(constant) {\n  const description = print(constant);\n  const t = typeof constant;\n  return new Struct({\n    type: 'literal',\n    schema: t === 'string' || t === 'number' || t === 'boolean' ? constant : null,\n\n    validator(value) {\n      return value === constant || \"Expected the literal `\" + description + \"`, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Augment an existing struct to allow `null` values.\n */\n\nfunction nullable(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === null || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === null || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a number.\n */\n\nfunction number() {\n  return define('number', value => {\n    return typeof value === 'number' && !isNaN(value) || \"Expected a number, but received: \" + print(value);\n  });\n}\n/**\n * Augment a struct to allow `undefined` values.\n */\n\nfunction optional(struct) {\n  return new Struct({ ...struct,\n    validator: (value, ctx) => value === undefined || struct.validator(value, ctx),\n    refiner: (value, ctx) => value === undefined || struct.refiner(value, ctx)\n  });\n}\n/**\n * Ensure that a value is a string.\n */\n\nfunction string() {\n  return define('string', value => {\n    return typeof value === 'string' || \"Expected a string, but received: \" + print(value);\n  });\n}\n/**\n * Ensure that a value has a set of known properties of specific types.\n *\n * Note: Unrecognized properties are allowed and untouched. This is similar to\n * how TypeScript's structural typing works.\n */\n\nfunction type(schema) {\n  const keys = Object.keys(schema);\n  return new Struct({\n    type: 'type',\n    schema,\n\n    *entries(value) {\n      if (isObject(value)) {\n        for (const k of keys) {\n          yield [k, value[k], schema[k]];\n        }\n      }\n    },\n\n    validator(value) {\n      return isObject(value) || \"Expected an object, but received: \" + print(value);\n    }\n\n  });\n}\n/**\n * Ensure that a value matches one of a set of types.\n */\n\nfunction union$1(Structs) {\n  const description = Structs.map(s => s.type).join(' | ');\n  return new Struct({\n    type: 'union',\n    schema: null,\n\n    coercer(value, ctx) {\n      const firstMatch = Structs.find(s => {\n        const [e] = s.validate(value, {\n          coerce: true\n        });\n        return !e;\n      }) || unknown();\n      return firstMatch.coercer(value, ctx);\n    },\n\n    validator(value, ctx) {\n      const failures = [];\n\n      for (const S of Structs) {\n        const [...tuples] = run(value, S, ctx);\n        const [first] = tuples;\n\n        if (!first[0]) {\n          return [];\n        } else {\n          for (const [failure] of tuples) {\n            if (failure) {\n              failures.push(failure);\n            }\n          }\n        }\n      }\n\n      return [\"Expected the value to satisfy a union of `\" + description + \"`, but received: \" + print(value), ...failures];\n    }\n\n  });\n}\n/**\n * Ensure that any value passes validation, without widening its type to `any`.\n */\n\nfunction unknown() {\n  return define('unknown', () => true);\n}\n\n/**\n * Augment a `Struct` to add an additional coercion step to its input.\n *\n * This allows you to transform input data before validating it, to increase the\n * likelihood that it passes validation—for example for default values, parsing\n * different formats, etc.\n *\n * Note: You must use `create(value, Struct)` on the value to have the coercion\n * take effect! Using simply `assert()` or `is()` will not use coercion.\n */\n\nfunction coerce(struct, condition, coercer) {\n  return new Struct({ ...struct,\n    coercer: (value, ctx) => {\n      return is(value, condition) ? struct.coercer(coercer(value, ctx), ctx) : struct.coercer(value, ctx);\n    }\n  });\n}\n\n/**\n * Sends a transaction to a program with the given accounts and instruction\n * data.\n */\nasync function invoke(programId, accounts, data, provider) {\n    programId = translateAddress(programId);\n    if (!provider) {\n        provider = getProvider();\n    }\n    const tx = new Transaction();\n    tx.add(new TransactionInstruction({\n        programId,\n        keys: accounts !== null && accounts !== void 0 ? accounts : [],\n        data,\n    }));\n    if (provider.sendAndConfirm === undefined) {\n        throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");\n    }\n    return await provider.sendAndConfirm(tx, []);\n}\nconst GET_MULTIPLE_ACCOUNTS_LIMIT = 99;\nasync function getMultipleAccounts(connection, publicKeys, commitment) {\n    const results = await getMultipleAccountsAndContext(connection, publicKeys, commitment);\n    return results.map((result) => {\n        return result\n            ? { publicKey: result.publicKey, account: result.account }\n            : null;\n    });\n}\nasync function getMultipleAccountsAndContext(connection, publicKeys, commitment) {\n    if (publicKeys.length <= GET_MULTIPLE_ACCOUNTS_LIMIT) {\n        return await getMultipleAccountsAndContextCore(connection, publicKeys, commitment);\n    }\n    else {\n        const batches = chunks(publicKeys, GET_MULTIPLE_ACCOUNTS_LIMIT);\n        const results = await Promise.all(batches.map((batch) => getMultipleAccountsAndContextCore(connection, batch, commitment)));\n        return results.flat();\n    }\n}\nasync function getMultipleAccountsAndContextCore(connection, publicKeys, commitmentOverride) {\n    const commitment = commitmentOverride !== null && commitmentOverride !== void 0 ? commitmentOverride : connection.commitment;\n    const { value: accountInfos, context } = await connection.getMultipleAccountsInfoAndContext(publicKeys, commitment);\n    const accounts = accountInfos.map((account, idx) => {\n        if (account === null) {\n            return null;\n        }\n        return {\n            publicKey: publicKeys[idx],\n            account,\n            context,\n        };\n    });\n    return accounts;\n}\n// copy from @solana/web3.js that has a commitment param\nasync function simulateTransaction(connection, transaction, signers, commitment, includeAccounts) {\n    var _a;\n    if (signers && signers.length > 0) {\n        transaction.sign(...signers);\n    }\n    // @ts-expect-error\n    const message = transaction._compile();\n    const signData = message.serialize();\n    // @ts-expect-error\n    const wireTransaction = transaction._serialize(signData);\n    const encodedTransaction = wireTransaction.toString(\"base64\");\n    const config = {\n        encoding: \"base64\",\n        commitment: commitment !== null && commitment !== void 0 ? commitment : connection.commitment,\n    };\n    if (includeAccounts) {\n        const addresses = (Array.isArray(includeAccounts) ? includeAccounts : message.nonProgramIds()).map((key) => key.toBase58());\n        config[\"accounts\"] = {\n            encoding: \"base64\",\n            addresses,\n        };\n    }\n    if (signers && signers.length > 0) {\n        config.sigVerify = true;\n    }\n    const args = [encodedTransaction, config];\n    // @ts-expect-error\n    const unsafeRes = await connection._rpcRequest(\"simulateTransaction\", args);\n    const res = create(unsafeRes, SimulatedTransactionResponseStruct);\n    if (\"error\" in res) {\n        let logs;\n        if (\"data\" in res.error) {\n            logs = (_a = res.error.data) === null || _a === void 0 ? void 0 : _a.logs;\n            if (logs && Array.isArray(logs)) {\n                const traceIndent = \"\\n    \";\n                const logTrace = traceIndent + logs.join(traceIndent);\n                console.error(res.error.message, logTrace);\n            }\n        }\n        throw new SendTransactionError(\"failed to simulate transaction: \" + res.error.message, logs);\n    }\n    return res.result;\n}\n// copy from @solana/web3.js\nfunction jsonRpcResult(schema) {\n    return coerce(createRpcResult(schema), UnknownRpcResult, (value) => {\n        if (\"error\" in value) {\n            return value;\n        }\n        else {\n            return {\n                ...value,\n                result: create(value.result, schema),\n            };\n        }\n    });\n}\n// copy from @solana/web3.js\nconst UnknownRpcResult = createRpcResult(unknown());\n// copy from @solana/web3.js\nfunction createRpcResult(result) {\n    return union$1([\n        type({\n            jsonrpc: literal(\"2.0\"),\n            id: string(),\n            result,\n        }),\n        type({\n            jsonrpc: literal(\"2.0\"),\n            id: string(),\n            error: type({\n                code: unknown(),\n                message: string(),\n                data: optional(any()),\n            }),\n        }),\n    ]);\n}\n// copy from @solana/web3.js\nfunction jsonRpcResultAndContext(value) {\n    return jsonRpcResult(type({\n        context: type({\n            slot: number(),\n        }),\n        value,\n    }));\n}\n// copy from @solana/web3.js\nconst SimulatedTransactionResponseStruct = jsonRpcResultAndContext(type({\n    err: nullable(union$1([type({}), string()])),\n    logs: nullable(array(string())),\n    accounts: optional(nullable(array(nullable(type({\n        executable: boolean(),\n        owner: string(),\n        lamports: number(),\n        data: array(string()),\n        rentEpoch: optional(number()),\n    }))))),\n    unitsConsumed: optional(number()),\n}));\n\nvar rpc = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    invoke: invoke,\n    getMultipleAccounts: getMultipleAccounts,\n    getMultipleAccountsAndContext: getMultipleAccountsAndContext,\n    simulateTransaction: simulateTransaction\n});\n\n/**\n * The network and wallet context used to send transactions paid for and signed\n * by the provider.\n */\nclass AnchorProvider {\n    /**\n     * @param connection The cluster connection where the program is deployed.\n     * @param wallet     The wallet used to pay for and sign all transactions.\n     * @param opts       Transaction confirmation options to use by default.\n     */\n    constructor(connection, wallet, opts = AnchorProvider.defaultOptions()) {\n        this.connection = connection;\n        this.wallet = wallet;\n        this.opts = opts;\n        this.publicKey = wallet === null || wallet === void 0 ? void 0 : wallet.publicKey;\n    }\n    static defaultOptions() {\n        return {\n            preflightCommitment: \"processed\",\n            commitment: \"processed\",\n        };\n    }\n    /**\n     * Returns a `Provider` with a wallet read from the local filesystem.\n     *\n     * @param url  The network cluster url.\n     * @param opts The default transaction confirmation options.\n     *\n     * (This api is for Node only.)\n     */\n    static local(url, opts = AnchorProvider.defaultOptions()) {\n        {\n            throw new Error(`Provider local is not available on browser.`);\n        }\n    }\n    /**\n     * Returns a `Provider` read from the `ANCHOR_PROVIDER_URL` environment\n     * variable\n     *\n     * (This api is for Node only.)\n     */\n    static env() {\n        {\n            throw new Error(`Provider env is not available on browser.`);\n        }\n    }\n    /**\n     * Sends the given transaction, paid for and signed by the provider's wallet.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The signers of the transaction.\n     * @param opts    Transaction confirmation options.\n     */\n    async sendAndConfirm(tx, signers, opts) {\n        var _a, _b, _c, _d;\n        if (opts === undefined) {\n            opts = this.opts;\n        }\n        if (isVersionedTransaction(tx)) {\n            if (signers) {\n                tx.sign(signers);\n            }\n        }\n        else {\n            tx.feePayer = (_a = tx.feePayer) !== null && _a !== void 0 ? _a : this.wallet.publicKey;\n            tx.recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;\n            if (signers) {\n                for (const signer of signers) {\n                    tx.partialSign(signer);\n                }\n            }\n        }\n        tx = await this.wallet.signTransaction(tx);\n        const rawTx = tx.serialize();\n        try {\n            return await sendAndConfirmRawTransaction(this.connection, rawTx, opts);\n        }\n        catch (err) {\n            // thrown if the underlying 'confirmTransaction' encounters a failed tx\n            // the 'confirmTransaction' error does not return logs so we make another rpc call to get them\n            if (err instanceof ConfirmError) {\n                // choose the shortest available commitment for 'getTransaction'\n                // (the json RPC does not support any shorter than \"confirmed\" for 'getTransaction')\n                // because that will see the tx sent with `sendAndConfirmRawTransaction` no matter which\n                // commitment `sendAndConfirmRawTransaction` used\n                const txSig = encode$1(isVersionedTransaction(tx)\n                    ? ((_b = tx.signatures) === null || _b === void 0 ? void 0 : _b[0]) || new Uint8Array()\n                    : (_c = tx.signature) !== null && _c !== void 0 ? _c : new Uint8Array());\n                const maxVer = isVersionedTransaction(tx) ? 0 : undefined;\n                const failedTx = await this.connection.getTransaction(txSig, {\n                    commitment: \"confirmed\",\n                    maxSupportedTransactionVersion: maxVer,\n                });\n                if (!failedTx) {\n                    throw err;\n                }\n                else {\n                    const logs = (_d = failedTx.meta) === null || _d === void 0 ? void 0 : _d.logMessages;\n                    throw !logs ? err : new SendTransactionError(err.message, logs);\n                }\n            }\n            else {\n                throw err;\n            }\n        }\n    }\n    /**\n     * Similar to `send`, but for an array of transactions and signers.\n     * All transactions need to be of the same type, it doesn't support a mix of `VersionedTransaction`s and `Transaction`s.\n     *\n     * @param txWithSigners Array of transactions and signers.\n     * @param opts          Transaction confirmation options.\n     */\n    async sendAll(txWithSigners, opts) {\n        var _a, _b, _c;\n        if (opts === undefined) {\n            opts = this.opts;\n        }\n        const recentBlockhash = (await this.connection.getLatestBlockhash(opts.preflightCommitment)).blockhash;\n        let txs = txWithSigners.map((r) => {\n            var _a, _b;\n            if (isVersionedTransaction(r.tx)) {\n                let tx = r.tx;\n                if (r.signers) {\n                    tx.sign(r.signers);\n                }\n                return tx;\n            }\n            else {\n                let tx = r.tx;\n                let signers = (_a = r.signers) !== null && _a !== void 0 ? _a : [];\n                tx.feePayer = (_b = tx.feePayer) !== null && _b !== void 0 ? _b : this.wallet.publicKey;\n                tx.recentBlockhash = recentBlockhash;\n                signers.forEach((kp) => {\n                    tx.partialSign(kp);\n                });\n                return tx;\n            }\n        });\n        const signedTxs = await this.wallet.signAllTransactions(txs);\n        const sigs = [];\n        for (let k = 0; k < txs.length; k += 1) {\n            const tx = signedTxs[k];\n            const rawTx = tx.serialize();\n            try {\n                sigs.push(await sendAndConfirmRawTransaction(this.connection, rawTx, opts));\n            }\n            catch (err) {\n                // thrown if the underlying 'confirmTransaction' encounters a failed tx\n                // the 'confirmTransaction' error does not return logs so we make another rpc call to get them\n                if (err instanceof ConfirmError) {\n                    // choose the shortest available commitment for 'getTransaction'\n                    // (the json RPC does not support any shorter than \"confirmed\" for 'getTransaction')\n                    // because that will see the tx sent with `sendAndConfirmRawTransaction` no matter which\n                    // commitment `sendAndConfirmRawTransaction` used\n                    const txSig = encode$1(isVersionedTransaction(tx)\n                        ? ((_a = tx.signatures) === null || _a === void 0 ? void 0 : _a[0]) || new Uint8Array()\n                        : (_b = tx.signature) !== null && _b !== void 0 ? _b : new Uint8Array());\n                    const maxVer = isVersionedTransaction(tx) ? 0 : undefined;\n                    const failedTx = await this.connection.getTransaction(txSig, {\n                        commitment: \"confirmed\",\n                        maxSupportedTransactionVersion: maxVer,\n                    });\n                    if (!failedTx) {\n                        throw err;\n                    }\n                    else {\n                        const logs = (_c = failedTx.meta) === null || _c === void 0 ? void 0 : _c.logMessages;\n                        throw !logs ? err : new SendTransactionError(err.message, logs);\n                    }\n                }\n                else {\n                    throw err;\n                }\n            }\n        }\n        return sigs;\n    }\n    /**\n     * Simulates the given transaction, returning emitted logs from execution.\n     *\n     * @param tx      The transaction to send.\n     * @param signers The signers of the transaction. If unset, the transaction\n     *                will be simulated with the \"sigVerify: false\" option. This\n     *                allows for simulation of transactions without asking the\n     *                wallet for a signature.\n     * @param opts    Transaction confirmation options.\n     */\n    async simulate(tx, signers, commitment, includeAccounts) {\n        let recentBlockhash = (await this.connection.getLatestBlockhash(commitment !== null && commitment !== void 0 ? commitment : this.connection.commitment)).blockhash;\n        let result;\n        if (isVersionedTransaction(tx)) {\n            if (signers && signers.length > 0) {\n                tx.sign(signers);\n                tx = await this.wallet.signTransaction(tx);\n            }\n            // Doesn't support includeAccounts which has been changed to something\n            // else in later versions of this function.\n            result = await this.connection.simulateTransaction(tx, { commitment });\n        }\n        else {\n            tx.feePayer = tx.feePayer || this.wallet.publicKey;\n            tx.recentBlockhash = recentBlockhash;\n            if (signers && signers.length > 0) {\n                tx = await this.wallet.signTransaction(tx);\n            }\n            result = await simulateTransaction(this.connection, tx, signers, commitment, includeAccounts);\n        }\n        if (result.value.err) {\n            throw new SimulateError(result.value);\n        }\n        return result.value;\n    }\n}\nclass SimulateError extends Error {\n    constructor(simulationResponse, message) {\n        super(message);\n        this.simulationResponse = simulationResponse;\n    }\n}\n// Copy of Connection.sendAndConfirmRawTransaction that throws\n// a better error if 'confirmTransaction` returns an error status\nasync function sendAndConfirmRawTransaction(connection, rawTransaction, options) {\n    const sendOptions = options\n        ? {\n            skipPreflight: options.skipPreflight,\n            preflightCommitment: options.preflightCommitment || options.commitment,\n            maxRetries: options.maxRetries,\n            minContextSlot: options.minContextSlot,\n        }\n        : {};\n    let status;\n    const startTime = Date.now();\n    while (Date.now() - startTime < 60000) {\n        try {\n            const signature = await connection.sendRawTransaction(rawTransaction, sendOptions);\n            if (options === null || options === void 0 ? void 0 : options.blockhash) {\n                if (sendOptions.maxRetries === 0) {\n                    const abortSignal = AbortSignal.timeout(15000);\n                    status = (await connection.confirmTransaction({ abortSignal, signature, ...options.blockhash }, options && options.commitment)).value;\n                }\n                else {\n                    status = (await connection.confirmTransaction({ signature, ...options.blockhash }, options && options.commitment)).value;\n                }\n            }\n            else {\n                status = (await connection.confirmTransaction(signature, options && options.commitment)).value;\n            }\n            if (status.err) {\n                throw new ConfirmError(`Raw transaction ${signature} failed (${JSON.stringify(status)})`);\n            }\n            return signature;\n        }\n        catch (err) {\n            if (err.name === \"TimeoutError\") {\n                continue;\n            }\n            throw err;\n        }\n    }\n    throw Error(\"Transaction failed to confirm in 60s\");\n}\nclass ConfirmError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\n/**\n * Sets the default provider on the client.\n */\nfunction setProvider(provider) {\n    _provider = provider;\n}\n/**\n * Returns the default provider being used by the client.\n */\nfunction getProvider() {\n    if (_provider === null) {\n        return AnchorProvider.local();\n    }\n    return _provider;\n}\n// Global provider used as the default when a provider is not given.\nlet _provider = null;\n\nvar commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};\n\nfunction getDefaultExportFromCjs (x) {\n\treturn x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;\n}\n\nvar dist = {};\n\n// Instruction errors.\nObject.defineProperty(dist, \"__esModule\", { value: true });\nvar ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = ANCHOR_ERROR__REQUIRE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_VIOLATED = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = ANCHOR_ERROR__CONSTRAINT_SPACE = dist.ANCHOR_ERROR__CONSTRAINT_SPACE = ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = ANCHOR_ERROR__CONSTRAINT_ZERO = dist.ANCHOR_ERROR__CONSTRAINT_ZERO = ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_ADDRESS = ANCHOR_ERROR__CONSTRAINT_CLOSE = dist.ANCHOR_ERROR__CONSTRAINT_CLOSE = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = ANCHOR_ERROR__CONSTRAINT_STATE = dist.ANCHOR_ERROR__CONSTRAINT_STATE = ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = ANCHOR_ERROR__CONSTRAINT_SEEDS = dist.ANCHOR_ERROR__CONSTRAINT_SEEDS = ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = ANCHOR_ERROR__CONSTRAINT_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_OWNER = ANCHOR_ERROR__CONSTRAINT_RAW = dist.ANCHOR_ERROR__CONSTRAINT_RAW = ANCHOR_ERROR__CONSTRAINT_SIGNER = dist.ANCHOR_ERROR__CONSTRAINT_SIGNER = ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = ANCHOR_ERROR__CONSTRAINT_MUT = dist.ANCHOR_ERROR__CONSTRAINT_MUT = ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = ANCHOR_ERROR__INSTRUCTION_MISSING = dist.ANCHOR_ERROR__INSTRUCTION_MISSING = void 0;\nvar ANCHOR_ERROR__DEPRECATED = dist.ANCHOR_ERROR__DEPRECATED = ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = ANCHOR_ERROR__INVALID_PROGRAM_ID = dist.ANCHOR_ERROR__INVALID_PROGRAM_ID = ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = void 0;\n/** 8 byte instruction identifier not provided. */\nvar ANCHOR_ERROR__INSTRUCTION_MISSING = dist.ANCHOR_ERROR__INSTRUCTION_MISSING = 100;\n/** Fallback functions are not supported. */\nvar ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = dist.ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND = 101;\n/** The program could not deserialize the given instruction. */\nvar ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE = 102;\n/** The program could not serialize the given instruction. */\nvar ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE = 103;\n// IDL instruction errors.\n/** The program was compiled without idl instructions. */\nvar ANCHOR_ERROR__IDL_INSTRUCTION_STUB = dist.ANCHOR_ERROR__IDL_INSTRUCTION_STUB = 1000;\n/** The transaction was given an invalid program for the IDL instruction. */\nvar ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = dist.ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM = 1001;\n/** IDL account must be empty in order to resize, try closing first. */\nvar ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = dist.ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY = 1002;\n// Event instructions.\n/** The program was compiled without `event-cpi` feature. */\nvar ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = dist.ANCHOR_ERROR__EVENT_INSTRUCTION_STUB = 1500;\n// Constraint errors.\n/** A mut constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MUT = dist.ANCHOR_ERROR__CONSTRAINT_MUT = 2000;\n/** A has one constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_HAS_ONE = dist.ANCHOR_ERROR__CONSTRAINT_HAS_ONE = 2001;\n/** A signer constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_SIGNER = dist.ANCHOR_ERROR__CONSTRAINT_SIGNER = 2002;\n/** A raw constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_RAW = dist.ANCHOR_ERROR__CONSTRAINT_RAW = 2003;\n/** An owner constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_OWNER = 2004;\n/** A rent exemption constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = dist.ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT = 2005;\n/** A seeds constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_SEEDS = dist.ANCHOR_ERROR__CONSTRAINT_SEEDS = 2006;\n/** An executable constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = dist.ANCHOR_ERROR__CONSTRAINT_EXECUTABLE = 2007;\n/** Deprecated Error, feel free to replace with something else. */\nvar ANCHOR_ERROR__CONSTRAINT_STATE = dist.ANCHOR_ERROR__CONSTRAINT_STATE = 2008;\n/** An associated constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED = 2009;\n/** An associated init constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT = 2010;\n/** A close constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_CLOSE = dist.ANCHOR_ERROR__CONSTRAINT_CLOSE = 2011;\n/** An address constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_ADDRESS = 2012;\n/** Expected zero account discriminant. */\nvar ANCHOR_ERROR__CONSTRAINT_ZERO = dist.ANCHOR_ERROR__CONSTRAINT_ZERO = 2013;\n/** A token mint constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT = 2014;\n/** A token owner constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER = 2015;\n/** A mint mint authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY = 2016;\n/** A mint freeze authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY = 2017;\n/** A mint decimals constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS = 2018;\n/** A space constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_SPACE = dist.ANCHOR_ERROR__CONSTRAINT_SPACE = 2019;\n/** A required account for the constraint is None. */\nvar ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = dist.ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE = 2020;\n/** A token account token program constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM = 2021;\n/** A mint token program constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM = 2022;\n/** An associated token account token program constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = dist.ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM = 2023;\n/** A group pointer extension constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION = 2024;\n/** A group pointer extension authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY = 2025;\n/** A group pointer extension group address constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS = 2026;\n/** A group member pointer extension constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION = 2027;\n/** A group member pointer extension authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY = 2028;\n/** A group member pointer extension group address constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS = 2029;\n/** A metadata pointer extension constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION = 2030;\n/** A metadata pointer extension authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY = 2031;\n/** A metadata pointer extension metadata address constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = dist.ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS = 2032;\n/** A close authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION = 2033;\n/** A close authority extension authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY = 2034;\n/** A permanent delegate extension constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION = 2035;\n/** A permanent delegate extension delegate constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = dist.ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE = 2036;\n/** A transfer hook extension constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION = 2037;\n/** A transfer hook extension authority constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY = 2038;\n/** A transfer hook extension transfer hook program id constraint was violated. */\nvar ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = dist.ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID = 2039;\n// Require errors.\n/** A require expression was violated. */\nvar ANCHOR_ERROR__REQUIRE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_VIOLATED = 2500;\n/** A require_eq expression was violated. */\nANCHOR_ERROR__REQUIRE_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_EQ_VIOLATED = 2501;\n/** A require_keys_eq expression was violated. */\nvar ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED = 2502;\n/** A require_neq expression was violated. */\nvar ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED = 2503;\n/** A require_keys_neq expression was violated. */\nvar ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED = 2504;\n/** A require_gt expression was violated. */\nvar ANCHOR_ERROR__REQUIRE_GT_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GT_VIOLATED = 2505;\n/** A require_gte expression was violated. */\nvar ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = dist.ANCHOR_ERROR__REQUIRE_GTE_VIOLATED = 2506;\n// Account errors.\n/** The account discriminator was already set on this account. */\nvar ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET = 3000;\n/** No 8 byte discriminator was found on the account. */\nvar ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND = 3001;\n/** 8 byte discriminator did not match what was expected. */\nvar ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH = 3002;\n/** Failed to deserialize the account. */\nvar ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE = 3003;\n/** Failed to serialize the account. */\nvar ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = dist.ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE = 3004;\n/** Not enough account keys given to the instruction. */\nvar ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = dist.ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS = 3005;\n/** The given account is not mutable. */\nvar ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = dist.ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE = 3006;\n/** The given account is owned by a different program than expected. */\nvar ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = dist.ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM = 3007;\n/** Program ID was not as expected. */\nvar ANCHOR_ERROR__INVALID_PROGRAM_ID = dist.ANCHOR_ERROR__INVALID_PROGRAM_ID = 3008;\n/** Program account is not executable. */\nvar ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = dist.ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE = 3009;\n/** The given account did not sign. */\nvar ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = dist.ANCHOR_ERROR__ACCOUNT_NOT_SIGNER = 3010;\n/** The given account is not owned by the system program. */\nvar ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = dist.ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED = 3011;\n/** The program expected this account to be already initialized. */\nvar ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = dist.ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED = 3012;\n/** The given account is not a program data account. */\nvar ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = dist.ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA = 3013;\n/** The given account is not the associated token account. */\nvar ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = dist.ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT = 3014;\n/** The given public key does not match the required sysvar. */\nvar ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = dist.ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH = 3015;\n/** The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit. */\nvar ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = dist.ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT = 3016;\n/** The account was duplicated for more than one reallocation. */\nvar ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = dist.ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS = 3017;\n// Miscellaneous errors.\n/** The declared program id does not match the actual program id. */\nvar ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = dist.ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH = 4100;\n/** You cannot/should not initialize the payer account as a program account. */\nvar ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = dist.ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT = 4101;\n/** The program could not perform the numeric conversion, out of range integral type conversion attempted. */\nvar ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = dist.ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION = 4102;\n// Deprecated errors.\n/** The API being used is deprecated and should no longer be used. */\nANCHOR_ERROR__DEPRECATED = dist.ANCHOR_ERROR__DEPRECATED = 5000;\n\nconst _AVAILABLE_FEATURES = new Set([\"debug-logs\"]);\nconst _FEATURES = new Map();\nfunction set(key) {\n    if (!_AVAILABLE_FEATURES.has(key)) {\n        throw new Error(\"Invalid feature\");\n    }\n    _FEATURES.set(key, true);\n}\nfunction isSet(key) {\n    return _FEATURES.get(key) !== undefined;\n}\n\nvar features = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    set: set,\n    isSet: isSet\n});\n\nclass IdlError extends Error {\n    constructor(message) {\n        super(message);\n        this.name = \"IdlError\";\n    }\n}\nclass ProgramErrorStack {\n    constructor(stack) {\n        this.stack = stack;\n    }\n    static parse(logs) {\n        var _a;\n        const programKeyRegex = /^Program (\\w*) invoke/;\n        const successRegex = /^Program \\w* success/;\n        const programStack = [];\n        for (let i = 0; i < logs.length; i++) {\n            if (successRegex.exec(logs[i])) {\n                programStack.pop();\n                continue;\n            }\n            const programKey = (_a = programKeyRegex.exec(logs[i])) === null || _a === void 0 ? void 0 : _a[1];\n            if (!programKey) {\n                continue;\n            }\n            programStack.push(new PublicKey(programKey));\n        }\n        return new ProgramErrorStack(programStack);\n    }\n}\nclass AnchorError extends Error {\n    constructor(errorCode, errorMessage, errorLogs, logs, origin, comparedValues) {\n        super(errorLogs.join(\"\\n\").replace(\"Program log: \", \"\"));\n        this.errorLogs = errorLogs;\n        this.logs = logs;\n        this.error = { errorCode, errorMessage, comparedValues, origin };\n        this._programErrorStack = ProgramErrorStack.parse(logs);\n    }\n    static parse(logs) {\n        if (!logs) {\n            return null;\n        }\n        const anchorErrorLogIndex = logs.findIndex((log) => log.startsWith(\"Program log: AnchorError\"));\n        if (anchorErrorLogIndex === -1) {\n            return null;\n        }\n        const anchorErrorLog = logs[anchorErrorLogIndex];\n        const errorLogs = [anchorErrorLog];\n        let comparedValues;\n        if (anchorErrorLogIndex + 1 < logs.length) {\n            // This catches the comparedValues where the following is logged\n            // <AnchorError>\n            // Left:\n            // <Pubkey>\n            // Right:\n            // <Pubkey>\n            if (logs[anchorErrorLogIndex + 1] === \"Program log: Left:\") {\n                const pubkeyRegex = /^Program log: (.*)$/;\n                const leftPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 2])[1];\n                const rightPubkey = pubkeyRegex.exec(logs[anchorErrorLogIndex + 4])[1];\n                comparedValues = [\n                    new PublicKey(leftPubkey),\n                    new PublicKey(rightPubkey),\n                ];\n                errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 5));\n            }\n            // This catches the comparedValues where the following is logged\n            // <AnchorError>\n            // Left: <value>\n            // Right: <value>\n            else if (logs[anchorErrorLogIndex + 1].startsWith(\"Program log: Left:\")) {\n                const valueRegex = /^Program log: (Left|Right): (.*)$/;\n                const leftValue = valueRegex.exec(logs[anchorErrorLogIndex + 1])[2];\n                const rightValue = valueRegex.exec(logs[anchorErrorLogIndex + 2])[2];\n                errorLogs.push(...logs.slice(anchorErrorLogIndex + 1, anchorErrorLogIndex + 3));\n                comparedValues = [leftValue, rightValue];\n            }\n        }\n        const regexNoInfo = /^Program log: AnchorError occurred\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n        const noInfoAnchorErrorLog = regexNoInfo.exec(anchorErrorLog);\n        const regexFileLine = /^Program log: AnchorError thrown in (.*):(\\d*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n        const fileLineAnchorErrorLog = regexFileLine.exec(anchorErrorLog);\n        const regexAccountName = /^Program log: AnchorError caused by account: (.*)\\. Error Code: (.*)\\. Error Number: (\\d*)\\. Error Message: (.*)\\./;\n        const accountNameAnchorErrorLog = regexAccountName.exec(anchorErrorLog);\n        if (noInfoAnchorErrorLog) {\n            const [errorCodeString, errorNumber, errorMessage] = noInfoAnchorErrorLog.slice(1, 4);\n            const errorCode = {\n                code: errorCodeString,\n                number: parseInt(errorNumber),\n            };\n            return new AnchorError(errorCode, errorMessage, errorLogs, logs, undefined, comparedValues);\n        }\n        else if (fileLineAnchorErrorLog) {\n            const [file, line, errorCodeString, errorNumber, errorMessage] = fileLineAnchorErrorLog.slice(1, 6);\n            const errorCode = {\n                code: errorCodeString,\n                number: parseInt(errorNumber),\n            };\n            const fileLine = { file, line: parseInt(line) };\n            return new AnchorError(errorCode, errorMessage, errorLogs, logs, fileLine, comparedValues);\n        }\n        else if (accountNameAnchorErrorLog) {\n            const [accountName, errorCodeString, errorNumber, errorMessage] = accountNameAnchorErrorLog.slice(1, 5);\n            const origin = accountName;\n            const errorCode = {\n                code: errorCodeString,\n                number: parseInt(errorNumber),\n            };\n            return new AnchorError(errorCode, errorMessage, errorLogs, logs, origin, comparedValues);\n        }\n        else {\n            return null;\n        }\n    }\n    get program() {\n        return this._programErrorStack.stack[this._programErrorStack.stack.length - 1];\n    }\n    get programErrorStack() {\n        return this._programErrorStack.stack;\n    }\n    toString() {\n        return this.message;\n    }\n}\n// An error from a user defined program.\nclass ProgramError extends Error {\n    constructor(code, msg, logs) {\n        super();\n        this.code = code;\n        this.msg = msg;\n        this.logs = logs;\n        if (logs) {\n            this._programErrorStack = ProgramErrorStack.parse(logs);\n        }\n    }\n    static parse(err, idlErrors) {\n        const errString = err.toString();\n        // TODO: don't rely on the error string. web3.js should preserve the error\n        //       code information instead of giving us an untyped string.\n        let unparsedErrorCode;\n        if (errString.includes(\"custom program error:\")) {\n            let components = errString.split(\"custom program error: \");\n            if (components.length !== 2) {\n                return null;\n            }\n            else {\n                unparsedErrorCode = components[1];\n            }\n        }\n        else {\n            const matches = errString.match(/\"Custom\":([0-9]+)}/g);\n            if (!matches || matches.length > 1) {\n                return null;\n            }\n            unparsedErrorCode = matches[0].match(/([0-9]+)/g)[0];\n        }\n        let errorCode;\n        try {\n            errorCode = parseInt(unparsedErrorCode);\n        }\n        catch (parseErr) {\n            return null;\n        }\n        // Parse user error.\n        let errorMsg = idlErrors.get(errorCode);\n        if (errorMsg !== undefined) {\n            return new ProgramError(errorCode, errorMsg, err.logs);\n        }\n        // Parse framework internal error.\n        errorMsg = LangErrorMessage.get(errorCode);\n        if (errorMsg !== undefined) {\n            return new ProgramError(errorCode, errorMsg, err.logs);\n        }\n        // Unable to parse the error. Just return the untranslated error.\n        return null;\n    }\n    get program() {\n        var _a;\n        return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack[this._programErrorStack.stack.length - 1];\n    }\n    get programErrorStack() {\n        var _a;\n        return (_a = this._programErrorStack) === null || _a === void 0 ? void 0 : _a.stack;\n    }\n    toString() {\n        return this.msg;\n    }\n}\nfunction translateError(err, idlErrors) {\n    if (isSet(\"debug-logs\")) {\n        console.log(\"Translating error:\", err);\n    }\n    const anchorError = AnchorError.parse(err.logs);\n    if (anchorError) {\n        return anchorError;\n    }\n    const programError = ProgramError.parse(err, idlErrors);\n    if (programError) {\n        return programError;\n    }\n    if (err.logs) {\n        const handler = {\n            get: function (target, prop) {\n                if (prop === \"programErrorStack\") {\n                    return target.programErrorStack.stack;\n                }\n                else if (prop === \"program\") {\n                    return target.programErrorStack.stack[err.programErrorStack.stack.length - 1];\n                }\n                else {\n                    // this is the normal way to return all other props\n                    // without modifying them.\n                    // @ts-expect-error\n                    return Reflect.get(...arguments);\n                }\n            },\n        };\n        err.programErrorStack = ProgramErrorStack.parse(err.logs);\n        return new Proxy(err, handler);\n    }\n    return err;\n}\nconst LangErrorCode = {\n    // Instructions.\n    InstructionMissing: ANCHOR_ERROR__INSTRUCTION_MISSING,\n    InstructionFallbackNotFound: ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND,\n    InstructionDidNotDeserialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE,\n    InstructionDidNotSerialize: ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE,\n    // IDL instructions.\n    IdlInstructionStub: ANCHOR_ERROR__IDL_INSTRUCTION_STUB,\n    IdlInstructionInvalidProgram: ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM,\n    IdlAccountNotEmpty: ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY,\n    // Event instructions.\n    EventInstructionStub: ANCHOR_ERROR__EVENT_INSTRUCTION_STUB,\n    // Constraints.\n    ConstraintMut: ANCHOR_ERROR__CONSTRAINT_MUT,\n    ConstraintHasOne: ANCHOR_ERROR__CONSTRAINT_HAS_ONE,\n    ConstraintSigner: ANCHOR_ERROR__CONSTRAINT_SIGNER,\n    ConstraintRaw: ANCHOR_ERROR__CONSTRAINT_RAW,\n    ConstraintOwner: ANCHOR_ERROR__CONSTRAINT_OWNER,\n    ConstraintRentExempt: ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT,\n    ConstraintSeeds: ANCHOR_ERROR__CONSTRAINT_SEEDS,\n    ConstraintExecutable: ANCHOR_ERROR__CONSTRAINT_EXECUTABLE,\n    ConstraintState: ANCHOR_ERROR__CONSTRAINT_STATE,\n    ConstraintAssociated: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED,\n    ConstraintAssociatedInit: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT,\n    ConstraintClose: ANCHOR_ERROR__CONSTRAINT_CLOSE,\n    ConstraintAddress: ANCHOR_ERROR__CONSTRAINT_ADDRESS,\n    ConstraintZero: ANCHOR_ERROR__CONSTRAINT_ZERO,\n    ConstraintTokenMint: ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT,\n    ConstraintTokenOwner: ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER,\n    ConstraintMintMintAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY,\n    ConstraintMintFreezeAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY,\n    ConstraintMintDecimals: ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS,\n    ConstraintSpace: ANCHOR_ERROR__CONSTRAINT_SPACE,\n    ConstraintAccountIsNone: ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE,\n    ConstraintTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM,\n    ConstraintMintTokenProgram: ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM,\n    ConstraintAssociatedTokenTokenProgram: ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM,\n    ConstraintMintGroupPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION,\n    ConstraintMintGroupPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY,\n    ConstraintMintGroupPointerExtensionGroupAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS,\n    ConstraintMintGroupMemberPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION,\n    ConstraintMintGroupMemberPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY,\n    ConstraintMintGroupMemberPointerExtensionMemberAddress: ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS,\n    ConstraintMintMetadataPointerExtension: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION,\n    ConstraintMintMetadataPointerExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY,\n    ConstraintMintMetadataPointerExtensionMetadataAddress: ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS,\n    ConstraintMintCloseAuthorityExtension: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION,\n    ConstraintMintCloseAuthorityExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY,\n    ConstraintMintPermanentDelegateExtension: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION,\n    ConstraintMintPermanentDelegateExtensionDelegate: ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE,\n    ConstraintMintTransferHookExtension: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION,\n    ConstraintMintTransferHookExtensionAuthority: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY,\n    ConstraintMintTransferHookExtensionProgramId: ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID,\n    // Require.\n    RequireViolated: ANCHOR_ERROR__REQUIRE_VIOLATED,\n    RequireEqViolated: ANCHOR_ERROR__REQUIRE_EQ_VIOLATED,\n    RequireKeysEqViolated: ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED,\n    RequireNeqViolated: ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED,\n    RequireKeysNeqViolated: ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED,\n    RequireGtViolated: ANCHOR_ERROR__REQUIRE_GT_VIOLATED,\n    RequireGteViolated: ANCHOR_ERROR__REQUIRE_GTE_VIOLATED,\n    // Accounts.\n    AccountDiscriminatorAlreadySet: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET,\n    AccountDiscriminatorNotFound: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND,\n    AccountDiscriminatorMismatch: ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH,\n    AccountDidNotDeserialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE,\n    AccountDidNotSerialize: ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE,\n    AccountNotEnoughKeys: ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS,\n    AccountNotMutable: ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE,\n    AccountOwnedByWrongProgram: ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM,\n    InvalidProgramId: ANCHOR_ERROR__INVALID_PROGRAM_ID,\n    InvalidProgramExecutable: ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE,\n    AccountNotSigner: ANCHOR_ERROR__ACCOUNT_NOT_SIGNER,\n    AccountNotSystemOwned: ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED,\n    AccountNotInitialized: ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED,\n    AccountNotProgramData: ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA,\n    AccountNotAssociatedTokenAccount: ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT,\n    AccountSysvarMismatch: ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH,\n    AccountReallocExceedsLimit: ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT,\n    AccountDuplicateReallocs: ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS,\n    // Miscellaneous\n    DeclaredProgramIdMismatch: ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH,\n    TryingToInitPayerAsProgramAccount: ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT,\n    InvalidNumericConversion: ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION,\n    // Used for APIs that shouldn't be used anymore.\n    Deprecated: ANCHOR_ERROR__DEPRECATED,\n};\nconst LangErrorMessage = new Map([\n    // Instructions.\n    [LangErrorCode.InstructionMissing, \"Instruction discriminator not provided\"],\n    [\n        LangErrorCode.InstructionFallbackNotFound,\n        \"Fallback functions are not supported\",\n    ],\n    [\n        LangErrorCode.InstructionDidNotDeserialize,\n        \"The program could not deserialize the given instruction\",\n    ],\n    [\n        LangErrorCode.InstructionDidNotSerialize,\n        \"The program could not serialize the given instruction\",\n    ],\n    // Idl instructions.\n    [\n        LangErrorCode.IdlInstructionStub,\n        \"The program was compiled without idl instructions\",\n    ],\n    [\n        LangErrorCode.IdlInstructionInvalidProgram,\n        \"The transaction was given an invalid program for the IDL instruction\",\n    ],\n    [\n        LangErrorCode.IdlAccountNotEmpty,\n        \"IDL account must be empty in order to resize, try closing first\",\n    ],\n    // Event instructions.\n    [\n        LangErrorCode.EventInstructionStub,\n        \"The program was compiled without `event-cpi` feature\",\n    ],\n    // Constraints.\n    [LangErrorCode.ConstraintMut, \"A mut constraint was violated\"],\n    [LangErrorCode.ConstraintHasOne, \"A has one constraint was violated\"],\n    [LangErrorCode.ConstraintSigner, \"A signer constraint was violated\"],\n    [LangErrorCode.ConstraintRaw, \"A raw constraint was violated\"],\n    [LangErrorCode.ConstraintOwner, \"An owner constraint was violated\"],\n    [\n        LangErrorCode.ConstraintRentExempt,\n        \"A rent exemption constraint was violated\",\n    ],\n    [LangErrorCode.ConstraintSeeds, \"A seeds constraint was violated\"],\n    [LangErrorCode.ConstraintExecutable, \"An executable constraint was violated\"],\n    [\n        LangErrorCode.ConstraintState,\n        \"Deprecated Error, feel free to replace with something else\",\n    ],\n    [LangErrorCode.ConstraintAssociated, \"An associated constraint was violated\"],\n    [\n        LangErrorCode.ConstraintAssociatedInit,\n        \"An associated init constraint was violated\",\n    ],\n    [LangErrorCode.ConstraintClose, \"A close constraint was violated\"],\n    [LangErrorCode.ConstraintAddress, \"An address constraint was violated\"],\n    [LangErrorCode.ConstraintZero, \"Expected zero account discriminant\"],\n    [LangErrorCode.ConstraintTokenMint, \"A token mint constraint was violated\"],\n    [LangErrorCode.ConstraintTokenOwner, \"A token owner constraint was violated\"],\n    [\n        LangErrorCode.ConstraintMintMintAuthority,\n        \"A mint mint authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintFreezeAuthority,\n        \"A mint freeze authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintDecimals,\n        \"A mint decimals constraint was violated\",\n    ],\n    [LangErrorCode.ConstraintSpace, \"A space constraint was violated\"],\n    [\n        LangErrorCode.ConstraintAccountIsNone,\n        \"A required account for the constraint is None\",\n    ],\n    [\n        LangErrorCode.ConstraintTokenTokenProgram,\n        \"A token account token program constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintTokenProgram,\n        \"A mint token program constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintAssociatedTokenTokenProgram,\n        \"An associated token account token program constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupPointerExtension,\n        \"A group pointer extension constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupPointerExtensionAuthority,\n        \"A group pointer extension authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupPointerExtensionGroupAddress,\n        \"A group pointer extension group address constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupMemberPointerExtension,\n        \"A group member pointer extension constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupMemberPointerExtensionAuthority,\n        \"A group member pointer extension authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintGroupMemberPointerExtensionMemberAddress,\n        \"A group member pointer extension group address constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintMetadataPointerExtension,\n        \"A metadata pointer extension constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintMetadataPointerExtensionAuthority,\n        \"A metadata pointer extension authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintMetadataPointerExtensionMetadataAddress,\n        \"A metadata pointer extension metadata address constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintCloseAuthorityExtension,\n        \"A close authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintCloseAuthorityExtensionAuthority,\n        \"A close authority extension authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintPermanentDelegateExtension,\n        \"A permanent delegate extension constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintPermanentDelegateExtensionDelegate,\n        \"A permanent delegate extension delegate constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintTransferHookExtension,\n        \"A transfer hook extension constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintTransferHookExtensionAuthority,\n        \"A transfer hook extension authority constraint was violated\",\n    ],\n    [\n        LangErrorCode.ConstraintMintTransferHookExtensionProgramId,\n        \"A transfer hook extension transfer hook program id constraint was violated\",\n    ],\n    // Require.\n    [LangErrorCode.RequireViolated, \"A require expression was violated\"],\n    [LangErrorCode.RequireEqViolated, \"A require_eq expression was violated\"],\n    [\n        LangErrorCode.RequireKeysEqViolated,\n        \"A require_keys_eq expression was violated\",\n    ],\n    [LangErrorCode.RequireNeqViolated, \"A require_neq expression was violated\"],\n    [\n        LangErrorCode.RequireKeysNeqViolated,\n        \"A require_keys_neq expression was violated\",\n    ],\n    [LangErrorCode.RequireGtViolated, \"A require_gt expression was violated\"],\n    [LangErrorCode.RequireGteViolated, \"A require_gte expression was violated\"],\n    // Accounts.\n    [\n        LangErrorCode.AccountDiscriminatorAlreadySet,\n        \"The account discriminator was already set on this account\",\n    ],\n    [\n        LangErrorCode.AccountDiscriminatorNotFound,\n        \"No discriminator was found on the account\",\n    ],\n    [\n        LangErrorCode.AccountDiscriminatorMismatch,\n        \"Account discriminator did not match what was expected\",\n    ],\n    [LangErrorCode.AccountDidNotDeserialize, \"Failed to deserialize the account\"],\n    [LangErrorCode.AccountDidNotSerialize, \"Failed to serialize the account\"],\n    [\n        LangErrorCode.AccountNotEnoughKeys,\n        \"Not enough account keys given to the instruction\",\n    ],\n    [LangErrorCode.AccountNotMutable, \"The given account is not mutable\"],\n    [\n        LangErrorCode.AccountOwnedByWrongProgram,\n        \"The given account is owned by a different program than expected\",\n    ],\n    [LangErrorCode.InvalidProgramId, \"Program ID was not as expected\"],\n    [LangErrorCode.InvalidProgramExecutable, \"Program account is not executable\"],\n    [LangErrorCode.AccountNotSigner, \"The given account did not sign\"],\n    [\n        LangErrorCode.AccountNotSystemOwned,\n        \"The given account is not owned by the system program\",\n    ],\n    [\n        LangErrorCode.AccountNotInitialized,\n        \"The program expected this account to be already initialized\",\n    ],\n    [\n        LangErrorCode.AccountNotProgramData,\n        \"The given account is not a program data account\",\n    ],\n    [\n        LangErrorCode.AccountNotAssociatedTokenAccount,\n        \"The given account is not the associated token account\",\n    ],\n    [\n        LangErrorCode.AccountSysvarMismatch,\n        \"The given public key does not match the required sysvar\",\n    ],\n    [\n        LangErrorCode.AccountReallocExceedsLimit,\n        \"The account reallocation exceeds the MAX_PERMITTED_DATA_INCREASE limit\",\n    ],\n    [\n        LangErrorCode.AccountDuplicateReallocs,\n        \"The account was duplicated for more than one reallocation\",\n    ],\n    // Miscellaneous\n    [\n        LangErrorCode.DeclaredProgramIdMismatch,\n        \"The declared program id does not match the actual program id\",\n    ],\n    [\n        LangErrorCode.TryingToInitPayerAsProgramAccount,\n        \"You cannot/should not initialize the payer account as a program account\",\n    ],\n    [\n        LangErrorCode.InvalidNumericConversion,\n        \"The program could not perform the numeric conversion, out of range integral type conversion attempted\",\n    ],\n    // Deprecated\n    [\n        LangErrorCode.Deprecated,\n        \"The API being used is deprecated and should no longer be used\",\n    ],\n]);\n\nclass IdlCoder {\n    static fieldLayout(field, types = [], genericArgs) {\n        const fieldName = field.name;\n        switch (field.type) {\n            case \"bool\": {\n                return borsh.bool(fieldName);\n            }\n            case \"u8\": {\n                return borsh.u8(fieldName);\n            }\n            case \"i8\": {\n                return borsh.i8(fieldName);\n            }\n            case \"u16\": {\n                return borsh.u16(fieldName);\n            }\n            case \"i16\": {\n                return borsh.i16(fieldName);\n            }\n            case \"u32\": {\n                return borsh.u32(fieldName);\n            }\n            case \"i32\": {\n                return borsh.i32(fieldName);\n            }\n            case \"f32\": {\n                return borsh.f32(fieldName);\n            }\n            case \"u64\": {\n                return borsh.u64(fieldName);\n            }\n            case \"i64\": {\n                return borsh.i64(fieldName);\n            }\n            case \"f64\": {\n                return borsh.f64(fieldName);\n            }\n            case \"u128\": {\n                return borsh.u128(fieldName);\n            }\n            case \"i128\": {\n                return borsh.i128(fieldName);\n            }\n            case \"u256\": {\n                return borsh.u256(fieldName);\n            }\n            case \"i256\": {\n                return borsh.i256(fieldName);\n            }\n            case \"bytes\": {\n                return borsh.vecU8(fieldName);\n            }\n            case \"string\": {\n                return borsh.str(fieldName);\n            }\n            case \"pubkey\": {\n                return borsh.publicKey(fieldName);\n            }\n            default: {\n                if (\"option\" in field.type) {\n                    return borsh.option(IdlCoder.fieldLayout({ type: field.type.option }, types, genericArgs), fieldName);\n                }\n                if (\"vec\" in field.type) {\n                    return borsh.vec(IdlCoder.fieldLayout({ type: field.type.vec }, types, genericArgs), fieldName);\n                }\n                if (\"array\" in field.type) {\n                    let [type, len] = field.type.array;\n                    len = IdlCoder.resolveArrayLen(len, genericArgs);\n                    return borsh.array(IdlCoder.fieldLayout({ type }, types, genericArgs), len, fieldName);\n                }\n                if (\"defined\" in field.type) {\n                    if (!types) {\n                        throw new IdlError(\"User defined types not provided\");\n                    }\n                    const definedName = field.type.defined.name;\n                    const typeDef = types.find((t) => t.name === definedName);\n                    if (!typeDef) {\n                        throw new IdlError(`Type not found: ${field.name}`);\n                    }\n                    return IdlCoder.typeDefLayout({\n                        typeDef,\n                        types,\n                        genericArgs: genericArgs !== null && genericArgs !== void 0 ? genericArgs : field.type.defined.generics,\n                        name: fieldName,\n                    });\n                }\n                if (\"generic\" in field.type) {\n                    const genericArg = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs.at(0);\n                    if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) !== \"type\") {\n                        throw new IdlError(`Invalid generic field: ${field.name}`);\n                    }\n                    return IdlCoder.fieldLayout({ ...field, type: genericArg.type }, types);\n                }\n                throw new IdlError(`Not yet implemented: ${JSON.stringify(field.type)}`);\n            }\n        }\n    }\n    /**\n     * Get the type layout of the given defined type(struct or enum).\n     */\n    static typeDefLayout({ typeDef, types, name, genericArgs, }) {\n        switch (typeDef.type.kind) {\n            case \"struct\": {\n                const fieldLayouts = handleDefinedFields(typeDef.type.fields, () => [], (fields) => fields.map((f) => {\n                    const genArgs = genericArgs\n                        ? IdlCoder.resolveGenericArgs({\n                            type: f.type,\n                            typeDef,\n                            genericArgs,\n                        })\n                        : genericArgs;\n                    return IdlCoder.fieldLayout(f, types, genArgs);\n                }), (fields) => fields.map((f, i) => {\n                    const genArgs = genericArgs\n                        ? IdlCoder.resolveGenericArgs({\n                            type: f,\n                            typeDef,\n                            genericArgs,\n                        })\n                        : genericArgs;\n                    return IdlCoder.fieldLayout({ name: i.toString(), type: f }, types, genArgs);\n                }));\n                return borsh.struct(fieldLayouts, name);\n            }\n            case \"enum\": {\n                const variants = typeDef.type.variants.map((variant) => {\n                    const fieldLayouts = handleDefinedFields(variant.fields, () => [], (fields) => fields.map((f) => {\n                        const genArgs = genericArgs\n                            ? IdlCoder.resolveGenericArgs({\n                                type: f.type,\n                                typeDef,\n                                genericArgs,\n                            })\n                            : genericArgs;\n                        return IdlCoder.fieldLayout(f, types, genArgs);\n                    }), (fields) => fields.map((f, i) => {\n                        const genArgs = genericArgs\n                            ? IdlCoder.resolveGenericArgs({\n                                type: f,\n                                typeDef,\n                                genericArgs,\n                            })\n                            : genericArgs;\n                        return IdlCoder.fieldLayout({ name: i.toString(), type: f }, types, genArgs);\n                    }));\n                    return borsh.struct(fieldLayouts, variant.name);\n                });\n                if (name !== undefined) {\n                    // Buffer-layout lib requires the name to be null (on construction)\n                    // when used as a field.\n                    return borsh.rustEnum(variants).replicate(name);\n                }\n                return borsh.rustEnum(variants, name);\n            }\n            case \"type\": {\n                return IdlCoder.fieldLayout({ type: typeDef.type.alias, name }, types);\n            }\n        }\n    }\n    /**\n     * Get the type of the size in bytes. Returns `1` for variable length types.\n     */\n    static typeSize(ty, idl, genericArgs) {\n        var _a;\n        switch (ty) {\n            case \"bool\":\n                return 1;\n            case \"u8\":\n                return 1;\n            case \"i8\":\n                return 1;\n            case \"i16\":\n                return 2;\n            case \"u16\":\n                return 2;\n            case \"u32\":\n                return 4;\n            case \"i32\":\n                return 4;\n            case \"f32\":\n                return 4;\n            case \"u64\":\n                return 8;\n            case \"i64\":\n                return 8;\n            case \"f64\":\n                return 8;\n            case \"u128\":\n                return 16;\n            case \"i128\":\n                return 16;\n            case \"u256\":\n                return 32;\n            case \"i256\":\n                return 32;\n            case \"bytes\":\n                return 1;\n            case \"string\":\n                return 1;\n            case \"pubkey\":\n                return 32;\n            default:\n                if (\"option\" in ty) {\n                    return 1 + IdlCoder.typeSize(ty.option, idl, genericArgs);\n                }\n                if (\"coption\" in ty) {\n                    return 4 + IdlCoder.typeSize(ty.coption, idl, genericArgs);\n                }\n                if (\"vec\" in ty) {\n                    return 1;\n                }\n                if (\"array\" in ty) {\n                    let [type, len] = ty.array;\n                    len = IdlCoder.resolveArrayLen(len, genericArgs);\n                    return IdlCoder.typeSize(type, idl, genericArgs) * len;\n                }\n                if (\"defined\" in ty) {\n                    const typeDef = (_a = idl.types) === null || _a === void 0 ? void 0 : _a.find((t) => t.name === ty.defined.name);\n                    if (!typeDef) {\n                        throw new IdlError(`Type not found: ${JSON.stringify(ty)}`);\n                    }\n                    const typeSize = (type) => {\n                        const genArgs = genericArgs !== null && genericArgs !== void 0 ? genericArgs : ty.defined.generics;\n                        const args = genArgs\n                            ? IdlCoder.resolveGenericArgs({\n                                type,\n                                typeDef,\n                                genericArgs: genArgs,\n                            })\n                            : genArgs;\n                        return IdlCoder.typeSize(type, idl, args);\n                    };\n                    switch (typeDef.type.kind) {\n                        case \"struct\": {\n                            return handleDefinedFields(typeDef.type.fields, () => [0], (fields) => fields.map((f) => typeSize(f.type)), (fields) => fields.map((f) => typeSize(f))).reduce((acc, size) => acc + size, 0);\n                        }\n                        case \"enum\": {\n                            const variantSizes = typeDef.type.variants.map((variant) => {\n                                return handleDefinedFields(variant.fields, () => [0], (fields) => fields.map((f) => typeSize(f.type)), (fields) => fields.map((f) => typeSize(f))).reduce((acc, size) => acc + size, 0);\n                            });\n                            return Math.max(...variantSizes) + 1;\n                        }\n                        case \"type\": {\n                            return IdlCoder.typeSize(typeDef.type.alias, idl, genericArgs);\n                        }\n                    }\n                }\n                if (\"generic\" in ty) {\n                    const genericArg = genericArgs === null || genericArgs === void 0 ? void 0 : genericArgs.at(0);\n                    if ((genericArg === null || genericArg === void 0 ? void 0 : genericArg.kind) !== \"type\") {\n                        throw new IdlError(`Invalid generic: ${ty.generic}`);\n                    }\n                    return IdlCoder.typeSize(genericArg.type, idl, genericArgs);\n                }\n                throw new Error(`Invalid type ${JSON.stringify(ty)}`);\n        }\n    }\n    /**\n     * Resolve the generic array length or return the constant-sized array length.\n     */\n    static resolveArrayLen(len, genericArgs) {\n        if (typeof len === \"number\")\n            return len;\n        if (genericArgs) {\n            const genericLen = genericArgs.find((g) => g.kind === \"const\");\n            if ((genericLen === null || genericLen === void 0 ? void 0 : genericLen.kind) === \"const\") {\n                len = +genericLen.value;\n            }\n        }\n        if (typeof len !== \"number\") {\n            throw new IdlError(\"Generic array length did not resolve\");\n        }\n        return len;\n    }\n    /**\n     * Recursively resolve generic arguments i.e. replace all generics with the\n     * actual type that they hold based on the initial `genericArgs` given.\n     */\n    static resolveGenericArgs({ type, typeDef, genericArgs, isDefined, }) {\n        if (typeof type !== \"object\")\n            return null;\n        for (const index in typeDef.generics) {\n            const defGeneric = typeDef.generics[index];\n            if (\"generic\" in type && defGeneric.name === type.generic) {\n                return [genericArgs[index]];\n            }\n            if (\"option\" in type) {\n                const args = IdlCoder.resolveGenericArgs({\n                    type: type.option,\n                    typeDef,\n                    genericArgs,\n                    isDefined,\n                });\n                if (!args || !isDefined)\n                    return args;\n                if (args[0].kind === \"type\") {\n                    return [\n                        {\n                            kind: \"type\",\n                            type: { option: args[0].type },\n                        },\n                    ];\n                }\n            }\n            if (\"vec\" in type) {\n                const args = IdlCoder.resolveGenericArgs({\n                    type: type.vec,\n                    typeDef,\n                    genericArgs,\n                    isDefined,\n                });\n                if (!args || !isDefined)\n                    return args;\n                if (args[0].kind === \"type\") {\n                    return [\n                        {\n                            kind: \"type\",\n                            type: { vec: args[0].type },\n                        },\n                    ];\n                }\n            }\n            if (\"array\" in type) {\n                const [elTy, len] = type.array;\n                const isGenericLen = typeof len === \"object\";\n                const args = IdlCoder.resolveGenericArgs({\n                    type: elTy,\n                    typeDef,\n                    genericArgs,\n                    isDefined,\n                });\n                if (args) {\n                    // Has generic type, also check for generic length\n                    for (const i in typeDef.generics.slice(+index)) {\n                        const curIndex = +index + +i;\n                        if (isGenericLen &&\n                            typeDef.generics[curIndex].name === len.generic) {\n                            args.push(genericArgs[curIndex]);\n                        }\n                    }\n                    if (!isDefined)\n                        return args;\n                    if (args[0].kind === \"type\" && args[1].kind === \"const\") {\n                        return [\n                            {\n                                kind: \"type\",\n                                type: { array: [args[0].type, +args[1].value] },\n                            },\n                        ];\n                    }\n                }\n                // Only generic len\n                if (isGenericLen && defGeneric.name === len.generic) {\n                    const arg = genericArgs[index];\n                    if (!isDefined)\n                        return [arg];\n                    return [\n                        {\n                            kind: \"type\",\n                            type: { array: [elTy, +arg.value] },\n                        },\n                    ];\n                }\n                // Non-generic\n                return null;\n            }\n            if (\"defined\" in type) {\n                if (!type.defined.generics)\n                    return null;\n                return type.defined.generics\n                    .flatMap((g) => {\n                    switch (g.kind) {\n                        case \"type\":\n                            return IdlCoder.resolveGenericArgs({\n                                type: g.type,\n                                typeDef,\n                                genericArgs,\n                                isDefined: true,\n                            });\n                        case \"const\":\n                            return [g];\n                    }\n                })\n                    .filter((g) => g !== null);\n            }\n        }\n        return null;\n    }\n}\n\n/**\n * Encodes and decodes program instructions.\n */\nclass BorshInstructionCoder {\n    constructor(idl) {\n        this.idl = idl;\n        const ixLayouts = idl.instructions.map((ix) => {\n            const name = ix.name;\n            const fieldLayouts = ix.args.map((arg) => IdlCoder.fieldLayout(arg, idl.types));\n            const layout = borsh.struct(fieldLayouts, name);\n            return [name, { discriminator: ix.discriminator, layout }];\n        });\n        this.ixLayouts = new Map(ixLayouts);\n    }\n    /**\n     * Encodes a program instruction.\n     */\n    encode(ixName, ix) {\n        const buffer = Buffer$1.alloc(1000); // TODO: use a tighter buffer.\n        const encoder = this.ixLayouts.get(ixName);\n        if (!encoder) {\n            throw new Error(`Unknown method: ${ixName}`);\n        }\n        const len = encoder.layout.encode(ix, buffer);\n        const data = buffer.slice(0, len);\n        return Buffer$1.concat([Buffer$1.from(encoder.discriminator), data]);\n    }\n    /**\n     * Decodes a program instruction.\n     */\n    decode(ix, encoding = \"hex\") {\n        if (typeof ix === \"string\") {\n            ix = encoding === \"hex\" ? Buffer$1.from(ix, \"hex\") : bs58$1.decode(ix);\n        }\n        for (const [name, layout] of this.ixLayouts) {\n            const givenDisc = ix.subarray(0, layout.discriminator.length);\n            const matches = givenDisc.equals(Buffer$1.from(layout.discriminator));\n            if (matches) {\n                return {\n                    name,\n                    data: layout.layout.decode(ix.subarray(givenDisc.length)),\n                };\n            }\n        }\n        return null;\n    }\n    /**\n     * Returns a formatted table of all the fields in the given instruction data.\n     */\n    format(ix, accountMetas) {\n        return InstructionFormatter.format(ix, accountMetas, this.idl);\n    }\n}\nclass InstructionFormatter {\n    static format(ix, accountMetas, idl) {\n        const idlIx = idl.instructions.find((i) => ix.name === i.name);\n        if (!idlIx) {\n            console.error(\"Invalid instruction given\");\n            return null;\n        }\n        const args = idlIx.args.map((idlField) => {\n            return {\n                name: idlField.name,\n                type: InstructionFormatter.formatIdlType(idlField.type),\n                data: InstructionFormatter.formatIdlData(idlField, ix.data[idlField.name], idl.types),\n            };\n        });\n        const flatIdlAccounts = InstructionFormatter.flattenIdlAccounts(idlIx.accounts);\n        const accounts = accountMetas.map((meta, idx) => {\n            if (idx < flatIdlAccounts.length) {\n                return {\n                    name: flatIdlAccounts[idx].name,\n                    ...meta,\n                };\n            }\n            // \"Remaining accounts\" are unnamed in Anchor.\n            else {\n                return {\n                    name: undefined,\n                    ...meta,\n                };\n            }\n        });\n        return {\n            args,\n            accounts,\n        };\n    }\n    static formatIdlType(idlType) {\n        if (typeof idlType === \"string\") {\n            return idlType;\n        }\n        if (\"option\" in idlType) {\n            return `Option<${this.formatIdlType(idlType.option)}>`;\n        }\n        if (\"coption\" in idlType) {\n            return `COption<${this.formatIdlType(idlType.coption)}>`;\n        }\n        if (\"vec\" in idlType) {\n            return `Vec<${this.formatIdlType(idlType.vec)}>`;\n        }\n        if (\"array\" in idlType) {\n            return `Array<${idlType.array[0]}; ${idlType.array[1]}>`;\n        }\n        if (\"defined\" in idlType) {\n            const name = idlType.defined.name;\n            if (idlType.defined.generics) {\n                const generics = idlType.defined.generics\n                    .map((g) => {\n                    switch (g.kind) {\n                        case \"type\":\n                            return InstructionFormatter.formatIdlType(g.type);\n                        case \"const\":\n                            return g.value;\n                    }\n                })\n                    .join(\", \");\n                return `${name}<${generics}>`;\n            }\n            return name;\n        }\n        throw new Error(`Unknown IDL type: ${idlType}`);\n    }\n    static formatIdlData(idlField, data, types) {\n        if (typeof idlField.type === \"string\") {\n            return data.toString();\n        }\n        if (\"vec\" in idlField.type) {\n            return (\"[\" +\n                data\n                    .map((d) => this.formatIdlData({ name: \"\", type: idlField.type.vec }, d, types))\n                    .join(\", \") +\n                \"]\");\n        }\n        if (\"option\" in idlField.type) {\n            return data === null\n                ? \"null\"\n                : this.formatIdlData({ name: \"\", type: idlField.type.option }, data, types);\n        }\n        if (\"defined\" in idlField.type) {\n            if (!types) {\n                throw new Error(\"User defined types not provided\");\n            }\n            const definedName = idlField.type.defined.name;\n            const typeDef = types.find((t) => t.name === definedName);\n            if (!typeDef) {\n                throw new Error(`Type not found: ${definedName}`);\n            }\n            return InstructionFormatter.formatIdlDataDefined(typeDef, data, types);\n        }\n        return \"unknown\";\n    }\n    static formatIdlDataDefined(typeDef, data, types) {\n        switch (typeDef.type.kind) {\n            case \"struct\": {\n                return (\"{ \" +\n                    handleDefinedFields(typeDef.type.fields, () => \"\", (fields) => {\n                        return Object.entries(data)\n                            .map(([key, val]) => {\n                            const field = fields.find((f) => f.name === key);\n                            if (!field) {\n                                throw new Error(`Field not found: ${key}`);\n                            }\n                            return (key +\n                                \": \" +\n                                InstructionFormatter.formatIdlData(field, val, types));\n                        })\n                            .join(\", \");\n                    }, (fields) => {\n                        return Object.entries(data)\n                            .map(([key, val]) => {\n                            return (key +\n                                \": \" +\n                                InstructionFormatter.formatIdlData({ name: \"\", type: fields[key] }, val, types));\n                        })\n                            .join(\", \");\n                    }) +\n                    \" }\");\n            }\n            case \"enum\": {\n                const variantName = Object.keys(data)[0];\n                const variant = typeDef.type.variants.find((v) => v.name === variantName);\n                if (!variant) {\n                    throw new Error(`Unable to find variant: ${variantName}`);\n                }\n                const enumValue = data[variantName];\n                return handleDefinedFields(variant.fields, () => variantName, (fields) => {\n                    const namedFields = Object.keys(enumValue)\n                        .map((f) => {\n                        const fieldData = enumValue[f];\n                        const idlField = fields.find((v) => v.name === f);\n                        if (!idlField) {\n                            throw new Error(`Field not found: ${f}`);\n                        }\n                        return (f +\n                            \": \" +\n                            InstructionFormatter.formatIdlData(idlField, fieldData, types));\n                    })\n                        .join(\", \");\n                    return `${variantName} { ${namedFields} }`;\n                }, (fields) => {\n                    const tupleFields = Object.entries(enumValue)\n                        .map(([key, val]) => {\n                        return (key +\n                            \": \" +\n                            InstructionFormatter.formatIdlData({ name: \"\", type: fields[key] }, val, types));\n                    })\n                        .join(\", \");\n                    return `${variantName} { ${tupleFields} }`;\n                });\n            }\n            case \"type\": {\n                return InstructionFormatter.formatIdlType(typeDef.type.alias);\n            }\n        }\n    }\n    static flattenIdlAccounts(accounts, prefix) {\n        return accounts\n            .map((account) => {\n            const accName = sentenceCase(account.name);\n            if (account.hasOwnProperty(\"accounts\")) {\n                const newPrefix = prefix ? `${prefix} > ${accName}` : accName;\n                return InstructionFormatter.flattenIdlAccounts(account.accounts, newPrefix);\n            }\n            else {\n                return {\n                    ...account,\n                    name: prefix ? `${prefix} > ${accName}` : accName,\n                };\n            }\n        })\n            .flat();\n    }\n}\nfunction sentenceCase(field) {\n    const result = field.replace(/([A-Z])/g, \" $1\");\n    return result.charAt(0).toUpperCase() + result.slice(1);\n}\n\n/**\n * Encodes and decodes account objects.\n */\nclass BorshAccountsCoder {\n    constructor(idl) {\n        this.idl = idl;\n        if (!idl.accounts) {\n            this.accountLayouts = new Map();\n            return;\n        }\n        const types = idl.types;\n        if (!types) {\n            throw new Error(\"Accounts require `idl.types`\");\n        }\n        const layouts = idl.accounts.map((acc) => {\n            const typeDef = types.find((ty) => ty.name === acc.name);\n            if (!typeDef) {\n                throw new Error(`Account not found: ${acc.name}`);\n            }\n            return [\n                acc.name,\n                {\n                    discriminator: acc.discriminator,\n                    layout: IdlCoder.typeDefLayout({ typeDef, types }),\n                },\n            ];\n        });\n        this.accountLayouts = new Map(layouts);\n    }\n    async encode(accountName, account) {\n        const buffer = Buffer$1.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.accountLayouts.get(accountName);\n        if (!layout) {\n            throw new Error(`Unknown account: ${accountName}`);\n        }\n        const len = layout.layout.encode(account, buffer);\n        const accountData = buffer.slice(0, len);\n        const discriminator = this.accountDiscriminator(accountName);\n        return Buffer$1.concat([discriminator, accountData]);\n    }\n    decode(accountName, data) {\n        // Assert the account discriminator is correct.\n        const discriminator = this.accountDiscriminator(accountName);\n        if (discriminator.compare(data.slice(0, discriminator.length))) {\n            throw new Error(\"Invalid account discriminator\");\n        }\n        return this.decodeUnchecked(accountName, data);\n    }\n    decodeAny(data) {\n        for (const [name, layout] of this.accountLayouts) {\n            const givenDisc = data.subarray(0, layout.discriminator.length);\n            const matches = givenDisc.equals(Buffer$1.from(layout.discriminator));\n            if (matches)\n                return this.decodeUnchecked(name, data);\n        }\n        throw new Error(\"Account not found\");\n    }\n    decodeUnchecked(accountName, acc) {\n        // Chop off the discriminator before decoding.\n        const discriminator = this.accountDiscriminator(accountName);\n        const data = acc.subarray(discriminator.length);\n        const layout = this.accountLayouts.get(accountName);\n        if (!layout) {\n            throw new Error(`Unknown account: ${accountName}`);\n        }\n        return layout.layout.decode(data);\n    }\n    memcmp(accountName, appendData) {\n        const discriminator = this.accountDiscriminator(accountName);\n        return {\n            offset: 0,\n            bytes: bs58$1.encode(appendData ? Buffer$1.concat([discriminator, appendData]) : discriminator),\n        };\n    }\n    size(accountName) {\n        return (this.accountDiscriminator(accountName).length +\n            IdlCoder.typeSize({ defined: { name: accountName } }, this.idl));\n    }\n    /**\n     * Get the unique discriminator prepended to all anchor accounts.\n     *\n     * @param name The name of the account to get the discriminator of.\n     */\n    accountDiscriminator(name) {\n        var _a;\n        const account = (_a = this.idl.accounts) === null || _a === void 0 ? void 0 : _a.find((acc) => acc.name === name);\n        if (!account) {\n            throw new Error(`Account not found: ${name}`);\n        }\n        return Buffer$1.from(account.discriminator);\n    }\n}\n\nclass BorshEventCoder {\n    constructor(idl) {\n        if (!idl.events) {\n            this.layouts = new Map();\n            return;\n        }\n        const types = idl.types;\n        if (!types) {\n            throw new Error(\"Events require `idl.types`\");\n        }\n        const layouts = idl.events.map((ev) => {\n            const typeDef = types.find((ty) => ty.name === ev.name);\n            if (!typeDef) {\n                throw new Error(`Event not found: ${ev.name}`);\n            }\n            return [\n                ev.name,\n                {\n                    discriminator: ev.discriminator,\n                    layout: IdlCoder.typeDefLayout({ typeDef, types }),\n                },\n            ];\n        });\n        this.layouts = new Map(layouts);\n    }\n    decode(log) {\n        let logArr;\n        // This will throw if log length is not a multiple of 4.\n        try {\n            logArr = decode(log);\n        }\n        catch (e) {\n            return null;\n        }\n        for (const [name, layout] of this.layouts) {\n            const givenDisc = logArr.subarray(0, layout.discriminator.length);\n            const matches = givenDisc.equals(Buffer$1.from(layout.discriminator));\n            if (matches) {\n                return {\n                    name,\n                    data: layout.layout.decode(logArr.subarray(givenDisc.length)),\n                };\n            }\n        }\n        return null;\n    }\n}\n\n/**\n * Encodes and decodes user-defined types.\n */\nclass BorshTypesCoder {\n    constructor(idl) {\n        const types = idl.types;\n        if (!types) {\n            this.typeLayouts = new Map();\n            return;\n        }\n        const layouts = types\n            .filter((ty) => !ty.generics)\n            .map((ty) => [\n            ty.name,\n            IdlCoder.typeDefLayout({ typeDef: ty, types }),\n        ]);\n        this.typeLayouts = new Map(layouts);\n    }\n    encode(name, type) {\n        const buffer = Buffer$1.alloc(1000); // TODO: use a tighter buffer.\n        const layout = this.typeLayouts.get(name);\n        if (!layout) {\n            throw new Error(`Unknown type: ${name}`);\n        }\n        const len = layout.encode(type, buffer);\n        return buffer.slice(0, len);\n    }\n    decode(name, data) {\n        const layout = this.typeLayouts.get(name);\n        if (!layout) {\n            throw new Error(`Unknown type: ${name}`);\n        }\n        return layout.decode(data);\n    }\n}\n\n/**\n * BorshCoder is the default Coder for Anchor programs implementing the\n * borsh based serialization interface.\n */\nclass BorshCoder {\n    constructor(idl) {\n        this.instruction = new BorshInstructionCoder(idl);\n        this.accounts = new BorshAccountsCoder(idl);\n        this.events = new BorshEventCoder(idl);\n        this.types = new BorshTypesCoder(idl);\n    }\n}\n\n/* The MIT License (MIT)\n *\n * Copyright 2015-2018 Peter A. Bigot\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/**\n * Base class for layout objects.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * Layout#encode|encode} or {@link Layout#decode|decode} functions.\n *\n * @param {Number} span - Initializer for {@link Layout#span|span}.  The\n * parameter must be an integer; a negative value signifies that the\n * span is {@link Layout#getSpan|value-specific}.\n *\n * @param {string} [property] - Initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n */\nclass Layout {\n  constructor(span, property) {\n    if (!Number.isInteger(span)) {\n      throw new TypeError('span must be an integer');\n    }\n\n    /** The span of the layout in bytes.\n     *\n     * Positive values are generally expected.\n     *\n     * Zero will only appear in {@link Constant}s and in {@link\n     * Sequence}s where the {@link Sequence#count|count} is zero.\n     *\n     * A negative value indicates that the span is value-specific, and\n     * must be obtained using {@link Layout#getSpan|getSpan}. */\n    this.span = span;\n\n    /** The property name used when this layout is represented in an\n     * Object.\n     *\n     * Used only for layouts that {@link Layout#decode|decode} to Object\n     * instances.  If left undefined the span of the unnamed layout will\n     * be treated as padding: it will not be mutated by {@link\n     * Layout#encode|encode} nor represented as a property in the\n     * decoded Object. */\n    this.property = property;\n  }\n\n  /** Function to create an Object into which decoded properties will\n   * be written.\n   *\n   * Used only for layouts that {@link Layout#decode|decode} to Object\n   * instances, which means:\n   * * {@link Structure}\n   * * {@link Union}\n   * * {@link VariantLayout}\n   * * {@link BitStructure}\n   *\n   * If left undefined the JavaScript representation of these layouts\n   * will be Object instances.\n   *\n   * See {@link bindConstructorLayout}.\n   */\n  makeDestinationObject() {\n    return {};\n  }\n\n  /**\n   * Decode from a Buffer into an JavaScript value.\n   *\n   * @param {Buffer} b - the buffer from which encoded data is read.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {(Number|Array|Object)} - the value of the decoded data.\n   *\n   * @abstract\n   */\n  decode(b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Encode a JavaScript value into a Buffer.\n   *\n   * @param {(Number|Array|Object)} src - the value to be encoded into\n   * the buffer.  The type accepted depends on the (sub-)type of {@link\n   * Layout}.\n   *\n   * @param {Buffer} b - the buffer into which encoded data will be\n   * written.\n   *\n   * @param {Number} [offset] - the offset at which the encoded data\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @returns {Number} - the number of bytes encoded, including the\n   * space skipped for internal padding, but excluding data such as\n   * {@link Sequence#count|lengths} when stored {@link\n   * ExternalLayout|externally}.  This is the adjustment to `offset`\n   * producing the offset where data for the next layout would be\n   * written.\n   *\n   * @abstract\n   */\n  encode(src, b, offset) {\n    throw new Error('Layout is abstract');\n  }\n\n  /**\n   * Calculate the span of a specific instance of a layout.\n   *\n   * @param {Buffer} b - the buffer that contains an encoded instance.\n   *\n   * @param {Number} [offset] - the offset at which the encoded instance\n   * starts.  If absent a zero offset is inferred.\n   *\n   * @return {Number} - the number of bytes covered by the layout\n   * instance.  If this method is not overridden in a subclass the\n   * definition-time constant {@link Layout#span|span} will be\n   * returned.\n   *\n   * @throws {RangeError} - if the length of the value cannot be\n   * determined.\n   */\n  getSpan(b, offset) {\n    if (0 > this.span) {\n      throw new RangeError('indeterminate span');\n    }\n    return this.span;\n  }\n\n  /**\n   * Replicate the layout using a new property.\n   *\n   * This function must be used to get a structurally-equivalent layout\n   * with a different name since all {@link Layout} instances are\n   * immutable.\n   *\n   * **NOTE** This is a shallow copy.  All fields except {@link\n   * Layout#property|property} are strictly equal to the origin layout.\n   *\n   * @param {String} property - the value for {@link\n   * Layout#property|property} in the replica.\n   *\n   * @returns {Layout} - the copy with {@link Layout#property|property}\n   * set to `property`.\n   */\n  replicate(property) {\n    const rv = Object.create(this.constructor.prototype);\n    Object.assign(rv, this);\n    rv.property = property;\n    return rv;\n  }\n\n  /**\n   * Create an object from layout properties and an array of values.\n   *\n   * **NOTE** This function returns `undefined` if invoked on a layout\n   * that does not return its value as an Object.  Objects are\n   * returned for things that are a {@link Structure}, which includes\n   * {@link VariantLayout|variant layouts} if they are structures, and\n   * excludes {@link Union}s.  If you want this feature for a union\n   * you must use {@link Union.getVariant|getVariant} to select the\n   * desired layout.\n   *\n   * @param {Array} values - an array of values that correspond to the\n   * default order for properties.  As with {@link Layout#decode|decode}\n   * layout elements that have no property name are skipped when\n   * iterating over the array values.  Only the top-level properties are\n   * assigned; arguments are not assigned to properties of contained\n   * layouts.  Any unused values are ignored.\n   *\n   * @return {(Object|undefined)}\n   */\n  fromArray(values) {\n    return undefined;\n  }\n}\nvar Layout_2 = Layout;\n\n/* Provide text that carries a name (such as for a function that will\n * be throwing an error) annotated with the property of a given layout\n * (such as one for which the value was unacceptable).\n *\n * @ignore */\nfunction nameWithProperty(name, lo) {\n  if (lo.property) {\n    return name + '[' + lo.property + ']';\n  }\n  return name;\n}\n\n/**\n * An object that behaves like a layout but does not consume space\n * within its containing layout.\n *\n * This is primarily used to obtain metadata about a member, such as a\n * {@link OffsetLayout} that can provide data about a {@link\n * Layout#getSpan|value-specific span}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support {@link\n * ExternalLayout#isCount|isCount} or other {@link Layout} functions.\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @abstract\n * @augments {Layout}\n */\nclass ExternalLayout extends Layout {\n  /**\n   * Return `true` iff the external layout decodes to an unsigned\n   * integer layout.\n   *\n   * In that case it can be used as the source of {@link\n   * Sequence#count|Sequence counts}, {@link Blob#length|Blob lengths},\n   * or as {@link UnionLayoutDiscriminator#layout|external union\n   * discriminators}.\n   *\n   * @abstract\n   */\n  isCount() {\n    throw new Error('ExternalLayout is abstract');\n  }\n}\n\n/**\n * An {@link ExternalLayout} that supports accessing a {@link Layout}\n * at a fixed offset from the start of another Layout.  The offset may\n * be before, within, or after the base layout.\n *\n * *Factory*: {@link module:Layout.offset|offset}\n *\n * @param {Layout} layout - initializer for {@link\n * OffsetLayout#layout|layout}, modulo `property`.\n *\n * @param {Number} [offset] - Initializes {@link\n * OffsetLayout#offset|offset}.  Defaults to zero.\n *\n * @param {string} [property] - Optional new property name for a\n * {@link Layout#replicate| replica} of `layout` to be used as {@link\n * OffsetLayout#layout|layout}.  If not provided the `layout` is used\n * unchanged.\n *\n * @augments {Layout}\n */\nclass OffsetLayout extends ExternalLayout {\n  constructor(layout, offset, property) {\n    if (!(layout instanceof Layout)) {\n      throw new TypeError('layout must be a Layout');\n    }\n\n    if (undefined === offset) {\n      offset = 0;\n    } else if (!Number.isInteger(offset)) {\n      throw new TypeError('offset must be integer or undefined');\n    }\n\n    super(layout.span, property || layout.property);\n\n    /** The subordinated layout. */\n    this.layout = layout;\n\n    /** The location of {@link OffsetLayout#layout} relative to the\n     * start of another layout.\n     *\n     * The value may be positive or negative, but an error will thrown\n     * if at the point of use it goes outside the span of the Buffer\n     * being accessed.  */\n    this.offset = offset;\n  }\n\n  /** @override */\n  isCount() {\n    return ((this.layout instanceof UInt)\n            || (this.layout instanceof UIntBE));\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.decode(b, offset + this.offset);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return this.layout.encode(src, b, offset + this.offset);\n  }\n}\n\n/**\n * Represent an unsigned integer in little-endian format.\n *\n * *Factory*: {@link module:Layout.u8|u8}, {@link\n *  module:Layout.u16|u16}, {@link module:Layout.u24|u24}, {@link\n *  module:Layout.u32|u32}, {@link module:Layout.u40|u40}, {@link\n *  module:Layout.u48|u48}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UInt extends Layout {\n  constructor(span, property) {\n    super(span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntLE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntLE(src, offset, this.span);\n    return this.span;\n  }\n}\n\n/**\n * Represent an unsigned integer in big-endian format.\n *\n * *Factory*: {@link module:Layout.u8be|u8be}, {@link\n * module:Layout.u16be|u16be}, {@link module:Layout.u24be|u24be},\n * {@link module:Layout.u32be|u32be}, {@link\n * module:Layout.u40be|u40be}, {@link module:Layout.u48be|u48be}\n *\n * @param {Number} span - initializer for {@link Layout#span|span}.\n * The parameter can range from 1 through 6.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass UIntBE extends Layout {\n  constructor(span, property) {\n    super( span, property);\n    if (6 < this.span) {\n      throw new RangeError('span must not exceed 6 bytes');\n    }\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    return b.readUIntBE(offset, this.span);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    b.writeUIntBE(src, offset, this.span);\n    return this.span;\n  }\n}\n\nconst V2E32 = Math.pow(2, 32);\n\n/* True modulus high and low 32-bit words, where low word is always\n * non-negative. */\nfunction divmodInt64(src) {\n  const hi32 = Math.floor(src / V2E32);\n  const lo32 = src - (hi32 * V2E32);\n  return {hi32, lo32};\n}\n/* Reconstruct Number from quotient and non-negative remainder */\nfunction roundedInt64(hi32, lo32) {\n  return hi32 * V2E32 + lo32;\n}\n\n/**\n * Represent an unsigned 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.nu64|nu64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearUInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readUInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeUInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a signed 64-bit integer in little-endian format when\n * encoded and as a near integral JavaScript Number when decoded.\n *\n * *Factory*: {@link module:Layout.ns64|ns64}\n *\n * **NOTE** Values with magnitude greater than 2^52 may not decode to\n * the exact value of the encoded representation.\n *\n * @augments {Layout}\n */\nclass NearInt64 extends Layout {\n  constructor(property) {\n    super(8, property);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const lo32 = b.readUInt32LE(offset);\n    const hi32 = b.readInt32LE(offset + 4);\n    return roundedInt64(hi32, lo32);\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const split = divmodInt64(src);\n    b.writeUInt32LE(split.lo32, offset);\n    b.writeInt32LE(split.hi32, offset + 4);\n    return 8;\n  }\n}\n\n/**\n * Represent a contiguous sequence of arbitrary layout elements as an\n * Object.\n *\n * *Factory*: {@link module:Layout.struct|struct}\n *\n * **NOTE** The {@link Layout#span|span} of the structure is variable\n * if any layout in {@link Structure#fields|fields} has a variable\n * span.  When {@link Layout#encode|encoding} we must have a value for\n * all variable-length fields, or we wouldn't be able to figure out\n * how much space to use for storage.  We can only identify the value\n * for a field when it has a {@link Layout#property|property}.  As\n * such, although a structure may contain both unnamed fields and\n * variable-length fields, it cannot contain an unnamed\n * variable-length field.\n *\n * @param {Layout[]} fields - initializer for {@link\n * Structure#fields|fields}.  An error is raised if this contains a\n * variable-length field for which a {@link Layout#property|property}\n * is not defined.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @param {Boolean} [decodePrefixes] - initializer for {@link\n * Structure#decodePrefixes|property}.\n *\n * @throws {Error} - if `fields` contains an unnamed variable-length\n * layout.\n *\n * @augments {Layout}\n */\nclass Structure extends Layout {\n  constructor(fields, property, decodePrefixes) {\n    if (!(Array.isArray(fields)\n          && fields.reduce((acc, v) => acc && (v instanceof Layout), true))) {\n      throw new TypeError('fields must be array of Layout instances');\n    }\n    if (('boolean' === typeof property)\n        && (undefined === decodePrefixes)) {\n      decodePrefixes = property;\n      property = undefined;\n    }\n\n    /* Verify absence of unnamed variable-length fields. */\n    for (const fd of fields) {\n      if ((0 > fd.span)\n          && (undefined === fd.property)) {\n        throw new Error('fields cannot contain unnamed variable-length layout');\n      }\n    }\n\n    let span = -1;\n    try {\n      span = fields.reduce((span, fd) => span + fd.getSpan(), 0);\n    } catch (e) {\n    }\n    super(span, property);\n\n    /** The sequence of {@link Layout} values that comprise the\n     * structure.\n     *\n     * The individual elements need not be the same type, and may be\n     * either scalar or aggregate layouts.  If a member layout leaves\n     * its {@link Layout#property|property} undefined the\n     * corresponding region of the buffer associated with the element\n     * will not be mutated.\n     *\n     * @type {Layout[]} */\n    this.fields = fields;\n\n    /** Control behavior of {@link Layout#decode|decode()} given short\n     * buffers.\n     *\n     * In some situations a structure many be extended with additional\n     * fields over time, with older installations providing only a\n     * prefix of the full structure.  If this property is `true`\n     * decoding will accept those buffers and leave subsequent fields\n     * undefined, as long as the buffer ends at a field boundary.\n     * Defaults to `false`. */\n    this.decodePrefixes = !!decodePrefixes;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = 0;\n    try {\n      span = this.fields.reduce((span, fd) => {\n        const fsp = fd.getSpan(b, offset);\n        offset += fsp;\n        return span + fsp;\n      }, 0);\n    } catch (e) {\n      throw new RangeError('indeterminate span');\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if (undefined !== fd.property) {\n        dest[fd.property] = fd.decode(b, offset);\n      }\n      offset += fd.getSpan(b, offset);\n      if (this.decodePrefixes\n          && (b.length === offset)) {\n        break;\n      }\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Structure}.\n   *\n   * If `src` is missing a property for a member with a defined {@link\n   * Layout#property|property} the corresponding region of the buffer is\n   * left unmodified. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const firstOffset = offset;\n    let lastOffset = 0;\n    let lastWrote = 0;\n    for (const fd of this.fields) {\n      let span = fd.span;\n      lastWrote = (0 < span) ? span : 0;\n      if (undefined !== fd.property) {\n        const fv = src[fd.property];\n        if (undefined !== fv) {\n          lastWrote = fd.encode(fv, b, offset);\n          if (0 > span) {\n            /* Read the as-encoded span, which is not necessarily the\n             * same as what we wrote. */\n            span = fd.getSpan(b, offset);\n          }\n        }\n      }\n      lastOffset = offset;\n      offset += span;\n    }\n    /* Use (lastOffset + lastWrote) instead of offset because the last\n     * item may have had a dynamic length and we don't want to include\n     * the padding between it and the end of the space reserved for\n     * it. */\n    return (lastOffset + lastWrote) - firstOffset;\n  }\n\n  /** @override */\n  fromArray(values) {\n    const dest = this.makeDestinationObject();\n    for (const fd of this.fields) {\n      if ((undefined !== fd.property)\n          && (0 < values.length)) {\n        dest[fd.property] = values.shift();\n      }\n    }\n    return dest;\n  }\n\n  /**\n   * Get access to the layout of a given property.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Layout} - the layout associated with `property`, or\n   * undefined if there is no such property.\n   */\n  layoutFor(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return fd;\n      }\n    }\n  }\n\n  /**\n   * Get the offset of a structure member.\n   *\n   * @param {String} property - the structure member of interest.\n   *\n   * @return {Number} - the offset in bytes to the start of `property`\n   * within the structure, or undefined if `property` is not a field\n   * within the structure.  If the property is a member but follows a\n   * variable-length structure member a negative number will be\n   * returned.\n   */\n  offsetOf(property) {\n    if ('string' !== typeof property) {\n      throw new TypeError('property must be string');\n    }\n    let offset = 0;\n    for (const fd of this.fields) {\n      if (fd.property === property) {\n        return offset;\n      }\n      if (0 > fd.span) {\n        offset = -1;\n      } else if (0 <= offset) {\n        offset += fd.span;\n      }\n    }\n  }\n}\n\n/**\n * An object that can provide a {@link\n * Union#discriminator|discriminator} API for {@link Union}.\n *\n * **NOTE** This is an abstract base class; you can create instances\n * if it amuses you, but they won't support the {@link\n * UnionDiscriminator#encode|encode} or {@link\n * UnionDiscriminator#decode|decode} functions.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}.\n *\n * @abstract\n */\nclass UnionDiscriminator {\n  constructor(property) {\n    /** The {@link Layout#property|property} to be used when the\n     * discriminator is referenced in isolation (generally when {@link\n     * Union#decode|Union decode} cannot delegate to a specific\n     * variant). */\n    this.property = property;\n  }\n\n  /** Analog to {@link Layout#decode|Layout decode} for union discriminators.\n   *\n   * The implementation of this method need not reference the buffer if\n   * variant information is available through other means. */\n  decode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n\n  /** Analog to {@link Layout#decode|Layout encode} for union discriminators.\n   *\n   * The implementation of this method need not store the value if\n   * variant information is maintained through other means. */\n  encode() {\n    throw new Error('UnionDiscriminator is abstract');\n  }\n}\n\n/**\n * An object that can provide a {@link\n * UnionDiscriminator|discriminator API} for {@link Union} using an\n * unsigned integral {@link Layout} instance located either inside or\n * outside the union.\n *\n * @param {ExternalLayout} layout - initializes {@link\n * UnionLayoutDiscriminator#layout|layout}.  Must satisfy {@link\n * ExternalLayout#isCount|isCount()}.\n *\n * @param {string} [property] - Default for {@link\n * UnionDiscriminator#property|property}, superseding the property\n * from `layout`, but defaulting to `variant` if neither `property`\n * nor layout provide a property name.\n *\n * @augments {UnionDiscriminator}\n */\nclass UnionLayoutDiscriminator extends UnionDiscriminator {\n  constructor(layout, property) {\n    if (!((layout instanceof ExternalLayout)\n          && layout.isCount())) {\n      throw new TypeError('layout must be an unsigned integer ExternalLayout');\n    }\n\n    super(property || layout.property || 'variant');\n\n    /** The {@link ExternalLayout} used to access the discriminator\n     * value. */\n    this.layout = layout;\n  }\n\n  /** Delegate decoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  decode(b, offset) {\n    return this.layout.decode(b, offset);\n  }\n\n  /** Delegate encoding to {@link UnionLayoutDiscriminator#layout|layout}. */\n  encode(src, b, offset) {\n    return this.layout.encode(src, b, offset);\n  }\n}\n\n/**\n * Represent any number of span-compatible layouts.\n *\n * *Factory*: {@link module:Layout.union|union}\n *\n * If the union has a {@link Union#defaultLayout|default layout} that\n * layout must have a non-negative {@link Layout#span|span}.  The span\n * of a fixed-span union includes its {@link\n * Union#discriminator|discriminator} if the variant is a {@link\n * Union#usesPrefixDiscriminator|prefix of the union}, plus the span\n * of its {@link Union#defaultLayout|default layout}.\n *\n * If the union does not have a default layout then the encoded span\n * of the union depends on the encoded span of its variant (which may\n * be fixed or variable).\n *\n * {@link VariantLayout#layout|Variant layout}s are added through\n * {@link Union#addVariant|addVariant}.  If the union has a default\n * layout, the span of the {@link VariantLayout#layout|layout\n * contained by the variant} must not exceed the span of the {@link\n * Union#defaultLayout|default layout} (minus the span of a {@link\n * Union#usesPrefixDiscriminator|prefix disriminator}, if used).  The\n * span of the variant will equal the span of the union itself.\n *\n * The variant for a buffer can only be identified from the {@link\n * Union#discriminator|discriminator} {@link\n * UnionDiscriminator#property|property} (in the case of the {@link\n * Union#defaultLayout|default layout}), or by using {@link\n * Union#getVariant|getVariant} and examining the resulting {@link\n * VariantLayout} instance.\n *\n * A variant compatible with a JavaScript object can be identified\n * using {@link Union#getSourceVariant|getSourceVariant}.\n *\n * @param {(UnionDiscriminator|ExternalLayout|Layout)} discr - How to\n * identify the layout used to interpret the union contents.  The\n * parameter must be an instance of {@link UnionDiscriminator}, an\n * {@link ExternalLayout} that satisfies {@link\n * ExternalLayout#isCount|isCount()}, or {@link UInt} (or {@link\n * UIntBE}).  When a non-external layout element is passed the layout\n * appears at the start of the union.  In all cases the (synthesized)\n * {@link UnionDiscriminator} instance is recorded as {@link\n * Union#discriminator|discriminator}.\n *\n * @param {(Layout|null)} defaultLayout - initializer for {@link\n * Union#defaultLayout|defaultLayout}.  If absent defaults to `null`.\n * If `null` there is no default layout: the union has data-dependent\n * length and attempts to decode or encode unrecognized variants will\n * throw an exception.  A {@link Layout} instance must have a\n * non-negative {@link Layout#span|span}, and if it lacks a {@link\n * Layout#property|property} the {@link\n * Union#defaultLayout|defaultLayout} will be a {@link\n * Layout#replicate|replica} with property `content`.\n *\n * @param {string} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Union extends Layout {\n  constructor(discr, defaultLayout, property) {\n    const upv = ((discr instanceof UInt)\n               || (discr instanceof UIntBE));\n    if (upv) {\n      discr = new UnionLayoutDiscriminator(new OffsetLayout(discr));\n    } else if ((discr instanceof ExternalLayout)\n               && discr.isCount()) {\n      discr = new UnionLayoutDiscriminator(discr);\n    } else if (!(discr instanceof UnionDiscriminator)) {\n      throw new TypeError('discr must be a UnionDiscriminator '\n                          + 'or an unsigned integer layout');\n    }\n    if (undefined === defaultLayout) {\n      defaultLayout = null;\n    }\n    if (!((null === defaultLayout)\n          || (defaultLayout instanceof Layout))) {\n      throw new TypeError('defaultLayout must be null or a Layout');\n    }\n    if (null !== defaultLayout) {\n      if (0 > defaultLayout.span) {\n        throw new Error('defaultLayout must have constant span');\n      }\n      if (undefined === defaultLayout.property) {\n        defaultLayout = defaultLayout.replicate('content');\n      }\n    }\n\n    /* The union span can be estimated only if there's a default\n     * layout.  The union spans its default layout, plus any prefix\n     * variant layout.  By construction both layouts, if present, have\n     * non-negative span. */\n    let span = -1;\n    if (defaultLayout) {\n      span = defaultLayout.span;\n      if ((0 <= span) && upv) {\n        span += discr.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The interface for the discriminator value in isolation.\n     *\n     * This a {@link UnionDiscriminator} either passed to the\n     * constructor or synthesized from the `discr` constructor\n     * argument.  {@link\n     * Union#usesPrefixDiscriminator|usesPrefixDiscriminator} will be\n     * `true` iff the `discr` parameter was a non-offset {@link\n     * Layout} instance. */\n    this.discriminator = discr;\n\n    /** `true` if the {@link Union#discriminator|discriminator} is the\n     * first field in the union.\n     *\n     * If `false` the discriminator is obtained from somewhere\n     * else. */\n    this.usesPrefixDiscriminator = upv;\n\n    /** The layout for non-discriminator content when the value of the\n     * discriminator is not recognized.\n     *\n     * This is the value passed to the constructor.  It is\n     * structurally equivalent to the second component of {@link\n     * Union#layout|layout} but may have a different property\n     * name. */\n    this.defaultLayout = defaultLayout;\n\n    /** A registry of allowed variants.\n     *\n     * The keys are unsigned integers which should be compatible with\n     * {@link Union.discriminator|discriminator}.  The property value\n     * is the corresponding {@link VariantLayout} instances assigned\n     * to this union by {@link Union#addVariant|addVariant}.\n     *\n     * **NOTE** The registry remains mutable so that variants can be\n     * {@link Union#addVariant|added} at any time.  Users should not\n     * manipulate the content of this property. */\n    this.registry = {};\n\n    /* Private variable used when invoking getSourceVariant */\n    let boundGetSourceVariant = this.defaultGetSourceVariant.bind(this);\n\n    /** Function to infer the variant selected by a source object.\n     *\n     * Defaults to {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant} but may\n     * be overridden using {@link\n     * Union#configGetSourceVariant|configGetSourceVariant}.\n     *\n     * @param {Object} src - as with {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * @returns {(undefined|VariantLayout)} The default variant\n     * (`undefined`) or first registered variant that uses a property\n     * available in `src`. */\n    this.getSourceVariant = function(src) {\n      return boundGetSourceVariant(src);\n    };\n\n    /** Function to override the implementation of {@link\n     * Union#getSourceVariant|getSourceVariant}.\n     *\n     * Use this if the desired variant cannot be identified using the\n     * algorithm of {@link\n     * Union#defaultGetSourceVariant|defaultGetSourceVariant}.\n     *\n     * **NOTE** The provided function will be invoked bound to this\n     * Union instance, providing local access to {@link\n     * Union#registry|registry}.\n     *\n     * @param {Function} gsv - a function that follows the API of\n     * {@link Union#defaultGetSourceVariant|defaultGetSourceVariant}. */\n    this.configGetSourceVariant = function(gsv) {\n      boundGetSourceVariant = gsv.bind(this);\n    };\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    /* Default layouts always have non-negative span, so we don't have\n     * one and we have to recognize the variant which will in turn\n     * determine the span. */\n    const vlo = this.getVariant(b, offset);\n    if (!vlo) {\n      throw new Error('unable to determine span for unrecognized variant');\n    }\n    return vlo.getSpan(b, offset);\n  }\n\n  /**\n   * Method to infer a registered Union variant compatible with `src`.\n   *\n   * The first satisified rule in the following sequence defines the\n   * return value:\n   * * If `src` has properties matching the Union discriminator and\n   *   the default layout, `undefined` is returned regardless of the\n   *   value of the discriminator property (this ensures the default\n   *   layout will be used);\n   * * If `src` has a property matching the Union discriminator, the\n   *   value of the discriminator identifies a registered variant, and\n   *   either (a) the variant has no layout, or (b) `src` has the\n   *   variant's property, then the variant is returned (because the\n   *   source satisfies the constraints of the variant it identifies);\n   * * If `src` does not have a property matching the Union\n   *   discriminator, but does have a property matching a registered\n   *   variant, then the variant is returned (because the source\n   *   matches a variant without an explicit conflict);\n   * * An error is thrown (because we either can't identify a variant,\n   *   or we were explicitly told the variant but can't satisfy it).\n   *\n   * @param {Object} src - an object presumed to be compatible with\n   * the content of the Union.\n   *\n   * @return {(undefined|VariantLayout)} - as described above.\n   *\n   * @throws {Error} - if `src` cannot be associated with a default or\n   * registered variant.\n   */\n  defaultGetSourceVariant(src) {\n    if (src.hasOwnProperty(this.discriminator.property)) {\n      if (this.defaultLayout\n          && src.hasOwnProperty(this.defaultLayout.property)) {\n        return undefined;\n      }\n      const vlo = this.registry[src[this.discriminator.property]];\n      if (vlo\n          && ((!vlo.layout)\n              || src.hasOwnProperty(vlo.property))) {\n        return vlo;\n      }\n    } else {\n      for (const tag in this.registry) {\n        const vlo = this.registry[tag];\n        if (src.hasOwnProperty(vlo.property)) {\n          return vlo;\n        }\n      }\n    }\n    throw new Error('unable to infer src variant');\n  }\n\n  /** Implement {@link Layout#decode|decode} for {@link Union}.\n   *\n   * If the variant is {@link Union#addVariant|registered} the return\n   * value is an instance of that variant, with no explicit\n   * discriminator.  Otherwise the {@link Union#defaultLayout|default\n   * layout} is used to decode the content. */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let dest;\n    const dlo = this.discriminator;\n    const discr = dlo.decode(b, offset);\n    let clo = this.registry[discr];\n    if (undefined === clo) {\n      let contentOffset = 0;\n      clo = this.defaultLayout;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dest = this.makeDestinationObject();\n      dest[dlo.property] = discr;\n      dest[clo.property] = this.defaultLayout.decode(b, offset + contentOffset);\n    } else {\n      dest = clo.decode(b, offset);\n    }\n    return dest;\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Union}.\n   *\n   * This API assumes the `src` object is consistent with the union's\n   * {@link Union#defaultLayout|default layout}.  To encode variants\n   * use the appropriate variant-specific {@link VariantLayout#encode}\n   * method. */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    const vlo = this.getSourceVariant(src);\n    if (undefined === vlo) {\n      const dlo = this.discriminator;\n      const clo = this.defaultLayout;\n      let contentOffset = 0;\n      if (this.usesPrefixDiscriminator) {\n        contentOffset = dlo.layout.span;\n      }\n      dlo.encode(src[dlo.property], b, offset);\n      return contentOffset + clo.encode(src[clo.property], b,\n                                        offset + contentOffset);\n    }\n    return vlo.encode(src, b, offset);\n  }\n\n  /** Register a new variant structure within a union.  The newly\n   * created variant is returned.\n   *\n   * @param {Number} variant - initializer for {@link\n   * VariantLayout#variant|variant}.\n   *\n   * @param {Layout} layout - initializer for {@link\n   * VariantLayout#layout|layout}.\n   *\n   * @param {String} property - initializer for {@link\n   * Layout#property|property}.\n   *\n   * @return {VariantLayout} */\n  addVariant(variant, layout, property) {\n    const rv = new VariantLayout(this, variant, layout, property);\n    this.registry[variant] = rv;\n    return rv;\n  }\n\n  /**\n   * Get the layout associated with a registered variant.\n   *\n   * If `vb` does not produce a registered variant the function returns\n   * `undefined`.\n   *\n   * @param {(Number|Buffer)} vb - either the variant number, or a\n   * buffer from which the discriminator is to be read.\n   *\n   * @param {Number} offset - offset into `vb` for the start of the\n   * union.  Used only when `vb` is an instance of {Buffer}.\n   *\n   * @return {({VariantLayout}|undefined)}\n   */\n  getVariant(vb, offset) {\n    let variant = vb;\n    if (Buffer.isBuffer(vb)) {\n      if (undefined === offset) {\n        offset = 0;\n      }\n      variant = this.discriminator.decode(vb, offset);\n    }\n    return this.registry[variant];\n  }\n}\n\n/**\n * Represent a specific variant within a containing union.\n *\n * **NOTE** The {@link Layout#span|span} of the variant may include\n * the span of the {@link Union#discriminator|discriminator} used to\n * identify it, but values read and written using the variant strictly\n * conform to the content of {@link VariantLayout#layout|layout}.\n *\n * **NOTE** User code should not invoke this constructor directly.  Use\n * the union {@link Union#addVariant|addVariant} helper method.\n *\n * @param {Union} union - initializer for {@link\n * VariantLayout#union|union}.\n *\n * @param {Number} variant - initializer for {@link\n * VariantLayout#variant|variant}.\n *\n * @param {Layout} [layout] - initializer for {@link\n * VariantLayout#layout|layout}.  If absent the variant carries no\n * data.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.  Unlike many other layouts, variant\n * layouts normally include a property name so they can be identified\n * within their containing {@link Union}.  The property identifier may\n * be absent only if `layout` is is absent.\n *\n * @augments {Layout}\n */\nclass VariantLayout extends Layout {\n  constructor(union, variant, layout, property) {\n    if (!(union instanceof Union)) {\n      throw new TypeError('union must be a Union');\n    }\n    if ((!Number.isInteger(variant)) || (0 > variant)) {\n      throw new TypeError('variant must be a (non-negative) integer');\n    }\n    if (('string' === typeof layout)\n        && (undefined === property)) {\n      property = layout;\n      layout = null;\n    }\n    if (layout) {\n      if (!(layout instanceof Layout)) {\n        throw new TypeError('layout must be a Layout');\n      }\n      if ((null !== union.defaultLayout)\n          && (0 <= layout.span)\n          && (layout.span > union.defaultLayout.span)) {\n        throw new Error('variant span exceeds span of containing union');\n      }\n      if ('string' !== typeof property) {\n        throw new TypeError('variant must have a String property');\n      }\n    }\n    let span = union.span;\n    if (0 > union.span) {\n      span = layout ? layout.span : 0;\n      if ((0 <= span) && union.usesPrefixDiscriminator) {\n        span += union.discriminator.layout.span;\n      }\n    }\n    super(span, property);\n\n    /** The {@link Union} to which this variant belongs. */\n    this.union = union;\n\n    /** The unsigned integral value identifying this variant within\n     * the {@link Union#discriminator|discriminator} of the containing\n     * union. */\n    this.variant = variant;\n\n    /** The {@link Layout} to be used when reading/writing the\n     * non-discriminator part of the {@link\n     * VariantLayout#union|union}.  If `null` the variant carries no\n     * data. */\n    this.layout = layout || null;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    if (0 <= this.span) {\n      /* Will be equal to the containing union span if that is not\n       * variable. */\n      return this.span;\n    }\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    /* Span is defined solely by the variant (and prefix discriminator) */\n    return contentOffset + this.layout.getSpan(b, offset + contentOffset);\n  }\n\n  /** @override */\n  decode(b, offset) {\n    const dest = this.makeDestinationObject();\n    if (undefined === offset) {\n      offset = 0;\n    }\n    if (this !== this.union.getVariant(b, offset)) {\n      throw new Error('variant mismatch');\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout) {\n      dest[this.property] = this.layout.decode(b, offset + contentOffset);\n    } else if (this.property) {\n      dest[this.property] = true;\n    } else if (this.union.usesPrefixDiscriminator) {\n      dest[this.union.discriminator.property] = this.variant;\n    }\n    return dest;\n  }\n\n  /** @override */\n  encode(src, b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let contentOffset = 0;\n    if (this.union.usesPrefixDiscriminator) {\n      contentOffset = this.union.discriminator.layout.span;\n    }\n    if (this.layout\n        && (!src.hasOwnProperty(this.property))) {\n      throw new TypeError('variant lacks property ' + this.property);\n    }\n    this.union.discriminator.encode(this.variant, b, offset);\n    let span = contentOffset;\n    if (this.layout) {\n      this.layout.encode(src[this.property], b, offset + contentOffset);\n      span += this.layout.getSpan(b, offset + contentOffset);\n      if ((0 <= this.union.span)\n          && (span > this.union.span)) {\n        throw new Error('encoded variant overruns containing union');\n      }\n    }\n    return span;\n  }\n\n  /** Delegate {@link Layout#fromArray|fromArray} to {@link\n   * VariantLayout#layout|layout}. */\n  fromArray(values) {\n    if (this.layout) {\n      return this.layout.fromArray(values);\n    }\n  }\n}\n/* eslint-enable no-extend-native */\n\n/**\n * Contain a fixed-length block of arbitrary data, represented as a\n * Buffer.\n *\n * *Factory*: {@link module:Layout.blob|blob}\n *\n * @param {(Number|ExternalLayout)} length - initializes {@link\n * Blob#length|length}.\n *\n * @param {String} [property] - initializer for {@link\n * Layout#property|property}.\n *\n * @augments {Layout}\n */\nclass Blob$1 extends Layout {\n  constructor(length, property) {\n    if (!(((length instanceof ExternalLayout) && length.isCount())\n          || (Number.isInteger(length) && (0 <= length)))) {\n      throw new TypeError('length must be positive integer '\n                          + 'or an unsigned integer ExternalLayout');\n    }\n\n    let span = -1;\n    if (!(length instanceof ExternalLayout)) {\n      span = length;\n    }\n    super(span, property);\n\n    /** The number of bytes in the blob.\n     *\n     * This may be a non-negative integer, or an instance of {@link\n     * ExternalLayout} that satisfies {@link\n     * ExternalLayout#isCount|isCount()}. */\n    this.length = length;\n  }\n\n  /** @override */\n  getSpan(b, offset) {\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return span;\n  }\n\n  /** @override */\n  decode(b, offset) {\n    if (undefined === offset) {\n      offset = 0;\n    }\n    let span = this.span;\n    if (0 > span) {\n      span = this.length.decode(b, offset);\n    }\n    return b.slice(offset, offset + span);\n  }\n\n  /** Implement {@link Layout#encode|encode} for {@link Blob}.\n   *\n   * **NOTE** If {@link Layout#count|count} is an instance of {@link\n   * ExternalLayout} then the length of `src` will be encoded as the\n   * count after `src` is encoded. */\n  encode(src, b, offset) {\n    let span = this.length;\n    if (this.length instanceof ExternalLayout) {\n      span = src.length;\n    }\n    if (!(Buffer.isBuffer(src)\n          && (span === src.length))) {\n      throw new TypeError(nameWithProperty('Blob.encode', this)\n                          + ' requires (length ' + span + ') Buffer as src');\n    }\n    if ((offset + span) > b.length) {\n      throw new RangeError('encoding overruns Buffer');\n    }\n    b.write(src.toString('hex'), offset, span, 'hex');\n    if (this.length instanceof ExternalLayout) {\n      this.length.encode(span, b, offset);\n    }\n    return span;\n  }\n}\n\n/** Factory for {@link OffsetLayout}. */\nvar offset = ((layout, offset, property) => new OffsetLayout(layout, offset, property));\n\n/** Factory for {@link UInt|unsigned int layouts} spanning one\n * byte. */\nvar u8 = (property => new UInt(1, property));\n\n/** Factory for {@link UInt|little-endian unsigned int layouts}\n * spanning four bytes. */\nvar u32 = (property => new UInt(4, property));\n\n/** Factory for {@link NearUInt64|little-endian unsigned int\n * layouts} interpreted as Numbers. */\nvar nu64 = (property => new NearUInt64(property));\n\n/** Factory for {@link NearInt64|little-endian signed int layouts}\n * interpreted as Numbers. */\nvar ns64 = (property => new NearInt64(property));\n\n/** Factory for {@link Structure} values. */\nvar struct = ((fields, property, decodePrefixes) => new Structure(fields, property, decodePrefixes));\n\n/** Factory for {@link Union} values. */\nvar union = ((discr, defaultLayout, property) => new Union(discr, defaultLayout, property));\n\n/** Factory for {@link Blob} values. */\nvar blob = ((length, property) => new Blob$1(length, property));\n\nclass SystemInstructionCoder {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    constructor(_) { }\n    encode(ixName, ix) {\n        switch (ixName) {\n            case \"createAccount\": {\n                return encodeCreateAccount(ix);\n            }\n            case \"assign\": {\n                return encodeAssign(ix);\n            }\n            case \"transfer\": {\n                return encodeTransfer(ix);\n            }\n            case \"createAccountWithSeed\": {\n                return encodeCreateAccountWithSeed(ix);\n            }\n            case \"advanceNonceAccount\": {\n                return encodeAdvanceNonceAccount(ix);\n            }\n            case \"withdrawNonceAccount\": {\n                return encodeWithdrawNonceAccount(ix);\n            }\n            case \"initializeNonceAccount\": {\n                return encodeInitializeNonceAccount(ix);\n            }\n            case \"authorizeNonceAccount\": {\n                return encodeAuthorizeNonceAccount(ix);\n            }\n            case \"allocate\": {\n                return encodeAllocate(ix);\n            }\n            case \"allocateWithSeed\": {\n                return encodeAllocateWithSeed(ix);\n            }\n            case \"assignWithSeed\": {\n                return encodeAssignWithSeed(ix);\n            }\n            case \"transferWithSeed\": {\n                return encodeTransferWithSeed(ix);\n            }\n            default: {\n                throw new Error(`Invalid instruction: ${ixName}`);\n            }\n        }\n    }\n    encodeState(_ixName, _ix) {\n        throw new Error(\"System does not have state\");\n    }\n}\nclass RustStringLayout extends Layout_2 {\n    constructor(property) {\n        super(-1, property);\n        this.property = property;\n        this.layout = struct([\n            u32(\"length\"),\n            u32(\"lengthPadding\"),\n            blob(offset(u32(), -8), \"chars\"),\n        ], this.property);\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.layout.span;\n        }\n        const data = {\n            chars: Buffer.from(src, \"utf8\"),\n        };\n        return this.layout.encode(data, b, offset);\n    }\n    decode(b, offset = 0) {\n        const data = this.layout.decode(b, offset);\n        return data[\"chars\"].toString();\n    }\n    getSpan(b, offset = 0) {\n        return (u32().span +\n            u32().span +\n            new BN(new Uint8Array(b).slice(offset, offset + 4), 10, \"le\").toNumber());\n    }\n}\nfunction rustStringLayout(property) {\n    return new RustStringLayout(property);\n}\nfunction publicKey$2(property) {\n    return blob(32, property);\n}\nfunction encodeCreateAccount({ lamports, space, owner }) {\n    return encodeData({\n        createAccount: { lamports, space, owner: owner.toBuffer() },\n    });\n}\nfunction encodeAssign({ owner }) {\n    return encodeData({\n        assign: { owner: owner.toBuffer() },\n    });\n}\nfunction encodeTransfer({ lamports }) {\n    return encodeData({\n        transfer: { lamports },\n    });\n}\nfunction encodeCreateAccountWithSeed({ base, seed, lamports, space, owner, }) {\n    return encodeData({\n        createAccountWithSeed: {\n            base: base.toBuffer(),\n            seed,\n            lamports,\n            space,\n            owner: owner.toBuffer(),\n        },\n    }, LAYOUT.getVariant(3).span + seed.length);\n}\nfunction encodeInitializeNonceAccount({ authorized }) {\n    return encodeData({\n        initializeNonceAccount: { authorized: authorized.toBuffer() },\n    });\n}\nfunction encodeAdvanceNonceAccount({ authorized }) {\n    return encodeData({\n        advanceNonceAccount: { authorized: authorized.toBuffer() },\n    });\n}\nfunction encodeWithdrawNonceAccount({ lamports }) {\n    return encodeData({\n        withdrawNonceAccount: { lamports },\n    });\n}\nfunction encodeAuthorizeNonceAccount({ authorized }) {\n    return encodeData({\n        authorizeNonceAccount: { authorized: authorized.toBuffer() },\n    });\n}\nfunction encodeAllocate({ space }) {\n    return encodeData({\n        allocate: { space },\n    });\n}\nfunction encodeAllocateWithSeed({ base, seed, space, owner }) {\n    return encodeData({\n        allocateWithSeed: {\n            base: base.toBuffer(),\n            seed,\n            space,\n            owner: owner.toBuffer(),\n        },\n    }, LAYOUT.getVariant(9).span + seed.length);\n}\nfunction encodeAssignWithSeed({ base, seed, owner }) {\n    return encodeData({\n        assignWithSeed: {\n            base: base.toBuffer(),\n            seed,\n            owner: owner.toBuffer(),\n        },\n    }, LAYOUT.getVariant(10).span + seed.length);\n}\nfunction encodeTransferWithSeed({ lamports, seed, owner }) {\n    return encodeData({\n        transferWithSeed: {\n            lamports,\n            seed,\n            owner: owner.toBuffer(),\n        },\n    }, LAYOUT.getVariant(11).span + seed.length);\n}\nconst LAYOUT = union(u32(\"instruction\"));\nLAYOUT.addVariant(0, struct([\n    ns64(\"lamports\"),\n    ns64(\"space\"),\n    publicKey$2(\"owner\"),\n]), \"createAccount\");\nLAYOUT.addVariant(1, struct([publicKey$2(\"owner\")]), \"assign\");\nLAYOUT.addVariant(2, struct([ns64(\"lamports\")]), \"transfer\");\nLAYOUT.addVariant(3, struct([\n    publicKey$2(\"base\"),\n    rustStringLayout(\"seed\"),\n    ns64(\"lamports\"),\n    ns64(\"space\"),\n    publicKey$2(\"owner\"),\n]), \"createAccountWithSeed\");\nLAYOUT.addVariant(4, struct([publicKey$2(\"authorized\")]), \"advanceNonceAccount\");\nLAYOUT.addVariant(5, struct([ns64(\"lamports\")]), \"withdrawNonceAccount\");\nLAYOUT.addVariant(6, struct([publicKey$2(\"authorized\")]), \"initializeNonceAccount\");\nLAYOUT.addVariant(7, struct([publicKey$2(\"authorized\")]), \"authorizeNonceAccount\");\nLAYOUT.addVariant(8, struct([ns64(\"space\")]), \"allocate\");\nLAYOUT.addVariant(9, struct([\n    publicKey$2(\"base\"),\n    rustStringLayout(\"seed\"),\n    ns64(\"space\"),\n    publicKey$2(\"owner\"),\n]), \"allocateWithSeed\");\nLAYOUT.addVariant(10, struct([\n    publicKey$2(\"base\"),\n    rustStringLayout(\"seed\"),\n    publicKey$2(\"owner\"),\n]), \"assignWithSeed\");\nLAYOUT.addVariant(11, struct([\n    ns64(\"lamports\"),\n    rustStringLayout(\"seed\"),\n    publicKey$2(\"owner\"),\n]), \"transferWithSeed\");\nfunction encodeData(instruction, maxSpan) {\n    const b = Buffer.alloc(maxSpan !== null && maxSpan !== void 0 ? maxSpan : instructionMaxSpan);\n    const span = LAYOUT.encode(instruction, b);\n    if (maxSpan === undefined) {\n        return b.slice(0, span);\n    }\n    return b;\n}\nconst instructionMaxSpan = Math.max(...Object.values(LAYOUT.registry).map((r) => r.span));\n\nclass SystemAccountsCoder {\n    constructor(idl) {\n        this.idl = idl;\n    }\n    async encode(accountName, account) {\n        switch (accountName) {\n            case \"nonce\": {\n                const buffer = Buffer.alloc(NONCE_ACCOUNT_LENGTH);\n                const len = NONCE_ACCOUNT_LAYOUT.encode(account, buffer);\n                return buffer.slice(0, len);\n            }\n            default: {\n                throw new Error(`Invalid account name: ${accountName}`);\n            }\n        }\n    }\n    decode(accountName, ix) {\n        return this.decodeUnchecked(accountName, ix);\n    }\n    decodeUnchecked(accountName, ix) {\n        switch (accountName) {\n            case \"nonce\": {\n                return decodeNonceAccount(ix);\n            }\n            default: {\n                throw new Error(`Invalid account name: ${accountName}`);\n            }\n        }\n    }\n    // TODO: this won't use the appendData.\n    memcmp(accountName, _appendData) {\n        switch (accountName) {\n            case \"nonce\": {\n                return {\n                    dataSize: NONCE_ACCOUNT_LENGTH,\n                };\n            }\n            default: {\n                throw new Error(`Invalid account name: ${accountName}`);\n            }\n        }\n    }\n    size(accountName) {\n        return IdlCoder.typeSize({ defined: { name: accountName } }, this.idl);\n    }\n}\nfunction decodeNonceAccount(ix) {\n    return NONCE_ACCOUNT_LAYOUT.decode(ix);\n}\nclass WrappedLayout$1 extends Layout_2 {\n    constructor(layout, decoder, encoder, property) {\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nfunction publicKey$1(property) {\n    return new WrappedLayout$1(blob(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);\n}\nconst NONCE_ACCOUNT_LAYOUT = struct([\n    u32(\"version\"),\n    u32(\"state\"),\n    publicKey$1(\"authorizedPubkey\"),\n    publicKey$1(\"nonce\"),\n    struct([nu64(\"lamportsPerSignature\")], \"feeCalculator\"),\n]);\n\nclass SystemEventsCoder {\n    constructor(_idl) { }\n    decode(_log) {\n        throw new Error(\"System program does not have events\");\n    }\n}\n\nclass SystemTypesCoder {\n    constructor(_idl) { }\n    encode(_name, _type) {\n        throw new Error(\"System does not have user-defined types\");\n    }\n    decode(_name, _typeData) {\n        throw new Error(\"System does not have user-defined types\");\n    }\n}\n\n/**\n * Coder for the System program.\n */\nclass SystemCoder {\n    constructor(idl) {\n        this.instruction = new SystemInstructionCoder(idl);\n        this.accounts = new SystemAccountsCoder(idl);\n        this.events = new SystemEventsCoder(idl);\n        this.types = new SystemTypesCoder(idl);\n    }\n}\n\nfunction hash(data) {\n    return new TextDecoder().decode(sha256$1(data));\n}\n\nvar sha256 = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    hash: hash\n});\n\n// Sync version of web3.PublicKey.createWithSeed.\nfunction createWithSeedSync(fromPublicKey, seed, programId) {\n    const buffer = Buffer$1.concat([\n        fromPublicKey.toBuffer(),\n        Buffer$1.from(seed),\n        programId.toBuffer(),\n    ]);\n    return new PublicKey(sha256$1(buffer));\n}\n\nvar pubkey = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    createWithSeedSync: createWithSeedSync\n});\n\nconst TOKEN_PROGRAM_ID = new PublicKey(\"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA\");\nconst ASSOCIATED_PROGRAM_ID = new PublicKey(\"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL\");\nfunction associatedAddress({ mint, owner, }) {\n    return PublicKey.findProgramAddressSync([owner.toBuffer(), TOKEN_PROGRAM_ID.toBuffer(), mint.toBuffer()], ASSOCIATED_PROGRAM_ID)[0];\n}\n\nvar token = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    TOKEN_PROGRAM_ID: TOKEN_PROGRAM_ID,\n    ASSOCIATED_PROGRAM_ID: ASSOCIATED_PROGRAM_ID,\n    associatedAddress: associatedAddress\n});\n\nvar browserPonyfill = {exports: {}};\n\n(function (module, exports) {\nvar global = typeof self !== 'undefined' ? self : commonjsGlobal;\nvar __self__ = (function () {\nfunction F() {\nthis.fetch = false;\nthis.DOMException = global.DOMException;\n}\nF.prototype = global;\nreturn new F();\n})();\n(function(self) {\n\n((function (exports) {\n\n  var support = {\n    searchParams: 'URLSearchParams' in self,\n    iterable: 'Symbol' in self && 'iterator' in Symbol,\n    blob:\n      'FileReader' in self &&\n      'Blob' in self &&\n      (function() {\n        try {\n          new Blob();\n          return true\n        } catch (e) {\n          return false\n        }\n      })(),\n    formData: 'FormData' in self,\n    arrayBuffer: 'ArrayBuffer' in self\n  };\n\n  function isDataView(obj) {\n    return obj && DataView.prototype.isPrototypeOf(obj)\n  }\n\n  if (support.arrayBuffer) {\n    var viewClasses = [\n      '[object Int8Array]',\n      '[object Uint8Array]',\n      '[object Uint8ClampedArray]',\n      '[object Int16Array]',\n      '[object Uint16Array]',\n      '[object Int32Array]',\n      '[object Uint32Array]',\n      '[object Float32Array]',\n      '[object Float64Array]'\n    ];\n\n    var isArrayBufferView =\n      ArrayBuffer.isView ||\n      function(obj) {\n        return obj && viewClasses.indexOf(Object.prototype.toString.call(obj)) > -1\n      };\n  }\n\n  function normalizeName(name) {\n    if (typeof name !== 'string') {\n      name = String(name);\n    }\n    if (/[^a-z0-9\\-#$%&'*+.^_`|~]/i.test(name)) {\n      throw new TypeError('Invalid character in header field name')\n    }\n    return name.toLowerCase()\n  }\n\n  function normalizeValue(value) {\n    if (typeof value !== 'string') {\n      value = String(value);\n    }\n    return value\n  }\n\n  // Build a destructive iterator for the value list\n  function iteratorFor(items) {\n    var iterator = {\n      next: function() {\n        var value = items.shift();\n        return {done: value === undefined, value: value}\n      }\n    };\n\n    if (support.iterable) {\n      iterator[Symbol.iterator] = function() {\n        return iterator\n      };\n    }\n\n    return iterator\n  }\n\n  function Headers(headers) {\n    this.map = {};\n\n    if (headers instanceof Headers) {\n      headers.forEach(function(value, name) {\n        this.append(name, value);\n      }, this);\n    } else if (Array.isArray(headers)) {\n      headers.forEach(function(header) {\n        this.append(header[0], header[1]);\n      }, this);\n    } else if (headers) {\n      Object.getOwnPropertyNames(headers).forEach(function(name) {\n        this.append(name, headers[name]);\n      }, this);\n    }\n  }\n\n  Headers.prototype.append = function(name, value) {\n    name = normalizeName(name);\n    value = normalizeValue(value);\n    var oldValue = this.map[name];\n    this.map[name] = oldValue ? oldValue + ', ' + value : value;\n  };\n\n  Headers.prototype['delete'] = function(name) {\n    delete this.map[normalizeName(name)];\n  };\n\n  Headers.prototype.get = function(name) {\n    name = normalizeName(name);\n    return this.has(name) ? this.map[name] : null\n  };\n\n  Headers.prototype.has = function(name) {\n    return this.map.hasOwnProperty(normalizeName(name))\n  };\n\n  Headers.prototype.set = function(name, value) {\n    this.map[normalizeName(name)] = normalizeValue(value);\n  };\n\n  Headers.prototype.forEach = function(callback, thisArg) {\n    for (var name in this.map) {\n      if (this.map.hasOwnProperty(name)) {\n        callback.call(thisArg, this.map[name], name, this);\n      }\n    }\n  };\n\n  Headers.prototype.keys = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push(name);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.values = function() {\n    var items = [];\n    this.forEach(function(value) {\n      items.push(value);\n    });\n    return iteratorFor(items)\n  };\n\n  Headers.prototype.entries = function() {\n    var items = [];\n    this.forEach(function(value, name) {\n      items.push([name, value]);\n    });\n    return iteratorFor(items)\n  };\n\n  if (support.iterable) {\n    Headers.prototype[Symbol.iterator] = Headers.prototype.entries;\n  }\n\n  function consumed(body) {\n    if (body.bodyUsed) {\n      return Promise.reject(new TypeError('Already read'))\n    }\n    body.bodyUsed = true;\n  }\n\n  function fileReaderReady(reader) {\n    return new Promise(function(resolve, reject) {\n      reader.onload = function() {\n        resolve(reader.result);\n      };\n      reader.onerror = function() {\n        reject(reader.error);\n      };\n    })\n  }\n\n  function readBlobAsArrayBuffer(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsArrayBuffer(blob);\n    return promise\n  }\n\n  function readBlobAsText(blob) {\n    var reader = new FileReader();\n    var promise = fileReaderReady(reader);\n    reader.readAsText(blob);\n    return promise\n  }\n\n  function readArrayBufferAsText(buf) {\n    var view = new Uint8Array(buf);\n    var chars = new Array(view.length);\n\n    for (var i = 0; i < view.length; i++) {\n      chars[i] = String.fromCharCode(view[i]);\n    }\n    return chars.join('')\n  }\n\n  function bufferClone(buf) {\n    if (buf.slice) {\n      return buf.slice(0)\n    } else {\n      var view = new Uint8Array(buf.byteLength);\n      view.set(new Uint8Array(buf));\n      return view.buffer\n    }\n  }\n\n  function Body() {\n    this.bodyUsed = false;\n\n    this._initBody = function(body) {\n      this._bodyInit = body;\n      if (!body) {\n        this._bodyText = '';\n      } else if (typeof body === 'string') {\n        this._bodyText = body;\n      } else if (support.blob && Blob.prototype.isPrototypeOf(body)) {\n        this._bodyBlob = body;\n      } else if (support.formData && FormData.prototype.isPrototypeOf(body)) {\n        this._bodyFormData = body;\n      } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n        this._bodyText = body.toString();\n      } else if (support.arrayBuffer && support.blob && isDataView(body)) {\n        this._bodyArrayBuffer = bufferClone(body.buffer);\n        // IE 10-11 can't handle a DataView body.\n        this._bodyInit = new Blob([this._bodyArrayBuffer]);\n      } else if (support.arrayBuffer && (ArrayBuffer.prototype.isPrototypeOf(body) || isArrayBufferView(body))) {\n        this._bodyArrayBuffer = bufferClone(body);\n      } else {\n        this._bodyText = body = Object.prototype.toString.call(body);\n      }\n\n      if (!this.headers.get('content-type')) {\n        if (typeof body === 'string') {\n          this.headers.set('content-type', 'text/plain;charset=UTF-8');\n        } else if (this._bodyBlob && this._bodyBlob.type) {\n          this.headers.set('content-type', this._bodyBlob.type);\n        } else if (support.searchParams && URLSearchParams.prototype.isPrototypeOf(body)) {\n          this.headers.set('content-type', 'application/x-www-form-urlencoded;charset=UTF-8');\n        }\n      }\n    };\n\n    if (support.blob) {\n      this.blob = function() {\n        var rejected = consumed(this);\n        if (rejected) {\n          return rejected\n        }\n\n        if (this._bodyBlob) {\n          return Promise.resolve(this._bodyBlob)\n        } else if (this._bodyArrayBuffer) {\n          return Promise.resolve(new Blob([this._bodyArrayBuffer]))\n        } else if (this._bodyFormData) {\n          throw new Error('could not read FormData body as blob')\n        } else {\n          return Promise.resolve(new Blob([this._bodyText]))\n        }\n      };\n\n      this.arrayBuffer = function() {\n        if (this._bodyArrayBuffer) {\n          return consumed(this) || Promise.resolve(this._bodyArrayBuffer)\n        } else {\n          return this.blob().then(readBlobAsArrayBuffer)\n        }\n      };\n    }\n\n    this.text = function() {\n      var rejected = consumed(this);\n      if (rejected) {\n        return rejected\n      }\n\n      if (this._bodyBlob) {\n        return readBlobAsText(this._bodyBlob)\n      } else if (this._bodyArrayBuffer) {\n        return Promise.resolve(readArrayBufferAsText(this._bodyArrayBuffer))\n      } else if (this._bodyFormData) {\n        throw new Error('could not read FormData body as text')\n      } else {\n        return Promise.resolve(this._bodyText)\n      }\n    };\n\n    if (support.formData) {\n      this.formData = function() {\n        return this.text().then(decode)\n      };\n    }\n\n    this.json = function() {\n      return this.text().then(JSON.parse)\n    };\n\n    return this\n  }\n\n  // HTTP methods whose capitalization should be normalized\n  var methods = ['DELETE', 'GET', 'HEAD', 'OPTIONS', 'POST', 'PUT'];\n\n  function normalizeMethod(method) {\n    var upcased = method.toUpperCase();\n    return methods.indexOf(upcased) > -1 ? upcased : method\n  }\n\n  function Request(input, options) {\n    options = options || {};\n    var body = options.body;\n\n    if (input instanceof Request) {\n      if (input.bodyUsed) {\n        throw new TypeError('Already read')\n      }\n      this.url = input.url;\n      this.credentials = input.credentials;\n      if (!options.headers) {\n        this.headers = new Headers(input.headers);\n      }\n      this.method = input.method;\n      this.mode = input.mode;\n      this.signal = input.signal;\n      if (!body && input._bodyInit != null) {\n        body = input._bodyInit;\n        input.bodyUsed = true;\n      }\n    } else {\n      this.url = String(input);\n    }\n\n    this.credentials = options.credentials || this.credentials || 'same-origin';\n    if (options.headers || !this.headers) {\n      this.headers = new Headers(options.headers);\n    }\n    this.method = normalizeMethod(options.method || this.method || 'GET');\n    this.mode = options.mode || this.mode || null;\n    this.signal = options.signal || this.signal;\n    this.referrer = null;\n\n    if ((this.method === 'GET' || this.method === 'HEAD') && body) {\n      throw new TypeError('Body not allowed for GET or HEAD requests')\n    }\n    this._initBody(body);\n  }\n\n  Request.prototype.clone = function() {\n    return new Request(this, {body: this._bodyInit})\n  };\n\n  function decode(body) {\n    var form = new FormData();\n    body\n      .trim()\n      .split('&')\n      .forEach(function(bytes) {\n        if (bytes) {\n          var split = bytes.split('=');\n          var name = split.shift().replace(/\\+/g, ' ');\n          var value = split.join('=').replace(/\\+/g, ' ');\n          form.append(decodeURIComponent(name), decodeURIComponent(value));\n        }\n      });\n    return form\n  }\n\n  function parseHeaders(rawHeaders) {\n    var headers = new Headers();\n    // Replace instances of \\r\\n and \\n followed by at least one space or horizontal tab with a space\n    // https://tools.ietf.org/html/rfc7230#section-3.2\n    var preProcessedHeaders = rawHeaders.replace(/\\r?\\n[\\t ]+/g, ' ');\n    preProcessedHeaders.split(/\\r?\\n/).forEach(function(line) {\n      var parts = line.split(':');\n      var key = parts.shift().trim();\n      if (key) {\n        var value = parts.join(':').trim();\n        headers.append(key, value);\n      }\n    });\n    return headers\n  }\n\n  Body.call(Request.prototype);\n\n  function Response(bodyInit, options) {\n    if (!options) {\n      options = {};\n    }\n\n    this.type = 'default';\n    this.status = options.status === undefined ? 200 : options.status;\n    this.ok = this.status >= 200 && this.status < 300;\n    this.statusText = 'statusText' in options ? options.statusText : 'OK';\n    this.headers = new Headers(options.headers);\n    this.url = options.url || '';\n    this._initBody(bodyInit);\n  }\n\n  Body.call(Response.prototype);\n\n  Response.prototype.clone = function() {\n    return new Response(this._bodyInit, {\n      status: this.status,\n      statusText: this.statusText,\n      headers: new Headers(this.headers),\n      url: this.url\n    })\n  };\n\n  Response.error = function() {\n    var response = new Response(null, {status: 0, statusText: ''});\n    response.type = 'error';\n    return response\n  };\n\n  var redirectStatuses = [301, 302, 303, 307, 308];\n\n  Response.redirect = function(url, status) {\n    if (redirectStatuses.indexOf(status) === -1) {\n      throw new RangeError('Invalid status code')\n    }\n\n    return new Response(null, {status: status, headers: {location: url}})\n  };\n\n  exports.DOMException = self.DOMException;\n  try {\n    new exports.DOMException();\n  } catch (err) {\n    exports.DOMException = function(message, name) {\n      this.message = message;\n      this.name = name;\n      var error = Error(message);\n      this.stack = error.stack;\n    };\n    exports.DOMException.prototype = Object.create(Error.prototype);\n    exports.DOMException.prototype.constructor = exports.DOMException;\n  }\n\n  function fetch(input, init) {\n    return new Promise(function(resolve, reject) {\n      var request = new Request(input, init);\n\n      if (request.signal && request.signal.aborted) {\n        return reject(new exports.DOMException('Aborted', 'AbortError'))\n      }\n\n      var xhr = new XMLHttpRequest();\n\n      function abortXhr() {\n        xhr.abort();\n      }\n\n      xhr.onload = function() {\n        var options = {\n          status: xhr.status,\n          statusText: xhr.statusText,\n          headers: parseHeaders(xhr.getAllResponseHeaders() || '')\n        };\n        options.url = 'responseURL' in xhr ? xhr.responseURL : options.headers.get('X-Request-URL');\n        var body = 'response' in xhr ? xhr.response : xhr.responseText;\n        resolve(new Response(body, options));\n      };\n\n      xhr.onerror = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.ontimeout = function() {\n        reject(new TypeError('Network request failed'));\n      };\n\n      xhr.onabort = function() {\n        reject(new exports.DOMException('Aborted', 'AbortError'));\n      };\n\n      xhr.open(request.method, request.url, true);\n\n      if (request.credentials === 'include') {\n        xhr.withCredentials = true;\n      } else if (request.credentials === 'omit') {\n        xhr.withCredentials = false;\n      }\n\n      if ('responseType' in xhr && support.blob) {\n        xhr.responseType = 'blob';\n      }\n\n      request.headers.forEach(function(value, name) {\n        xhr.setRequestHeader(name, value);\n      });\n\n      if (request.signal) {\n        request.signal.addEventListener('abort', abortXhr);\n\n        xhr.onreadystatechange = function() {\n          // DONE (success or failure)\n          if (xhr.readyState === 4) {\n            request.signal.removeEventListener('abort', abortXhr);\n          }\n        };\n      }\n\n      xhr.send(typeof request._bodyInit === 'undefined' ? null : request._bodyInit);\n    })\n  }\n\n  fetch.polyfill = true;\n\n  if (!self.fetch) {\n    self.fetch = fetch;\n    self.Headers = Headers;\n    self.Request = Request;\n    self.Response = Response;\n  }\n\n  exports.Headers = Headers;\n  exports.Request = Request;\n  exports.Response = Response;\n  exports.fetch = fetch;\n\n  Object.defineProperty(exports, '__esModule', { value: true });\n\n  return exports;\n\n}))({});\n})(__self__);\n__self__.fetch.ponyfill = true;\n// Remove \"polyfill\" property added by whatwg-fetch\ndelete __self__.fetch.polyfill;\n// Choose between native implementation (global) or custom implementation (__self__)\n// var ctx = global.fetch ? global : __self__;\nvar ctx = __self__; // this line disable service worker support temporarily\nexports = ctx.fetch; // To enable: import fetch from 'cross-fetch'\nexports.default = ctx.fetch; // For TypeScript consumers without esModuleInterop.\nexports.fetch = ctx.fetch; // To enable: import {fetch} from 'cross-fetch'\nexports.Headers = ctx.Headers;\nexports.Request = ctx.Request;\nexports.Response = ctx.Response;\nmodule.exports = exports;\n}(browserPonyfill, browserPonyfill.exports));\n\nvar fetch = /*@__PURE__*/getDefaultExportFromCjs(browserPonyfill.exports);\n\n/**\n * Returns a verified build from the anchor registry. null if no such\n * verified build exists, e.g., if the program has been upgraded since the\n * last verified build.\n */\nasync function verifiedBuild(connection, programId, limit = 5) {\n    const url = `https://api.apr.dev/api/v0/program/${programId.toString()}/latest?limit=${limit}`;\n    const [programData, latestBuildsResp] = await Promise.all([\n        fetchData(connection, programId),\n        fetch(url),\n    ]);\n    // Filter out all non successful builds.\n    const latestBuilds = (await latestBuildsResp.json()).filter((b) => !b.aborted && b.state === \"Built\" && b.verified === \"Verified\");\n    if (latestBuilds.length === 0) {\n        return null;\n    }\n    // Get the latest build.\n    const build = latestBuilds[0];\n    // Has the program been upgraded since the last build?\n    if (programData.slot.toNumber() !== build.verified_slot) {\n        return null;\n    }\n    // Success.\n    return build;\n}\n/**\n * Returns the program data account for this program, containing the\n * metadata for this program, e.g., the upgrade authority.\n */\nasync function fetchData(connection, programId) {\n    const accountInfo = await connection.getAccountInfo(programId);\n    if (accountInfo === null) {\n        throw new Error(\"program account not found\");\n    }\n    const { program } = decodeUpgradeableLoaderState(accountInfo.data);\n    const programdataAccountInfo = await connection.getAccountInfo(program.programdataAddress);\n    if (programdataAccountInfo === null) {\n        throw new Error(\"program data account not found\");\n    }\n    const { programData } = decodeUpgradeableLoaderState(programdataAccountInfo.data);\n    return programData;\n}\nconst UPGRADEABLE_LOADER_STATE_LAYOUT = borsh.rustEnum([\n    borsh.struct([], \"uninitialized\"),\n    borsh.struct([borsh.option(borsh.publicKey(), \"authorityAddress\")], \"buffer\"),\n    borsh.struct([borsh.publicKey(\"programdataAddress\")], \"program\"),\n    borsh.struct([\n        borsh.u64(\"slot\"),\n        borsh.option(borsh.publicKey(), \"upgradeAuthorityAddress\"),\n    ], \"programData\"),\n], undefined, borsh.u32());\nfunction decodeUpgradeableLoaderState(data) {\n    return UPGRADEABLE_LOADER_STATE_LAYOUT.decode(data);\n}\n\nvar registry = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    verifiedBuild: verifiedBuild,\n    fetchData: fetchData,\n    decodeUpgradeableLoaderState: decodeUpgradeableLoaderState\n});\n\nvar index = /*#__PURE__*/Object.freeze({\n    __proto__: null,\n    sha256: sha256,\n    rpc: rpc,\n    publicKey: pubkey,\n    bytes: index$1,\n    token: token,\n    features: features,\n    registry: registry\n});\n\nconst PROGRAM_LOG = \"Program log: \";\nconst PROGRAM_DATA = \"Program data: \";\nconst PROGRAM_LOG_START_INDEX = PROGRAM_LOG.length;\nconst PROGRAM_DATA_START_INDEX = PROGRAM_DATA.length;\nclass EventManager {\n    constructor(programId, provider, coder) {\n        this._programId = programId;\n        this._provider = provider;\n        this._eventParser = new EventParser(programId, coder);\n        this._eventCallbacks = new Map();\n        this._eventListeners = new Map();\n        this._listenerIdCount = 0;\n    }\n    addEventListener(eventName, callback, commitment) {\n        var _a;\n        let listener = this._listenerIdCount;\n        this._listenerIdCount += 1;\n        // Store the listener into the event map.\n        if (!this._eventListeners.has(eventName)) {\n            this._eventListeners.set(eventName, []);\n        }\n        this._eventListeners.set(eventName, ((_a = this._eventListeners.get(eventName)) !== null && _a !== void 0 ? _a : []).concat(listener));\n        // Store the callback into the listener map.\n        this._eventCallbacks.set(listener, [eventName, callback]);\n        // Create the subscription singleton, if needed.\n        if (this._onLogsSubscriptionId !== undefined) {\n            return listener;\n        }\n        this._onLogsSubscriptionId = this._provider.connection.onLogs(this._programId, (logs, ctx) => {\n            if (logs.err) {\n                return;\n            }\n            for (const event of this._eventParser.parseLogs(logs.logs)) {\n                const allListeners = this._eventListeners.get(event.name);\n                if (allListeners) {\n                    allListeners.forEach((listener) => {\n                        const listenerCb = this._eventCallbacks.get(listener);\n                        if (listenerCb) {\n                            const [, callback] = listenerCb;\n                            callback(event.data, ctx.slot, logs.signature);\n                        }\n                    });\n                }\n            }\n        }, commitment);\n        return listener;\n    }\n    async removeEventListener(listener) {\n        // Get the callback.\n        const callback = this._eventCallbacks.get(listener);\n        if (!callback) {\n            throw new Error(`Event listener ${listener} doesn't exist!`);\n        }\n        const [eventName] = callback;\n        // Get the listeners.\n        let listeners = this._eventListeners.get(eventName);\n        if (!listeners) {\n            throw new Error(`Event listeners don't exist for ${eventName}!`);\n        }\n        // Update both maps.\n        this._eventCallbacks.delete(listener);\n        listeners = listeners.filter((l) => l !== listener);\n        this._eventListeners.set(eventName, listeners);\n        if (listeners.length === 0) {\n            this._eventListeners.delete(eventName);\n        }\n        // Kill the websocket connection if all listeners have been removed.\n        if (this._eventCallbacks.size === 0) {\n            if (this._eventListeners.size !== 0) {\n                throw new Error(`Expected event listeners size to be 0 but got ${this._eventListeners.size}`);\n            }\n            if (this._onLogsSubscriptionId !== undefined) {\n                await this._provider.connection.removeOnLogsListener(this._onLogsSubscriptionId);\n                this._onLogsSubscriptionId = undefined;\n            }\n        }\n    }\n}\nclass EventParser {\n    constructor(programId, coder) {\n        this.coder = coder;\n        this.programId = programId;\n    }\n    // Each log given, represents an array of messages emitted by\n    // a single transaction, which can execute many different programs across\n    // CPI boundaries. However, the subscription is only interested in the\n    // events emitted by *this* program. In achieving this, we keep track of the\n    // program execution context by parsing each log and looking for a CPI\n    // `invoke` call. If one exists, we know a new program is executing. So we\n    // push the programId onto a stack and switch the program context. This\n    // allows us to track, for a given log, which program was executing during\n    // its emission, thereby allowing us to know if a given log event was\n    // emitted by *this* program. If it was, then we parse the raw string and\n    // emit the event if the string matches the event being subscribed to.\n    *parseLogs(logs, errorOnDecodeFailure = false) {\n        const logScanner = new LogScanner(logs);\n        const execution = new ExecutionContext();\n        let log = logScanner.next();\n        while (log !== null) {\n            let [event, newProgram, didPop] = this.handleLog(execution, log, errorOnDecodeFailure);\n            if (event) {\n                yield event;\n            }\n            if (newProgram) {\n                execution.push(newProgram);\n            }\n            if (didPop) {\n                execution.pop();\n            }\n            log = logScanner.next();\n        }\n    }\n    // Main log handler. Returns a three element array of the event, the\n    // next program that was invoked for CPI, and a boolean indicating if\n    // a program has completed execution (and thus should be popped off the\n    // execution stack).\n    handleLog(execution, log, errorOnDecodeFailure) {\n        // Executing program is this program.\n        if (execution.stack.length > 0 &&\n            execution.program() === this.programId.toString()) {\n            return this.handleProgramLog(log, errorOnDecodeFailure);\n        }\n        // Executing program is not this program.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs from *this* program.\n    handleProgramLog(log, errorOnDecodeFailure) {\n        // This is a `msg!` log or a `sol_log_data` log.\n        if (log.startsWith(PROGRAM_LOG) || log.startsWith(PROGRAM_DATA)) {\n            const logStr = log.startsWith(PROGRAM_LOG)\n                ? log.slice(PROGRAM_LOG_START_INDEX)\n                : log.slice(PROGRAM_DATA_START_INDEX);\n            const event = this.coder.events.decode(logStr);\n            if (errorOnDecodeFailure && event === null) {\n                throw new Error(`Unable to decode event ${logStr}`);\n            }\n            return [event, null, false];\n        }\n        // System log.\n        else {\n            return [null, ...this.handleSystemLog(log)];\n        }\n    }\n    // Handles logs when the current program being executing is *not* this.\n    handleSystemLog(log) {\n        // System component.\n        const logStart = log.split(\":\")[0];\n        // Did the program finish executing?\n        if (logStart.match(/^Program (.*) success/g) !== null) {\n            return [null, true];\n            // Recursive call.\n        }\n        else if (logStart.startsWith(`Program ${this.programId.toString()} invoke`)) {\n            return [this.programId.toString(), false];\n        }\n        // CPI call.\n        else if (logStart.includes(\"invoke\")) {\n            return [\"cpi\", false]; // Any string will do.\n        }\n        else {\n            return [null, false];\n        }\n    }\n}\n// Stack frame execution context, allowing one to track what program is\n// executing for a given log.\nclass ExecutionContext {\n    constructor() {\n        this.stack = [];\n    }\n    program() {\n        if (!this.stack.length) {\n            throw new Error(\"Expected the stack to have elements\");\n        }\n        return this.stack[this.stack.length - 1];\n    }\n    push(newProgram) {\n        this.stack.push(newProgram);\n    }\n    pop() {\n        if (!this.stack.length) {\n            throw new Error(\"Expected the stack to have elements\");\n        }\n        this.stack.pop();\n    }\n}\nclass LogScanner {\n    constructor(logs) {\n        this.logs = logs;\n    }\n    next() {\n        if (this.logs.length === 0) {\n            return null;\n        }\n        let l = this.logs[0];\n        this.logs = this.logs.slice(1);\n        return l;\n    }\n}\n\nfunction splitArgsAndCtx(idlIx, args) {\n    var _a, _b;\n    let options = {};\n    const inputLen = idlIx.args ? idlIx.args.length : 0;\n    if (args.length > inputLen) {\n        if (args.length !== inputLen + 1) {\n            throw new Error(`provided too many arguments ${args} to instruction ${idlIx === null || idlIx === void 0 ? void 0 : idlIx.name} expecting: ${(_b = (_a = idlIx.args) === null || _a === void 0 ? void 0 : _a.map((a) => a.name)) !== null && _b !== void 0 ? _b : []}`);\n        }\n        options = args.pop();\n    }\n    return [args, options];\n}\n\nclass InstructionNamespaceFactory {\n    static build(idlIx, encodeFn, programId) {\n        if (idlIx.name === \"_inner\") {\n            throw new IdlError(\"the _inner name is reserved\");\n        }\n        const ix = (...args) => {\n            const [ixArgs, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            validateAccounts(idlIx.accounts, ctx.accounts);\n            validateInstruction(idlIx, ...args);\n            const keys = ix.accounts(ctx.accounts);\n            if (ctx.remainingAccounts !== undefined) {\n                keys.push(...ctx.remainingAccounts);\n            }\n            if (isSet(\"debug-logs\")) {\n                console.log(\"Outgoing account metas:\", keys);\n            }\n            return new TransactionInstruction({\n                keys,\n                programId,\n                data: encodeFn(idlIx.name, toInstruction(idlIx, ...ixArgs)),\n            });\n        };\n        // Utility fn for ordering the accounts for this instruction.\n        ix[\"accounts\"] = (accs) => {\n            return InstructionNamespaceFactory.accountsArray(accs, idlIx.accounts, programId, idlIx.name);\n        };\n        return ix;\n    }\n    static accountsArray(ctx, accounts, programId, ixName) {\n        if (!ctx) {\n            return [];\n        }\n        return accounts\n            .map((acc) => {\n            if (isCompositeAccounts(acc)) {\n                const rpcAccs = ctx[acc.name];\n                return InstructionNamespaceFactory.accountsArray(rpcAccs, acc.accounts, programId, ixName).flat();\n            }\n            let pubkey;\n            try {\n                pubkey = translateAddress(ctx[acc.name]);\n            }\n            catch (err) {\n                throw new Error(`Wrong input type for account \"${acc.name}\" in the instruction accounts object${ixName !== undefined ? ' for instruction \"' + ixName + '\"' : \"\"}. Expected PublicKey or string.`);\n            }\n            const isOptional = acc.optional && pubkey.equals(programId);\n            const isWritable = Boolean(acc.writable && !isOptional);\n            const isSigner = Boolean(acc.signer && !isOptional);\n            return {\n                pubkey,\n                isWritable,\n                isSigner,\n            };\n        })\n            .flat();\n    }\n}\n// Throws error if any argument required for the `ix` is not given.\nfunction validateInstruction(ix, ...args) {\n    // todo\n}\n\nclass TransactionFactory {\n    static build(idlIx, ixFn) {\n        const txFn = (...args) => {\n            var _a, _b, _c;\n            const [, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            const tx = new Transaction();\n            if (ctx.preInstructions && ctx.instructions) {\n                throw new Error(\"instructions is deprecated, use preInstructions\");\n            }\n            (_a = ctx.preInstructions) === null || _a === void 0 ? void 0 : _a.forEach((ix) => tx.add(ix));\n            (_b = ctx.instructions) === null || _b === void 0 ? void 0 : _b.forEach((ix) => tx.add(ix));\n            tx.add(ixFn(...args));\n            (_c = ctx.postInstructions) === null || _c === void 0 ? void 0 : _c.forEach((ix) => tx.add(ix));\n            return tx;\n        };\n        return txFn;\n    }\n}\n\nclass RpcFactory {\n    static build(idlIx, txFn, idlErrors, provider) {\n        const rpc = async (...args) => {\n            var _a;\n            const tx = txFn(...args);\n            const [, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            if (provider.sendAndConfirm === undefined) {\n                throw new Error(\"This function requires 'Provider.sendAndConfirm' to be implemented.\");\n            }\n            try {\n                return await provider.sendAndConfirm(tx, (_a = ctx.signers) !== null && _a !== void 0 ? _a : [], ctx.options);\n            }\n            catch (err) {\n                throw translateError(err, idlErrors);\n            }\n        };\n        return rpc;\n    }\n}\n\nclass AccountFactory {\n    static build(idl, coder, programId, provider) {\n        var _a;\n        return ((_a = idl.accounts) !== null && _a !== void 0 ? _a : []).reduce((accountFns, acc) => {\n            accountFns[acc.name] = new AccountClient(idl, acc, programId, provider, coder);\n            return accountFns;\n        }, {});\n    }\n}\nclass AccountClient {\n    /**\n     * Returns the number of bytes in this account.\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * Returns the program ID owning all accounts.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * Returns the client's wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * Returns the coder.\n     */\n    get coder() {\n        return this._coder;\n    }\n    constructor(idl, idlAccount, programId, provider, coder) {\n        this._idlAccount = idlAccount;\n        this._programId = programId;\n        this._provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(idl);\n        this._size = this._coder.accounts.size(idlAccount.name);\n    }\n    /**\n     * Returns a deserialized account, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetchNullable(address, commitment) {\n        const { data } = await this.fetchNullableAndContext(address, commitment);\n        return data;\n    }\n    /**\n     * Returns a deserialized account along with the associated rpc response context, returning null if it doesn't exist.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetchNullableAndContext(address, commitment) {\n        const accountInfo = await this.getAccountInfoAndContext(address, commitment);\n        const { value, context } = accountInfo;\n        return {\n            data: value && value.data.length !== 0\n                ? this._coder.accounts.decode(this._idlAccount.name, value.data)\n                : null,\n            context,\n        };\n    }\n    /**\n     * Returns a deserialized account.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetch(address, commitment) {\n        const { data } = await this.fetchNullableAndContext(address, commitment);\n        if (data === null) {\n            throw new Error(`Account does not exist or has no data ${address.toString()}`);\n        }\n        return data;\n    }\n    /**\n     * Returns a deserialized account along with the associated rpc response context.\n     *\n     * @param address The address of the account to fetch.\n     */\n    async fetchAndContext(address, commitment) {\n        const { data, context } = await this.fetchNullableAndContext(address, commitment);\n        if (data === null) {\n            throw new Error(`Account does not exist ${address.toString()}`);\n        }\n        return { data, context };\n    }\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */\n    async fetchMultiple(addresses, commitment) {\n        const accounts = await this.fetchMultipleAndContext(addresses, commitment);\n        return accounts.map((account) => (account ? account.data : null));\n    }\n    /**\n     * Returns multiple deserialized accounts.\n     * Accounts not found or with wrong discriminator are returned as null.\n     *\n     * @param addresses The addresses of the accounts to fetch.\n     */\n    async fetchMultipleAndContext(addresses, commitment) {\n        const accounts = await getMultipleAccountsAndContext(this._provider.connection, addresses.map((address) => translateAddress(address)), commitment);\n        // Decode accounts where discriminator is correct, null otherwise\n        return accounts.map((result) => {\n            if (result == null) {\n                return null;\n            }\n            const { account, context } = result;\n            return {\n                data: this._coder.accounts.decode(this._idlAccount.name, account.data),\n                context,\n            };\n        });\n    }\n    /**\n     * Returns all instances of this account type for the program.\n     *\n     * @param filters User-provided filters to narrow the results from `connection.getProgramAccounts`.\n     *\n     *                When filters are not defined this method returns all\n     *                the account instances.\n     *\n     *                When filters are of type `Buffer`, the filters are appended\n     *                after the discriminator.\n     *\n     *                When filters are of type `GetProgramAccountsFilter[]`,\n     *                filters are appended after the discriminator filter.\n     */\n    async all(filters) {\n        const filter = this.coder.accounts.memcmp(this._idlAccount.name, filters instanceof Buffer ? filters : undefined);\n        const coderFilters = [];\n        if ((filter === null || filter === void 0 ? void 0 : filter.offset) != undefined && (filter === null || filter === void 0 ? void 0 : filter.bytes) != undefined) {\n            coderFilters.push({\n                memcmp: { offset: filter.offset, bytes: filter.bytes },\n            });\n        }\n        if ((filter === null || filter === void 0 ? void 0 : filter.dataSize) != undefined) {\n            coderFilters.push({ dataSize: filter.dataSize });\n        }\n        let resp = await this._provider.connection.getProgramAccounts(this._programId, {\n            commitment: this._provider.connection.commitment,\n            filters: [...coderFilters, ...(Array.isArray(filters) ? filters : [])],\n        });\n        return resp.map(({ pubkey, account }) => {\n            return {\n                publicKey: pubkey,\n                account: this._coder.accounts.decode(this._idlAccount.name, account.data),\n            };\n        });\n    }\n    /**\n     * Returns an `EventEmitter` emitting a \"change\" event whenever the account\n     * changes.\n     */\n    subscribe(address, commitment) {\n        const sub = subscriptions.get(address.toString());\n        if (sub) {\n            return sub.ee;\n        }\n        const ee = new EventEmitter();\n        address = translateAddress(address);\n        const listener = this._provider.connection.onAccountChange(address, (acc) => {\n            const account = this._coder.accounts.decode(this._idlAccount.name, acc.data);\n            ee.emit(\"change\", account);\n        }, commitment);\n        subscriptions.set(address.toString(), {\n            ee,\n            listener,\n        });\n        return ee;\n    }\n    /**\n     * Unsubscribes from the account at the given address.\n     */\n    async unsubscribe(address) {\n        let sub = subscriptions.get(address.toString());\n        if (!sub) {\n            console.warn(\"Address is not subscribed\");\n            return;\n        }\n        if (subscriptions) {\n            await this._provider.connection\n                .removeAccountChangeListener(sub.listener)\n                .then(() => {\n                subscriptions.delete(address.toString());\n            })\n                .catch(console.error);\n        }\n    }\n    /**\n     * Returns an instruction for creating this account.\n     */\n    async createInstruction(signer, sizeOverride) {\n        const size = this.size;\n        if (this._provider.publicKey === undefined) {\n            throw new Error(\"This function requires the Provider interface implementor to have a 'publicKey' field.\");\n        }\n        return SystemProgram.createAccount({\n            fromPubkey: this._provider.publicKey,\n            newAccountPubkey: signer.publicKey,\n            space: sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size,\n            lamports: await this._provider.connection.getMinimumBalanceForRentExemption(sizeOverride !== null && sizeOverride !== void 0 ? sizeOverride : size),\n            programId: this._programId,\n        });\n    }\n    async getAccountInfo(address, commitment) {\n        return await this._provider.connection.getAccountInfo(translateAddress(address), commitment);\n    }\n    async getAccountInfoAndContext(address, commitment) {\n        return await this._provider.connection.getAccountInfoAndContext(translateAddress(address), commitment);\n    }\n}\n// Tracks all subscriptions.\nconst subscriptions = new Map();\n\nclass SimulateFactory {\n    static build(idlIx, txFn, idlErrors, provider, coder, programId, idl) {\n        const simulate = async (...args) => {\n            var _a;\n            const tx = txFn(...args);\n            const [, ctx] = splitArgsAndCtx(idlIx, [...args]);\n            let resp = undefined;\n            if (provider.simulate === undefined) {\n                throw new Error(\"This function requires 'Provider.simulate' to be implemented.\");\n            }\n            try {\n                resp = await provider.simulate(tx, ctx.signers, (_a = ctx.options) === null || _a === void 0 ? void 0 : _a.commitment);\n            }\n            catch (err) {\n                throw translateError(err, idlErrors);\n            }\n            if (resp === undefined) {\n                throw new Error(\"Unable to simulate transaction\");\n            }\n            const logs = resp.logs;\n            if (!logs) {\n                throw new Error(\"Simulated logs not found\");\n            }\n            const events = [];\n            if (idl.events) {\n                let parser = new EventParser(programId, coder);\n                for (const event of parser.parseLogs(logs)) {\n                    events.push(event);\n                }\n            }\n            return { events, raw: logs };\n        };\n        return simulate;\n    }\n}\n\nfunction uint64(property) {\n    return new WrappedLayout(blob(8), (b) => u64.fromBuffer(b), (n) => n.toBuffer(), property);\n}\nfunction publicKey(property) {\n    return new WrappedLayout(blob(32), (b) => new PublicKey(b), (key) => key.toBuffer(), property);\n}\nfunction coption(layout, property) {\n    return new COptionLayout(layout, property);\n}\nclass WrappedLayout extends Layout_2 {\n    constructor(layout, decoder, encoder, property) {\n        super(layout.span, property);\n        this.layout = layout;\n        this.decoder = decoder;\n        this.encoder = encoder;\n    }\n    decode(b, offset) {\n        return this.decoder(this.layout.decode(b, offset));\n    }\n    encode(src, b, offset) {\n        return this.layout.encode(this.encoder(src), b, offset);\n    }\n    getSpan(b, offset) {\n        return this.layout.getSpan(b, offset);\n    }\n}\nclass COptionLayout extends Layout_2 {\n    constructor(layout, property) {\n        super(-1, property);\n        this.layout = layout;\n        this.discriminator = u32();\n    }\n    encode(src, b, offset = 0) {\n        if (src === null || src === undefined) {\n            return this.layout.span + this.discriminator.encode(0, b, offset);\n        }\n        this.discriminator.encode(1, b, offset);\n        return this.layout.encode(src, b, offset + 4) + 4;\n    }\n    decode(b, offset = 0) {\n        const discriminator = this.discriminator.decode(b, offset);\n        if (discriminator === 0) {\n            return null;\n        }\n        else if (discriminator === 1) {\n            return this.layout.decode(b, offset + 4);\n        }\n        throw new Error(\"Invalid coption \" + this.layout.property);\n    }\n    getSpan(b, offset = 0) {\n        return this.layout.getSpan(b, offset + 4) + 4;\n    }\n}\nclass u64 extends BN {\n    /**\n     * Convert to Buffer representation\n     */\n    toBuffer() {\n        const a = super.toArray().reverse();\n        const b = Buffer.from(a);\n        if (b.length === 8) {\n            return b;\n        }\n        if (b.length >= 8) {\n            throw new Error(\"u64 too large\");\n        }\n        const zeroPad = Buffer.alloc(8);\n        b.copy(zeroPad);\n        return zeroPad;\n    }\n    /**\n     * Construct a u64 from Buffer representation\n     */\n    static fromBuffer(buffer) {\n        if (buffer.length !== 8) {\n            throw new Error(`Invalid buffer length: ${buffer.length}`);\n        }\n        return new u64([...buffer]\n            .reverse()\n            .map((i) => `00${i.toString(16)}`.slice(-2))\n            .join(\"\"), 16);\n    }\n}\nconst TOKEN_ACCOUNT_LAYOUT = struct([\n    publicKey(\"mint\"),\n    publicKey(\"owner\"),\n    uint64(\"amount\"),\n    coption(publicKey(), \"delegate\"),\n    ((p) => {\n        const U = union(u8(\"discriminator\"), null, p);\n        U.addVariant(0, struct([]), \"uninitialized\");\n        U.addVariant(1, struct([]), \"initialized\");\n        U.addVariant(2, struct([]), \"frozen\");\n        return U;\n    })(\"state\"),\n    coption(uint64(), \"isNative\"),\n    uint64(\"delegatedAmount\"),\n    coption(publicKey(), \"closeAuthority\"),\n]);\nfunction decodeTokenAccount(b) {\n    return TOKEN_ACCOUNT_LAYOUT.decode(b);\n}\n\n// Populates a given accounts context with PDAs and common missing accounts.\nclass AccountsResolver {\n    constructor(_args, _accounts, _provider, _programId, _idlIx, accountNamespace, _idlTypes, _customResolver) {\n        this._args = _args;\n        this._accounts = _accounts;\n        this._provider = _provider;\n        this._programId = _programId;\n        this._idlIx = _idlIx;\n        this._idlTypes = _idlTypes;\n        this._customResolver = _customResolver;\n        this._accountStore = new AccountStore(_provider, accountNamespace, _programId);\n    }\n    args(args) {\n        this._args = args;\n    }\n    // Note: We serially resolve PDAs one by one rather than doing them\n    //       in parallel because there can be dependencies between\n    //       addresses. That is, one PDA can be used as a seed in another.\n    async resolve() {\n        this.resolveEventCpi(this._idlIx.accounts);\n        this.resolveConst(this._idlIx.accounts);\n        // Auto populate pdas and relations until we stop finding new accounts\n        let depth = 0;\n        while ((await this.resolvePdasAndRelations(this._idlIx.accounts)) +\n            (await this.resolveCustom()) >\n            0) {\n            depth++;\n            if (depth === 16) {\n                const isResolvable = (acc) => {\n                    if (!isCompositeAccounts(acc)) {\n                        return !!(acc.address || acc.pda || acc.relations);\n                    }\n                    return acc.accounts.some(isResolvable);\n                };\n                const getPaths = (accs, path = [], paths = []) => {\n                    for (const acc of accs) {\n                        if (isCompositeAccounts(acc)) {\n                            paths.push(...getPaths(acc.accounts, [...path, acc.name]));\n                        }\n                        else {\n                            paths.push([...path, acc.name]);\n                        }\n                    }\n                    return paths;\n                };\n                const resolvableAccs = this._idlIx.accounts.filter(isResolvable);\n                const unresolvedAccs = getPaths(resolvableAccs)\n                    .filter((path) => !this.get(path))\n                    .map((path) => path.reduce((acc, p) => acc + \".\" + p))\n                    .map((acc) => `\\`${acc}\\``)\n                    .join(\", \");\n                throw new Error([\n                    `Reached maximum depth for account resolution.`,\n                    `Unresolved accounts: ${unresolvedAccs}`,\n                ].join(\" \"));\n            }\n        }\n    }\n    resolveOptionals(accounts) {\n        Object.assign(this._accounts, this.resolveOptionalsHelper(accounts, this._idlIx.accounts));\n    }\n    get(path) {\n        // Only return if pubkey\n        const ret = path.reduce((acc, subPath) => acc && acc[subPath], this._accounts);\n        if (ret && ret.toBase58) {\n            return ret;\n        }\n    }\n    set(path, value) {\n        let cur = this._accounts;\n        path.forEach((p, i) => {\n            var _a;\n            const isLast = i === path.length - 1;\n            if (isLast) {\n                cur[p] = value;\n            }\n            cur[p] = (_a = cur[p]) !== null && _a !== void 0 ? _a : {};\n            cur = cur[p];\n        });\n    }\n    resolveOptionalsHelper(partialAccounts, accounts) {\n        const nestedAccountsGeneric = {};\n        // Looping through accountItem array instead of on partialAccounts, so\n        // we only traverse array once\n        for (const accountItem of accounts) {\n            const accountName = accountItem.name;\n            const partialAccount = partialAccounts[accountName];\n            // Skip if the account isn't included (thus would be undefined)\n            if (partialAccount === undefined)\n                continue;\n            if (isPartialAccounts(partialAccount)) {\n                // is compound accounts, recurse one level deeper\n                if (isCompositeAccounts(accountItem)) {\n                    nestedAccountsGeneric[accountName] = this.resolveOptionalsHelper(partialAccount, accountItem[\"accounts\"]);\n                }\n                else {\n                    // Here we try our best to recover gracefully. If there are optionals we can't check, we will fail then.\n                    nestedAccountsGeneric[accountName] = flattenPartialAccounts(partialAccount, true);\n                }\n            }\n            else {\n                // if not compound accounts, do null/optional check and proceed\n                if (partialAccount !== null) {\n                    nestedAccountsGeneric[accountName] = translateAddress(partialAccount);\n                }\n                else if (accountItem[\"optional\"]) {\n                    nestedAccountsGeneric[accountName] = this._programId;\n                }\n            }\n        }\n        return nestedAccountsGeneric;\n    }\n    async resolveCustom() {\n        if (this._customResolver) {\n            const { accounts, resolved } = await this._customResolver({\n                args: this._args,\n                accounts: this._accounts,\n                provider: this._provider,\n                programId: this._programId,\n                idlIx: this._idlIx,\n            });\n            this._accounts = accounts;\n            return resolved;\n        }\n        return 0;\n    }\n    /**\n     * Resolve event CPI accounts `eventAuthority` and `program`.\n     *\n     * Accounts will only be resolved if they are declared next to each other to\n     * reduce the chance of name collision.\n     */\n    resolveEventCpi(accounts, path = []) {\n        for (const i in accounts) {\n            const accountOrAccounts = accounts[i];\n            if (isCompositeAccounts(accountOrAccounts)) {\n                this.resolveEventCpi(accountOrAccounts.accounts, [\n                    ...path,\n                    accountOrAccounts.name,\n                ]);\n            }\n            // Validate next index exists\n            const nextIndex = +i + 1;\n            if (nextIndex === accounts.length)\n                return;\n            const currentName = accounts[i].name;\n            const nextName = accounts[nextIndex].name;\n            // Populate event CPI accounts if they exist\n            if (currentName === \"eventAuthority\" && nextName === \"program\") {\n                const currentPath = [...path, currentName];\n                const nextPath = [...path, nextName];\n                if (!this.get(currentPath)) {\n                    this.set(currentPath, PublicKey.findProgramAddressSync([Buffer.from(\"__event_authority\")], this._programId)[0]);\n                }\n                if (!this.get(nextPath)) {\n                    this.set(nextPath, this._programId);\n                }\n                return;\n            }\n        }\n    }\n    resolveConst(accounts, path = []) {\n        for (const accountOrAccounts of accounts) {\n            const name = accountOrAccounts.name;\n            if (isCompositeAccounts(accountOrAccounts)) {\n                this.resolveConst(accountOrAccounts.accounts, [...path, name]);\n            }\n            else {\n                const account = accountOrAccounts;\n                if ((account.signer || account.address) && !this.get([...path, name])) {\n                    // Default signers to the provider\n                    if (account.signer) {\n                        if (!this._provider.wallet) {\n                            throw new Error(\"This function requires the `Provider` interface implementor to have a `wallet` field.\");\n                        }\n                        this.set([...path, name], this._provider.wallet.publicKey);\n                    }\n                    // Set based on `address` field\n                    if (account.address) {\n                        this.set([...path, name], translateAddress(account.address));\n                    }\n                }\n            }\n        }\n    }\n    async resolvePdasAndRelations(accounts, path = []) {\n        let found = 0;\n        for (const accountOrAccounts of accounts) {\n            const name = accountOrAccounts.name;\n            if (isCompositeAccounts(accountOrAccounts)) {\n                found += await this.resolvePdasAndRelations(accountOrAccounts.accounts, [...path, name]);\n            }\n            else {\n                const account = accountOrAccounts;\n                if ((account.pda || account.relations) && !this.get([...path, name])) {\n                    found++;\n                    // Accounts might not get resolved successfully if a seed depends on\n                    // another seed to be resolved *and* the accounts for resolution are\n                    // out of order. In this case, skip the accounts that throw in order\n                    // to resolve those accounts later.\n                    try {\n                        if (account.pda) {\n                            const seeds = await Promise.all(account.pda.seeds.map((seed) => this.toBuffer(seed, path)));\n                            if (seeds.some((seed) => !seed)) {\n                                continue;\n                            }\n                            const programId = await this.parseProgramId(account, path);\n                            const [pubkey] = PublicKey.findProgramAddressSync(seeds, programId);\n                            this.set([...path, name], pubkey);\n                        }\n                    }\n                    catch { }\n                    try {\n                        if (account.relations) {\n                            const accountKey = this.get([...path, account.relations[0]]);\n                            if (accountKey) {\n                                const account = await this._accountStore.fetchAccount({\n                                    publicKey: accountKey,\n                                });\n                                this.set([...path, name], account[name]);\n                            }\n                        }\n                    }\n                    catch { }\n                }\n            }\n        }\n        return found;\n    }\n    async parseProgramId(account, path = []) {\n        var _a;\n        if (!((_a = account.pda) === null || _a === void 0 ? void 0 : _a.program)) {\n            return this._programId;\n        }\n        const buf = await this.toBuffer(account.pda.program, path);\n        if (!buf) {\n            throw new Error(`Program seed not resolved: ${account.name}`);\n        }\n        return new PublicKey(buf);\n    }\n    async toBuffer(seed, path = []) {\n        switch (seed.kind) {\n            case \"const\":\n                return this.toBufferConst(seed);\n            case \"arg\":\n                return await this.toBufferArg(seed);\n            case \"account\":\n                return await this.toBufferAccount(seed, path);\n            default:\n                throw new Error(`Unexpected seed: ${seed}`);\n        }\n    }\n    toBufferConst(seed) {\n        return this.toBufferValue(\"bytes\", seed.value);\n    }\n    async toBufferArg(seed) {\n        const [name, ...path] = seed.path.split(\".\");\n        const index = this._idlIx.args.findIndex((arg) => arg.name === name);\n        if (index === -1) {\n            throw new Error(`Unable to find argument for seed: ${name}`);\n        }\n        const value = path.reduce((acc, path) => (acc !== null && acc !== void 0 ? acc : {})[path], this._args[index]);\n        if (value === undefined) {\n            return;\n        }\n        const type = this.getType(this._idlIx.args[index].type, path);\n        return this.toBufferValue(type, value);\n    }\n    async toBufferAccount(seed, path = []) {\n        const [name, ...paths] = seed.path.split(\".\");\n        const fieldPubkey = this.get([...path, name]);\n        if (!fieldPubkey)\n            return;\n        // The seed is a pubkey of the account.\n        if (!paths.length) {\n            return this.toBufferValue(\"pubkey\", fieldPubkey);\n        }\n        if (!seed.account) {\n            throw new Error(`Seed account is required in order to resolve type: ${seed.path}`);\n        }\n        // The key is account data.\n        //\n        // Fetch and deserialize it.\n        const account = await this._accountStore.fetchAccount({\n            publicKey: fieldPubkey,\n            name: seed.account,\n        });\n        // Dereference all fields in the path to get the field value\n        // used in the seed.\n        let accountValue = account;\n        let currentPaths = paths;\n        while (currentPaths.length > 0) {\n            accountValue = accountValue[currentPaths[0]];\n            currentPaths = currentPaths.slice(1);\n        }\n        if (accountValue === undefined)\n            return;\n        const type = this.getType({ defined: { name: seed.account } }, paths);\n        return this.toBufferValue(type, accountValue);\n    }\n    /**\n     * Converts the given idl valaue into a Buffer. The values here must be\n     * primitives, e.g. no structs.\n     */\n    toBufferValue(type, value) {\n        switch (type) {\n            case \"u8\":\n            case \"i8\":\n                return Buffer.from([value]);\n            case \"u16\":\n            case \"i16\":\n                return new BN(value).toArrayLike(Buffer, \"le\", 2);\n            case \"u32\":\n            case \"i32\":\n                return new BN(value).toArrayLike(Buffer, \"le\", 4);\n            case \"u64\":\n            case \"i64\":\n                return new BN(value).toArrayLike(Buffer, \"le\", 8);\n            case \"u128\":\n            case \"i128\":\n                return new BN(value).toArrayLike(Buffer, \"le\", 16);\n            case \"u256\":\n            case \"i256\":\n                return new BN(value).toArrayLike(Buffer, \"le\", 32);\n            case \"string\":\n                return Buffer.from(value);\n            case \"pubkey\":\n                return value.toBuffer();\n            case \"bytes\":\n                return Buffer.from(value);\n            default:\n                if (type === null || type === void 0 ? void 0 : type.array) {\n                    return Buffer.from(value);\n                }\n                throw new Error(`Unexpected seed type: ${type}`);\n        }\n    }\n    /**\n     * Recursively get the type at some path of either a primitive or a user\n     * defined struct.\n     */\n    getType(type, path = []) {\n        var _a;\n        const typeName = (_a = type === null || type === void 0 ? void 0 : type.defined) === null || _a === void 0 ? void 0 : _a.name;\n        if (typeName) {\n            // Handle token account separately\n            if (typeName === \"tokenAccount\") {\n                switch (path.at(0)) {\n                    case \"mint\":\n                    case \"owner\":\n                        return \"pubkey\";\n                    case \"amount\":\n                    case \"delagatedAmount\":\n                        return \"u64\";\n                    default:\n                        throw new Error(`Unknown token account path: ${path}`);\n                }\n            }\n            const definedType = this._idlTypes.find((t) => t.name === typeName);\n            if (!definedType) {\n                throw new Error(`Type not found: ${typeName}`);\n            }\n            // Only named structs are supported\n            const [fieldName, ...subPath] = path;\n            const fields = definedType.type\n                .fields;\n            const field = fields.find((field) => field.name === fieldName);\n            if (!field) {\n                throw new Error(`Field not found: ${fieldName}`);\n            }\n            return this.getType(field.type, subPath);\n        }\n        return type;\n    }\n}\n// TODO: this should be configurable to avoid unnecessary requests.\nclass AccountStore {\n    constructor(_provider, accounts, programId) {\n        this._provider = _provider;\n        this._cache = new Map();\n        this._idls = {};\n        this._idls[programId.toBase58()] = accounts;\n    }\n    async fetchAccount({ publicKey, name, }) {\n        const address = publicKey.toBase58();\n        if (!this._cache.has(address)) {\n            const accountInfo = await this._provider.connection.getAccountInfo(publicKey);\n            if (accountInfo === null) {\n                throw new Error(`Account not found: ${address}`);\n            }\n            if (name === \"tokenAccount\") {\n                const account = decodeTokenAccount(accountInfo.data);\n                this._cache.set(address, account);\n            }\n            else {\n                const accounts = await this.getAccountsNs(accountInfo.owner);\n                if (accounts) {\n                    const accountNs = Object.values(accounts)[0];\n                    if (accountNs) {\n                        const account = accountNs.coder.accounts.decodeAny(accountInfo.data);\n                        this._cache.set(address, account);\n                    }\n                }\n            }\n        }\n        return this._cache.get(address);\n    }\n    async getAccountsNs(programId) {\n        const programIdStr = programId.toBase58();\n        if (!this._idls[programIdStr]) {\n            const idl = await Program.fetchIdl(programId, this._provider);\n            if (idl) {\n                const program = new Program(idl, this._provider);\n                this._idls[programIdStr] = program.account;\n            }\n        }\n        return this._idls[programIdStr];\n    }\n}\n\nclass MethodsBuilderFactory {\n    static build(provider, programId, idlIx, ixFn, txFn, rpcFn, simulateFn, viewFn, accountNamespace, idlTypes, customResolver) {\n        return (...args) => new MethodsBuilder(args, ixFn, txFn, rpcFn, simulateFn, viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);\n    }\n}\nfunction isPartialAccounts(partialAccount) {\n    return (typeof partialAccount === \"object\" &&\n        partialAccount !== null &&\n        !(\"_bn\" in partialAccount) // Ensures not a pubkey\n    );\n}\nfunction flattenPartialAccounts(partialAccounts, throwOnNull) {\n    const toReturn = {};\n    for (const accountName in partialAccounts) {\n        const account = partialAccounts[accountName];\n        if (account === null) {\n            if (throwOnNull)\n                throw new Error(\"Failed to resolve optionals due to IDL type mismatch with input accounts!\");\n            continue;\n        }\n        toReturn[accountName] = isPartialAccounts(account)\n            ? flattenPartialAccounts(account, true)\n            : translateAddress(account);\n    }\n    return toReturn;\n}\nclass MethodsBuilder {\n    constructor(_args, _ixFn, _txFn, _rpcFn, _simulateFn, _viewFn, provider, programId, idlIx, accountNamespace, idlTypes, customResolver) {\n        this._args = _args;\n        this._ixFn = _ixFn;\n        this._txFn = _txFn;\n        this._rpcFn = _rpcFn;\n        this._simulateFn = _simulateFn;\n        this._viewFn = _viewFn;\n        this._accounts = {};\n        this._remainingAccounts = [];\n        this._signers = [];\n        this._preInstructions = [];\n        this._postInstructions = [];\n        this._resolveAccounts = true;\n        this._accountsResolver = new AccountsResolver(_args, this._accounts, provider, programId, idlIx, accountNamespace, idlTypes, customResolver);\n    }\n    args(args) {\n        this._args = args;\n        this._accountsResolver.args(args);\n    }\n    /**\n     * Set instruction accounts with account resolution.\n     *\n     * This method only accepts accounts that cannot be resolved.\n     *\n     * See {@link accountsPartial} for overriding the account resolution or\n     * {@link accountsStrict} for strictly specifying all accounts.\n     */\n    accounts(accounts) {\n        // @ts-ignore\n        return this.accountsPartial(accounts);\n    }\n    /**\n     * Set instruction accounts with account resolution.\n     *\n     * There is no functional difference between this method and {@link accounts}\n     * method, the only difference is this method allows specifying all accounts\n     * even if they can be resolved. On the other hand, {@link accounts} method\n     * doesn't accept accounts that can be resolved.\n     */\n    accountsPartial(accounts) {\n        this._resolveAccounts = true;\n        this._accountsResolver.resolveOptionals(accounts);\n        return this;\n    }\n    /**\n     * Set instruction accounts without account resolution.\n     *\n     * All accounts strictly need to be specified when this method is used.\n     *\n     * See {@link accounts} and {@link accountsPartial} methods for automatically\n     * resolving accounts.\n     *\n     * @param accounts instruction accounts\n     */\n    accountsStrict(accounts) {\n        this._resolveAccounts = false;\n        this._accountsResolver.resolveOptionals(accounts);\n        return this;\n    }\n    /**\n     * Set instruction signers.\n     *\n     * Note that calling this method appends the given signers to the existing\n     * signers (instead of overriding them).\n     *\n     * @param signers signers to append\n     */\n    signers(signers) {\n        this._signers = this._signers.concat(signers);\n        return this;\n    }\n    /**\n     * Set remaining accounts.\n     *\n     * Note that calling this method appends the given accounts to the existing\n     * remaining accounts (instead of overriding them).\n     *\n     * @param accounts remaining accounts\n     */\n    remainingAccounts(accounts) {\n        this._remainingAccounts = this._remainingAccounts.concat(accounts);\n        return this;\n    }\n    /**\n     * Set previous instructions.\n     *\n     * See {@link postInstructions} to set the post instructions instead.\n     *\n     * @param ixs instructions\n     * @param prepend whether to prepend to the existing previous instructions\n     */\n    preInstructions(ixs, prepend = false) {\n        if (prepend) {\n            this._preInstructions = ixs.concat(this._preInstructions);\n        }\n        else {\n            this._preInstructions = this._preInstructions.concat(ixs);\n        }\n        return this;\n    }\n    /**\n     * Set post instructions.\n     *\n     * See {@link preInstructions} to set the previous instructions instead.\n     *\n     * @param ixs instructions\n     */\n    postInstructions(ixs) {\n        this._postInstructions = this._postInstructions.concat(ixs);\n        return this;\n    }\n    /**\n     * Get the public keys of the instruction accounts.\n     *\n     * The return type is an object with account names as keys and their public\n     * keys as their values.\n     *\n     * Note that an account key is `undefined` if the account hasn't yet been\n     * specified or resolved.\n     */\n    async pubkeys() {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._accounts;\n    }\n    /**\n     * Create an instruction based on the current configuration.\n     *\n     * See {@link transaction} to create a transaction instead.\n     *\n     * @returns the transaction instruction\n     */\n    async instruction() {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._ixFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n        });\n    }\n    /**\n     * Create a transaction based on the current configuration.\n     *\n     * This method doesn't send the created transaction. Use {@link rpc} method\n     * to conveniently send an confirm the configured transaction.\n     *\n     * See {@link instruction} to only create an instruction instead.\n     *\n     * @returns the transaction\n     */\n    async transaction() {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._txFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n        });\n    }\n    /**\n     * Simulate the configured transaction.\n     *\n     * @param options confirmation options\n     * @returns the simulation response\n     */\n    async simulate(options) {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._simulateFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n            options,\n        });\n    }\n    /**\n     * View the configured transaction.\n     *\n     * Note that to use this method, the instruction needs to return a value and\n     * all its accounts must be read-only.\n     *\n     * @param options confirmation options\n     * @returns the return value of the instruction\n     */\n    async view(options) {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        if (!this._viewFn) {\n            throw new Error([\n                \"Method does not support views.\",\n                \"The instruction should return a value, and its accounts must be read-only\",\n            ].join(\" \"));\n        }\n        // @ts-ignore\n        return this._viewFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n            options,\n        });\n    }\n    /**\n     * Send and confirm the configured transaction.\n     *\n     * See {@link rpcAndKeys} to both send the transaction and get the resolved\n     * account public keys.\n     *\n     * @param options confirmation options\n     * @returns the transaction signature\n     */\n    async rpc(options) {\n        if (this._resolveAccounts) {\n            await this._accountsResolver.resolve();\n        }\n        // @ts-ignore\n        return this._rpcFn(...this._args, {\n            accounts: this._accounts,\n            signers: this._signers,\n            remainingAccounts: this._remainingAccounts,\n            preInstructions: this._preInstructions,\n            postInstructions: this._postInstructions,\n            options,\n        });\n    }\n    /**\n     * Conveniently call both {@link rpc} and {@link pubkeys} methods.\n     *\n     * @param options confirmation options\n     * @returns the transaction signature and account public keys\n     */\n    async rpcAndKeys(options) {\n        return {\n            signature: await this.rpc(options),\n            pubkeys: (await this.pubkeys()),\n        };\n    }\n    /**\n     * Get instruction information necessary to include the instruction inside a\n     * transaction.\n     *\n     * # Example\n     *\n     * ```ts\n     * const { instruction, signers, pubkeys } = await method.prepare();\n     * ```\n     */\n    async prepare() {\n        return {\n            instruction: await this.instruction(),\n            signers: this._signers,\n            pubkeys: await this.pubkeys(),\n        };\n    }\n}\n\nclass ViewFactory {\n    static build(programId, idlIx, simulateFn, idl) {\n        const isWritable = idlIx.accounts.find((a) => a.writable);\n        const hasReturn = !!idlIx.returns;\n        if (isWritable || !hasReturn)\n            return;\n        const view = async (...args) => {\n            let simulationResult = await simulateFn(...args);\n            const returnPrefix = `Program return: ${programId} `;\n            let returnLog = simulationResult.raw.find((l) => l.startsWith(returnPrefix));\n            if (!returnLog) {\n                throw new Error(\"View expected return log\");\n            }\n            let returnData = decode(returnLog.slice(returnPrefix.length));\n            let returnType = idlIx.returns;\n            if (!returnType) {\n                throw new Error(\"View expected return type\");\n            }\n            const coder = IdlCoder.fieldLayout({ type: returnType }, idl.types);\n            return coder.decode(returnData);\n        };\n        return view;\n    }\n}\n\nclass NamespaceFactory {\n    /**\n     * Generates all namespaces for a given program.\n     */\n    static build(idl, coder, programId, provider, getCustomResolver) {\n        const rpc = {};\n        const instruction = {};\n        const transaction = {};\n        const simulate = {};\n        const methods = {};\n        const view = {};\n        const idlErrors = parseIdlErrors(idl);\n        const account = idl.accounts\n            ? AccountFactory.build(idl, coder, programId, provider)\n            : {};\n        idl.instructions.forEach((idlIx) => {\n            const ixItem = InstructionNamespaceFactory.build(idlIx, (ixName, ix) => coder.instruction.encode(ixName, ix), programId);\n            const txItem = TransactionFactory.build(idlIx, ixItem);\n            const rpcItem = RpcFactory.build(idlIx, txItem, idlErrors, provider);\n            const simulateItem = SimulateFactory.build(idlIx, txItem, idlErrors, provider, coder, programId, idl);\n            const viewItem = ViewFactory.build(programId, idlIx, simulateItem, idl);\n            const methodItem = MethodsBuilderFactory.build(provider, programId, idlIx, ixItem, txItem, rpcItem, simulateItem, viewItem, account, idl.types || [], getCustomResolver === null || getCustomResolver === void 0 ? void 0 : getCustomResolver(idlIx));\n            const name = idlIx.name;\n            instruction[name] = ixItem;\n            transaction[name] = txItem;\n            rpc[name] = rpcItem;\n            simulate[name] = simulateItem;\n            methods[name] = methodItem;\n            if (viewItem) {\n                view[name] = viewItem;\n            }\n        });\n        return [\n            rpc,\n            instruction,\n            transaction,\n            account,\n            simulate,\n            methods,\n            view,\n        ];\n    }\n}\n\n/**\n * ## Program\n *\n * Program provides the IDL deserialized client representation of an Anchor\n * program.\n *\n * This API is the one stop shop for all things related to communicating with\n * on-chain programs. Among other things, one can send transactions, fetch\n * deserialized accounts, decode instruction data, subscribe to account\n * changes, and listen to events.\n *\n * In addition to field accessors and methods, the object provides a set of\n * dynamically generated properties, also known as namespaces, that\n * map one-to-one to program methods and accounts. These namespaces generally\n *  can be used as follows:\n *\n * ## Usage\n *\n * ```javascript\n * program.<namespace>.<program-specific-method>\n * ```\n *\n * API specifics are namespace dependent. The examples used in the documentation\n * below will refer to the two counter examples found\n * [here](https://github.com/coral-xyz/anchor#examples).\n */\nclass Program {\n    /**\n     * Address of the program.\n     */\n    get programId() {\n        return this._programId;\n    }\n    /**\n     * IDL in camelCase format to work in TypeScript.\n     *\n     * See {@link rawIdl} field if you need the original IDL.\n     */\n    get idl() {\n        return this._idl;\n    }\n    /**\n     * Raw IDL i.e. the original IDL without camelCase conversion.\n     *\n     * See {@link idl} field if you need the camelCased version of the IDL.\n     */\n    get rawIdl() {\n        return this._rawIdl;\n    }\n    /**\n     * Coder for serializing requests.\n     */\n    get coder() {\n        return this._coder;\n    }\n    /**\n     * Wallet and network provider.\n     */\n    get provider() {\n        return this._provider;\n    }\n    /**\n     * @param idl       The interface definition.\n     * @param provider  The network and wallet context to use. If not provided\n     *                  then uses [[getProvider]].\n     * @param getCustomResolver A function that returns a custom account resolver\n     *                          for the given instruction. This is useful for resolving\n     *                          public keys of missing accounts when building instructions\n     */\n    constructor(idl, provider = getProvider(), coder, getCustomResolver) {\n        // Fields.\n        this._idl = convertIdlToCamelCase(idl);\n        this._rawIdl = idl;\n        this._provider = provider;\n        this._programId = translateAddress(idl.address);\n        this._coder = coder !== null && coder !== void 0 ? coder : new BorshCoder(this._idl);\n        this._events = new EventManager(this._programId, provider, this._coder);\n        // Dynamic namespaces.\n        const [rpc, instruction, transaction, account, simulate, methods, views] = NamespaceFactory.build(this._idl, this._coder, this._programId, provider, getCustomResolver);\n        this.rpc = rpc;\n        this.instruction = instruction;\n        this.transaction = transaction;\n        this.account = account;\n        this.simulate = simulate;\n        this.methods = methods;\n        this.views = views;\n    }\n    /**\n     * Generates a Program client by fetching the IDL from the network.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n    static async at(address, provider) {\n        const programId = translateAddress(address);\n        const idl = await Program.fetchIdl(programId, provider);\n        if (!idl) {\n            throw new Error(`IDL not found for program: ${address.toString()}`);\n        }\n        return new Program(idl, provider);\n    }\n    /**\n     * Fetches an idl from the blockchain.\n     *\n     * In order to use this method, an IDL must have been previously initialized\n     * via the anchor CLI's `anchor idl init` command.\n     *\n     * @param programId The on-chain address of the program.\n     * @param provider  The network and wallet context.\n     */\n    static async fetchIdl(address, provider) {\n        provider = provider !== null && provider !== void 0 ? provider : getProvider();\n        const programId = translateAddress(address);\n        const idlAddr = await idlAddress(programId);\n        const accountInfo = await provider.connection.getAccountInfo(idlAddr);\n        if (!accountInfo) {\n            return null;\n        }\n        // Chop off account discriminator.\n        let idlAccount = decodeIdlAccount(accountInfo.data.slice(8));\n        const inflatedIdl = inflate(idlAccount.data);\n        return JSON.parse(decode$2(inflatedIdl));\n    }\n    /**\n     * Invokes the given callback every time the given event is emitted.\n     *\n     * @param eventName The PascalCase name of the event, provided by the IDL.\n     * @param callback  The function to invoke whenever the event is emitted from\n     *                  program logs.\n     */\n    addEventListener(eventName, callback, commitment) {\n        return this._events.addEventListener(eventName, callback, commitment);\n    }\n    /**\n     * Unsubscribes from the given eventName.\n     */\n    async removeEventListener(listener) {\n        return await this._events.removeEventListener(listener);\n    }\n}\n\nnew PublicKey(\"11111111111111111111111111111111\");\nfunction program(provider) {\n    return new Program(IDL, provider, coder());\n}\nfunction coder() {\n    return new SystemCoder(IDL);\n}\nconst IDL = {\n    address: \"11111111111111111111111111111111\",\n    metadata: {\n        name: \"systemProgram\",\n        version: \"0.1.0\",\n        spec: \"0.1.0\",\n    },\n    instructions: [\n        {\n            name: \"advanceNonceAccount\",\n            discriminator: [4, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true,\n                },\n                {\n                    name: \"recentBlockhashes\",\n                },\n                {\n                    name: \"authorized\",\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"authorized\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"allocate\",\n            discriminator: [8, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"pubkey\",\n                    writable: true,\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"space\",\n                    type: \"u64\",\n                },\n            ],\n        },\n        {\n            name: \"allocateWithSeed\",\n            discriminator: [9, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"account\",\n                    writable: true,\n                },\n                {\n                    name: \"base\",\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"base\",\n                    type: \"pubkey\",\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\",\n                },\n                {\n                    name: \"space\",\n                    type: \"u64\",\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"assign\",\n            discriminator: [1, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"pubkey\",\n                    writable: true,\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"owner\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"assignWithSeed\",\n            discriminator: [10, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"account\",\n                    writable: true,\n                },\n                {\n                    name: \"base\",\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"base\",\n                    type: \"pubkey\",\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\",\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"authorizeNonceAccount\",\n            discriminator: [7, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true,\n                },\n                {\n                    name: \"authorized\",\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"authorized\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"createAccount\",\n            discriminator: [0, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true,\n                    signer: true,\n                },\n                {\n                    name: \"to\",\n                    writable: true,\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\",\n                },\n                {\n                    name: \"space\",\n                    type: \"u64\",\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"createAccountWithSeed\",\n            discriminator: [3, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true,\n                    signer: true,\n                },\n                {\n                    name: \"to\",\n                    writable: true,\n                },\n                {\n                    name: \"base\",\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"base\",\n                    type: \"pubkey\",\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\",\n                },\n                {\n                    name: \"lamports\",\n                    type: \"u64\",\n                },\n                {\n                    name: \"space\",\n                    type: \"u64\",\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"initializeNonceAccount\",\n            discriminator: [6, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true,\n                    signer: true,\n                },\n                {\n                    name: \"recentBlockhashes\",\n                },\n                {\n                    name: \"rent\",\n                    address: \"SysvarRent111111111111111111111111111111111\",\n                },\n            ],\n            args: [\n                {\n                    name: \"authorized\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"transfer\",\n            discriminator: [2, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true,\n                    signer: true,\n                },\n                {\n                    name: \"to\",\n                    writable: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\",\n                },\n            ],\n        },\n        {\n            name: \"transferWithSeed\",\n            discriminator: [11, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"from\",\n                    writable: true,\n                },\n                {\n                    name: \"base\",\n                    signer: true,\n                },\n                {\n                    name: \"to\",\n                    writable: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\",\n                },\n                {\n                    name: \"seed\",\n                    type: \"string\",\n                },\n                {\n                    name: \"owner\",\n                    type: \"pubkey\",\n                },\n            ],\n        },\n        {\n            name: \"withdrawNonceAccount\",\n            discriminator: [5, 0, 0, 0],\n            accounts: [\n                {\n                    name: \"nonce\",\n                    writable: true,\n                },\n                {\n                    name: \"to\",\n                    writable: true,\n                },\n                {\n                    name: \"recentBlockhashes\",\n                },\n                {\n                    name: \"rent\",\n                    address: \"SysvarRent111111111111111111111111111111111\",\n                },\n                {\n                    name: \"authorized\",\n                    signer: true,\n                },\n            ],\n            args: [\n                {\n                    name: \"lamports\",\n                    type: \"u64\",\n                },\n            ],\n        },\n    ],\n    accounts: [\n        {\n            name: \"nonce\",\n            discriminator: [],\n        },\n    ],\n    types: [\n        {\n            name: \"feeCalculator\",\n            type: {\n                kind: \"struct\",\n                fields: [\n                    {\n                        name: \"lamportsPerSignature\",\n                        type: \"u64\",\n                    },\n                ],\n            },\n        },\n        {\n            name: \"nonce\",\n            type: {\n                kind: \"struct\",\n                fields: [\n                    {\n                        name: \"version\",\n                        type: \"u32\",\n                    },\n                    {\n                        name: \"state\",\n                        type: \"u32\",\n                    },\n                    {\n                        name: \"authorizedPubkey\",\n                        type: \"pubkey\",\n                    },\n                    {\n                        name: \"nonce\",\n                        type: \"pubkey\",\n                    },\n                    {\n                        name: \"feeCalculator\",\n                        type: {\n                            defined: {\n                                name: \"feeCalculator\",\n                            },\n                        },\n                    },\n                ],\n            },\n        },\n    ],\n};\n\nclass Native {\n    static system(provider) {\n        return program(provider);\n    }\n}\n\nexport { AccountClient, AnchorError, AnchorProvider, BorshAccountsCoder, BorshCoder, BorshEventCoder, BorshInstructionCoder, EventManager, EventParser, IdlError, LangErrorCode, LangErrorMessage, MethodsBuilderFactory, Native, Program, ProgramError, ProgramErrorStack, SystemCoder, getProvider, parseIdlErrors, setProvider, splitArgsAndCtx, toInstruction, translateAddress, translateError, index as utils, validateAccounts };\n//# sourceMappingURL=index.js.map\n"],"names":["isVersionedTransaction","tx","hex","Object","freeze","__proto__","encode","data","reduce","str","byte","toString","padStart","decode","indexOf","substr","length","key","match","Buffer","from","map","parseInt","utf8","array","TextDecoder","input","TextEncoder","encode$1","bs58","base64","index$1","StructError","TypeError","constructor","failure","failures","cached","message","rest","path","super","join","this","value","type","refinement","branch","assign","name","_cached","isObject","x","print","JSON","stringify","toFailure","result","context","struct","toFailures","Symbol","iterator","r","run","options","coerce","mask","ctx","coercer","schema","Array","isArray","undefined","valid","validator","k","v","s","entries","ts","t","Map","set","Set","add","refiner","Struct","props","TYPE","assert","validate","create","is","tuples","tuple","done","next","shiftIterator","define","Element","i","slice","literal","constant","description","nullable","number","isNaN","optional","string","keys","union$1","Structs","find","e","unknown","S","first","push","async","getMultipleAccountsAndContext","connection","publicKeys","commitment","getMultipleAccountsAndContextCore","batches","apply","Math","ceil","_","index","chunks","Promise","all","batch","flat","commitmentOverride","accountInfos","getMultipleAccountsInfoAndContext","account","idx","publicKey","simulateTransaction","transaction","signers","includeAccounts","_a","sign","_compile","signData","serialize","encodedTransaction","_serialize","config","encoding","addresses","nonProgramIds","toBase58","sigVerify","args","res","_rpcRequest","SimulatedTransactionResponseStruct","logs","error","traceIndent","logTrace","console","SendTransactionError","UnknownRpcResult","createRpcResult","jsonrpc","id","code","err","accounts","executable","owner","lamports","rentEpoch","unitsConsumed","condition","slot","rpc","invoke","programId","provider","address","PublicKey","_provider","AnchorProvider","local","Transaction","TransactionInstruction","sendAndConfirm","Error","getMultipleAccounts","wallet","opts","defaultOptions","preflightCommitment","url","env","_b","_c","_d","feePayer","recentBlockhash","getLatestBlockhash","blockhash","signer","partialSign","rawTx","signTransaction","sendAndConfirmRawTransaction","ConfirmError","txSig","signatures","Uint8Array","signature","maxVer","failedTx","getTransaction","maxSupportedTransactionVersion","meta","logMessages","sendAll","txWithSigners","txs","forEach","kp","signedTxs","signAllTransactions","sigs","simulate","SimulateError","simulationResponse","rawTransaction","sendOptions","skipPreflight","maxRetries","minContextSlot","status","startTime","Date","now","sendRawTransaction","abortSignal","AbortSignal","timeout","confirmTransaction","commonjsGlobal","globalThis","window","g","self","getDefaultExportFromCjs","__esModule","prototype","hasOwnProperty","call","dist","defineProperty","ANCHOR_ERROR__REQUIRE_EQ_VIOLATED","ANCHOR_ERROR__REQUIRE_VIOLATED","ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_PROGRAM_ID","ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION_AUTHORITY","ANCHOR_ERROR__CONSTRAINT_MINT_TRANSFER_HOOK_EXTENSION","ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION_DELEGATE","ANCHOR_ERROR__CONSTRAINT_MINT_PERMANENT_DELEGATE_EXTENSION","ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION_AUTHORITY","ANCHOR_ERROR__CONSTRAINT_MINT_CLOSE_AUTHORITY_EXTENSION","ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_METADATA_ADDRESS","ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION_AUTHORITY","ANCHOR_ERROR__CONSTRAINT_MINT_METADATA_POINTER_EXTENSION","ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_MEMBER_ADDRESS","ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION_AUTHORITY","ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_MEMBER_POINTER_EXTENSION","ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_GROUP_ADDRESS","ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION_AUTHORITY","ANCHOR_ERROR__CONSTRAINT_MINT_GROUP_POINTER_EXTENSION","ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_TOKEN_TOKEN_PROGRAM","ANCHOR_ERROR__CONSTRAINT_MINT_TOKEN_PROGRAM","ANCHOR_ERROR__CONSTRAINT_TOKEN_TOKEN_PROGRAM","ANCHOR_ERROR__CONSTRAINT_ACCOUNT_IS_NONE","ANCHOR_ERROR__CONSTRAINT_SPACE","ANCHOR_ERROR__CONSTRAINT_MINT_DECIMALS","ANCHOR_ERROR__CONSTRAINT_MINT_FREEZE_AUTHORITY","ANCHOR_ERROR__CONSTRAINT_MINT_MINT_AUTHORITY","ANCHOR_ERROR__CONSTRAINT_TOKEN_OWNER","ANCHOR_ERROR__CONSTRAINT_TOKEN_MINT","ANCHOR_ERROR__CONSTRAINT_ZERO","ANCHOR_ERROR__CONSTRAINT_ADDRESS","ANCHOR_ERROR__CONSTRAINT_CLOSE","ANCHOR_ERROR__CONSTRAINT_ASSOCIATED_INIT","ANCHOR_ERROR__CONSTRAINT_ASSOCIATED","ANCHOR_ERROR__CONSTRAINT_STATE","ANCHOR_ERROR__CONSTRAINT_EXECUTABLE","ANCHOR_ERROR__CONSTRAINT_SEEDS","ANCHOR_ERROR__CONSTRAINT_RENT_EXEMPT","ANCHOR_ERROR__CONSTRAINT_OWNER","ANCHOR_ERROR__CONSTRAINT_RAW","ANCHOR_ERROR__CONSTRAINT_SIGNER","ANCHOR_ERROR__CONSTRAINT_HAS_ONE","ANCHOR_ERROR__CONSTRAINT_MUT","ANCHOR_ERROR__EVENT_INSTRUCTION_STUB","ANCHOR_ERROR__IDL_ACCOUNT_NOT_EMPTY","ANCHOR_ERROR__IDL_INSTRUCTION_INVALID_PROGRAM","ANCHOR_ERROR__IDL_INSTRUCTION_STUB","ANCHOR_ERROR__INSTRUCTION_DID_NOT_SERIALIZE","ANCHOR_ERROR__INSTRUCTION_DID_NOT_DESERIALIZE","ANCHOR_ERROR__INSTRUCTION_FALLBACK_NOT_FOUND","ANCHOR_ERROR__INSTRUCTION_MISSING","ANCHOR_ERROR__DEPRECATED","ANCHOR_ERROR__INVALID_NUMERIC_CONVERSION","ANCHOR_ERROR__TRYING_TO_INIT_PAYER_AS_PROGRAM_ACCOUNT","ANCHOR_ERROR__DECLARED_PROGRAM_ID_MISMATCH","ANCHOR_ERROR__ACCOUNT_DUPLICATE_REALLOCS","ANCHOR_ERROR__ACCOUNT_REALLOC_EXCEEDS_LIMIT","ANCHOR_ERROR__ACCOUNT_SYSVAR_MISMATCH","ANCHOR_ERROR__ACCOUNT_NOT_ASSOCIATED_TOKEN_ACCOUNT","ANCHOR_ERROR__ACCOUNT_NOT_PROGRAM_DATA","ANCHOR_ERROR__ACCOUNT_NOT_INITIALIZED","ANCHOR_ERROR__ACCOUNT_NOT_SYSTEM_OWNED","ANCHOR_ERROR__ACCOUNT_NOT_SIGNER","ANCHOR_ERROR__INVALID_PROGRAM_EXECUTABLE","ANCHOR_ERROR__INVALID_PROGRAM_ID","ANCHOR_ERROR__ACCOUNT_OWNED_BY_WRONG_PROGRAM","ANCHOR_ERROR__ACCOUNT_NOT_MUTABLE","ANCHOR_ERROR__ACCOUNT_NOT_ENOUGH_KEYS","ANCHOR_ERROR__ACCOUNT_DID_NOT_SERIALIZE","ANCHOR_ERROR__ACCOUNT_DID_NOT_DESERIALIZE","ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_MISMATCH","ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_NOT_FOUND","ANCHOR_ERROR__ACCOUNT_DISCRIMINATOR_ALREADY_SET","ANCHOR_ERROR__REQUIRE_GTE_VIOLATED","ANCHOR_ERROR__REQUIRE_GT_VIOLATED","ANCHOR_ERROR__REQUIRE_KEYS_NEQ_VIOLATED","ANCHOR_ERROR__REQUIRE_NEQ_VIOLATED","ANCHOR_ERROR__REQUIRE_KEYS_EQ_VIOLATED","_AVAILABLE_FEATURES","_FEATURES","features","has","isSet","get","LangErrorCode","InstructionMissing","InstructionFallbackNotFound","InstructionDidNotDeserialize","InstructionDidNotSerialize","IdlInstructionStub","IdlInstructionInvalidProgram","IdlAccountNotEmpty","EventInstructionStub","ConstraintMut","ConstraintHasOne","ConstraintSigner","ConstraintRaw","ConstraintOwner","ConstraintRentExempt","ConstraintSeeds","ConstraintExecutable","ConstraintState","ConstraintAssociated","ConstraintAssociatedInit","ConstraintClose","ConstraintAddress","ConstraintZero","ConstraintTokenMint","ConstraintTokenOwner","ConstraintMintMintAuthority","ConstraintMintFreezeAuthority","ConstraintMintDecimals","ConstraintSpace","ConstraintAccountIsNone","ConstraintTokenTokenProgram","ConstraintMintTokenProgram","ConstraintAssociatedTokenTokenProgram","ConstraintMintGroupPointerExtension","ConstraintMintGroupPointerExtensionAuthority","ConstraintMintGroupPointerExtensionGroupAddress","ConstraintMintGroupMemberPointerExtension","ConstraintMintGroupMemberPointerExtensionAuthority","ConstraintMintGroupMemberPointerExtensionMemberAddress","ConstraintMintMetadataPointerExtension","ConstraintMintMetadataPointerExtensionAuthority","ConstraintMintMetadataPointerExtensionMetadataAddress","ConstraintMintCloseAuthorityExtension","ConstraintMintCloseAuthorityExtensionAuthority","ConstraintMintPermanentDelegateExtension","ConstraintMintPermanentDelegateExtensionDelegate","ConstraintMintTransferHookExtension","ConstraintMintTransferHookExtensionAuthority","ConstraintMintTransferHookExtensionProgramId","RequireViolated","RequireEqViolated","RequireKeysEqViolated","RequireNeqViolated","RequireKeysNeqViolated","RequireGtViolated","RequireGteViolated","AccountDiscriminatorAlreadySet","AccountDiscriminatorNotFound","AccountDiscriminatorMismatch","AccountDidNotDeserialize","AccountDidNotSerialize","AccountNotEnoughKeys","AccountNotMutable","AccountOwnedByWrongProgram","InvalidProgramId","InvalidProgramExecutable","AccountNotSigner","AccountNotSystemOwned","AccountNotInitialized","AccountNotProgramData","AccountNotAssociatedTokenAccount","AccountSysvarMismatch","AccountReallocExceedsLimit","AccountDuplicateReallocs","DeclaredProgramIdMismatch","TryingToInitPayerAsProgramAccount","InvalidNumericConversion","Deprecated","Layout","span","property","Number","isInteger","makeDestinationObject","b","offset","src","getSpan","RangeError","replicate","rv","fromArray","values","Layout_2","ExternalLayout","isCount","OffsetLayout","layout","UInt","UIntBE","readUIntLE","writeUIntLE","readUIntBE","writeUIntBE","V2E32","pow","divmodInt64","hi32","floor","lo32","roundedInt64","NearInt64","readUInt32LE","readInt32LE","split","writeUInt32LE","writeInt32LE","Structure","fields","decodePrefixes","acc","fd","fsp","dest","firstOffset","lastOffset","lastWrote","fv","shift","layoutFor","offsetOf","UnionDiscriminator","UnionLayoutDiscriminator","Union","discr","defaultLayout","upv","discriminator","usesPrefixDiscriminator","registry","boundGetSourceVariant","defaultGetSourceVariant","bind","getSourceVariant","configGetSourceVariant","gsv","vlo","getVariant","tag","dlo","clo","contentOffset","addVariant","variant","VariantLayout","vb","isBuffer","union","Blob$1","write","u32","ns64","blob","RustStringLayout","chars","toNumber","rustStringLayout","publicKey$2","LAYOUT","max","WrappedLayout$1","decoder","encoder","publicKey$1","toBuffer","sha256","hash","pubkey","createWithSeedSync","fromPublicKey","seed","buffer","concat","TOKEN_PROGRAM_ID","ASSOCIATED_PROGRAM_ID","token","associatedAddress","mint","findProgramAddressSync","browserPonyfill","exports","module","global","__self__","F","fetch","DOMException","support","Blob","viewClasses","isArrayBufferView","ArrayBuffer","isView","obj","normalizeName","String","test","toLowerCase","normalizeValue","iteratorFor","items","Headers","headers","append","header","getOwnPropertyNames","consumed","body","bodyUsed","reject","fileReaderReady","reader","resolve","onload","onerror","readBlobAsArrayBuffer","FileReader","promise","readAsArrayBuffer","bufferClone","buf","view","byteLength","Body","_initBody","_bodyInit","_bodyText","isPrototypeOf","_bodyBlob","FormData","_bodyFormData","URLSearchParams","DataView","_bodyArrayBuffer","rejected","arrayBuffer","then","text","readAsText","readBlobAsText","fromCharCode","readArrayBufferAsText","formData","json","parse","oldValue","callback","thisArg","methods","Request","method","upcased","credentials","mode","signal","toUpperCase","referrer","form","trim","bytes","replace","decodeURIComponent","Response","bodyInit","ok","statusText","clone","response","redirectStatuses","redirect","location","stack","init","request","aborted","xhr","XMLHttpRequest","abortXhr","abort","rawHeaders","getAllResponseHeaders","line","parts","responseURL","responseText","ontimeout","onabort","open","withCredentials","responseType","setRequestHeader","addEventListener","onreadystatechange","readyState","removeEventListener","send","polyfill","ponyfill","default","fetchData","accountInfo","getAccountInfo","program","decodeUpgradeableLoaderState","programdataAccountInfo","programdataAddress","programData","UPGRADEABLE_LOADER_STATE_LAYOUT","verifiedBuild","limit","latestBuildsResp","latestBuilds","filter","state","verified","build","verified_slot","uint64","WrappedLayout","u64","fromBuffer","n","coption","COptionLayout","a","toArray","reverse","zeroPad","alloc","copy","U"],"sourceRoot":""}