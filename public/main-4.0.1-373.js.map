{"version":3,"file":"main-4.0.1-373.js","mappings":"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","sources":["webpack://@jup-ag/terminal/./node_modules/react-window/dist/index.esm.js"],"sourcesContent":["import _extends from '@babel/runtime/helpers/esm/extends';\nimport _inheritsLoose from '@babel/runtime/helpers/esm/inheritsLoose';\nimport _assertThisInitialized from '@babel/runtime/helpers/esm/assertThisInitialized';\nimport memoizeOne from 'memoize-one';\nimport { createElement, PureComponent } from 'react';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/esm/objectWithoutPropertiesLoose';\n\n// Animation frame based implementation of setTimeout.\n// Inspired by Joe Lambert, https://gist.github.com/joelambert/1002116#file-requesttimeout-js\nvar hasNativePerformanceNow = typeof performance === 'object' && typeof performance.now === 'function';\nvar now = hasNativePerformanceNow ? function () {\n  return performance.now();\n} : function () {\n  return Date.now();\n};\nfunction cancelTimeout(timeoutID) {\n  cancelAnimationFrame(timeoutID.id);\n}\nfunction requestTimeout(callback, delay) {\n  var start = now();\n\n  function tick() {\n    if (now() - start >= delay) {\n      callback.call(null);\n    } else {\n      timeoutID.id = requestAnimationFrame(tick);\n    }\n  }\n\n  var timeoutID = {\n    id: requestAnimationFrame(tick)\n  };\n  return timeoutID;\n}\n\nvar size = -1; // This utility copied from \"dom-helpers\" package.\n\nfunction getScrollbarSize(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (size === -1 || recalculate) {\n    var div = document.createElement('div');\n    var style = div.style;\n    style.width = '50px';\n    style.height = '50px';\n    style.overflow = 'scroll';\n    document.body.appendChild(div);\n    size = div.offsetWidth - div.clientWidth;\n    document.body.removeChild(div);\n  }\n\n  return size;\n}\nvar cachedRTLResult = null; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n// Chrome does not seem to adhere; its scrollLeft values are positive (measured relative to the left).\n// Safari's elastic bounce makes detecting this even more complicated wrt potential false positives.\n// The safest way to check this is to intentionally set a negative offset,\n// and then verify that the subsequent \"scroll\" event matches the negative offset.\n// If it does not match, then we can assume a non-standard RTL scroll implementation.\n\nfunction getRTLOffsetType(recalculate) {\n  if (recalculate === void 0) {\n    recalculate = false;\n  }\n\n  if (cachedRTLResult === null || recalculate) {\n    var outerDiv = document.createElement('div');\n    var outerStyle = outerDiv.style;\n    outerStyle.width = '50px';\n    outerStyle.height = '50px';\n    outerStyle.overflow = 'scroll';\n    outerStyle.direction = 'rtl';\n    var innerDiv = document.createElement('div');\n    var innerStyle = innerDiv.style;\n    innerStyle.width = '100px';\n    innerStyle.height = '100px';\n    outerDiv.appendChild(innerDiv);\n    document.body.appendChild(outerDiv);\n\n    if (outerDiv.scrollLeft > 0) {\n      cachedRTLResult = 'positive-descending';\n    } else {\n      outerDiv.scrollLeft = 1;\n\n      if (outerDiv.scrollLeft === 0) {\n        cachedRTLResult = 'negative';\n      } else {\n        cachedRTLResult = 'positive-ascending';\n      }\n    }\n\n    document.body.removeChild(outerDiv);\n    return cachedRTLResult;\n  }\n\n  return cachedRTLResult;\n}\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL = 150;\n\nvar defaultItemKey = function defaultItemKey(_ref) {\n  var columnIndex = _ref.columnIndex,\n      data = _ref.data,\n      rowIndex = _ref.rowIndex;\n  return rowIndex + \":\" + columnIndex;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsOverscanCount = null;\nvar devWarningsOverscanRowsColumnsCount = null;\nvar devWarningsTagName = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsOverscanCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsOverscanRowsColumnsCount =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createGridComponent(_ref2) {\n  var _class, _temp;\n\n  var getColumnOffset = _ref2.getColumnOffset,\n      getColumnStartIndexForOffset = _ref2.getColumnStartIndexForOffset,\n      getColumnStopIndexForStartIndex = _ref2.getColumnStopIndexForStartIndex,\n      getColumnWidth = _ref2.getColumnWidth,\n      getEstimatedTotalHeight = _ref2.getEstimatedTotalHeight,\n      getEstimatedTotalWidth = _ref2.getEstimatedTotalWidth,\n      getOffsetForColumnAndAlignment = _ref2.getOffsetForColumnAndAlignment,\n      getOffsetForRowAndAlignment = _ref2.getOffsetForRowAndAlignment,\n      getRowHeight = _ref2.getRowHeight,\n      getRowOffset = _ref2.getRowOffset,\n      getRowStartIndexForOffset = _ref2.getRowStartIndexForOffset,\n      getRowStopIndexForStartIndex = _ref2.getRowStopIndexForStartIndex,\n      initInstanceProps = _ref2.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref2.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref2.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(Grid, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function Grid(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._resetIsScrollingTimeoutId = null;\n      _this._outerRef = void 0;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        horizontalScrollDirection: 'forward',\n        scrollLeft: typeof _this.props.initialScrollLeft === 'number' ? _this.props.initialScrollLeft : 0,\n        scrollTop: typeof _this.props.initialScrollTop === 'number' ? _this.props.initialScrollTop : 0,\n        scrollUpdateWasRequested: false,\n        verticalScrollDirection: 'forward'\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanColumnStartIndex, overscanColumnStopIndex, overscanRowStartIndex, overscanRowStopIndex, visibleColumnStartIndex, visibleColumnStopIndex, visibleRowStartIndex, visibleRowStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanColumnStartIndex: overscanColumnStartIndex,\n          overscanColumnStopIndex: overscanColumnStopIndex,\n          overscanRowStartIndex: overscanRowStartIndex,\n          overscanRowStopIndex: overscanRowStopIndex,\n          visibleColumnStartIndex: visibleColumnStartIndex,\n          visibleColumnStopIndex: visibleColumnStopIndex,\n          visibleRowStartIndex: visibleRowStartIndex,\n          visibleRowStopIndex: visibleRowStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollLeft, scrollTop, horizontalScrollDirection, verticalScrollDirection, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          horizontalScrollDirection: horizontalScrollDirection,\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          verticalScrollDirection: verticalScrollDirection,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (rowIndex, columnIndex) {\n        var _this$props = _this.props,\n            columnWidth = _this$props.columnWidth,\n            direction = _this$props.direction,\n            rowHeight = _this$props.rowHeight;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && columnWidth, shouldResetStyleCacheOnItemSizeChange && direction, shouldResetStyleCacheOnItemSizeChange && rowHeight);\n\n        var key = rowIndex + \":\" + columnIndex;\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(key)) {\n          style = itemStyleCache[key];\n        } else {\n          var _offset = getColumnOffset(_this.props, columnIndex, _this._instanceProps);\n\n          var isRtl = direction === 'rtl';\n          itemStyleCache[key] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : _offset,\n            right: isRtl ? _offset : undefined,\n            top: getRowOffset(_this.props, rowIndex, _this._instanceProps),\n            height: getRowHeight(_this.props, rowIndex, _this._instanceProps),\n            width: getColumnWidth(_this.props, columnIndex, _this._instanceProps)\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScroll = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientHeight = _event$currentTarget.clientHeight,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollTop = _event$currentTarget.scrollTop,\n            scrollHeight = _event$currentTarget.scrollHeight,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction; // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n          // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n          // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n          // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n\n          var calculatedScrollLeft = scrollLeft;\n\n          if (direction === 'rtl') {\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                calculatedScrollLeft = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                calculatedScrollLeft = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          calculatedScrollLeft = Math.max(0, Math.min(calculatedScrollLeft, scrollWidth - clientWidth));\n          var calculatedScrollTop = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n            scrollLeft: calculatedScrollLeft,\n            scrollTop: calculatedScrollTop,\n            verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward',\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1);\n        });\n      };\n\n      return _this;\n    }\n\n    Grid.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = Grid.prototype;\n\n    _proto.scrollTo = function scrollTo(_ref3) {\n      var scrollLeft = _ref3.scrollLeft,\n          scrollTop = _ref3.scrollTop;\n\n      if (scrollLeft !== undefined) {\n        scrollLeft = Math.max(0, scrollLeft);\n      }\n\n      if (scrollTop !== undefined) {\n        scrollTop = Math.max(0, scrollTop);\n      }\n\n      this.setState(function (prevState) {\n        if (scrollLeft === undefined) {\n          scrollLeft = prevState.scrollLeft;\n        }\n\n        if (scrollTop === undefined) {\n          scrollTop = prevState.scrollTop;\n        }\n\n        if (prevState.scrollLeft === scrollLeft && prevState.scrollTop === scrollTop) {\n          return null;\n        }\n\n        return {\n          horizontalScrollDirection: prevState.scrollLeft < scrollLeft ? 'forward' : 'backward',\n          scrollLeft: scrollLeft,\n          scrollTop: scrollTop,\n          scrollUpdateWasRequested: true,\n          verticalScrollDirection: prevState.scrollTop < scrollTop ? 'forward' : 'backward'\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(_ref4) {\n      var _ref4$align = _ref4.align,\n          align = _ref4$align === void 0 ? 'auto' : _ref4$align,\n          columnIndex = _ref4.columnIndex,\n          rowIndex = _ref4.rowIndex;\n      var _this$props2 = this.props,\n          columnCount = _this$props2.columnCount,\n          height = _this$props2.height,\n          rowCount = _this$props2.rowCount,\n          width = _this$props2.width;\n      var _this$state = this.state,\n          scrollLeft = _this$state.scrollLeft,\n          scrollTop = _this$state.scrollTop;\n      var scrollbarSize = getScrollbarSize();\n\n      if (columnIndex !== undefined) {\n        columnIndex = Math.max(0, Math.min(columnIndex, columnCount - 1));\n      }\n\n      if (rowIndex !== undefined) {\n        rowIndex = Math.max(0, Math.min(rowIndex, rowCount - 1));\n      }\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps); // The scrollbar size should be considered when scrolling an item into view,\n      // to ensure it's fully visible.\n      // But we only need to account for its size when it's actually visible.\n\n      var horizontalScrollbarSize = estimatedTotalWidth > width ? scrollbarSize : 0;\n      var verticalScrollbarSize = estimatedTotalHeight > height ? scrollbarSize : 0;\n      this.scrollTo({\n        scrollLeft: columnIndex !== undefined ? getOffsetForColumnAndAlignment(this.props, columnIndex, align, scrollLeft, this._instanceProps, verticalScrollbarSize) : scrollLeft,\n        scrollTop: rowIndex !== undefined ? getOffsetForRowAndAlignment(this.props, rowIndex, align, scrollTop, this._instanceProps, horizontalScrollbarSize) : scrollTop\n      });\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props3 = this.props,\n          initialScrollLeft = _this$props3.initialScrollLeft,\n          initialScrollTop = _this$props3.initialScrollTop;\n\n      if (this._outerRef != null) {\n        var outerRef = this._outerRef;\n\n        if (typeof initialScrollLeft === 'number') {\n          outerRef.scrollLeft = initialScrollLeft;\n        }\n\n        if (typeof initialScrollTop === 'number') {\n          outerRef.scrollTop = initialScrollTop;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var direction = this.props.direction;\n      var _this$state2 = this.state,\n          scrollLeft = _this$state2.scrollLeft,\n          scrollTop = _this$state2.scrollTop,\n          scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n        // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n        // So we need to determine which browser behavior we're dealing with, and mimic it.\n        var outerRef = this._outerRef;\n\n        if (direction === 'rtl') {\n          switch (getRTLOffsetType()) {\n            case 'negative':\n              outerRef.scrollLeft = -scrollLeft;\n              break;\n\n            case 'positive-ascending':\n              outerRef.scrollLeft = scrollLeft;\n              break;\n\n            default:\n              var clientWidth = outerRef.clientWidth,\n                  scrollWidth = outerRef.scrollWidth;\n              outerRef.scrollLeft = scrollWidth - clientWidth - scrollLeft;\n              break;\n          }\n        } else {\n          outerRef.scrollLeft = Math.max(0, scrollLeft);\n        }\n\n        outerRef.scrollTop = Math.max(0, scrollTop);\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          columnCount = _this$props4.columnCount,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey : _this$props4$itemKey,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          rowCount = _this$props4.rowCount,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling;\n\n      var _this$_getHorizontalR = this._getHorizontalRangeToRender(),\n          columnStartIndex = _this$_getHorizontalR[0],\n          columnStopIndex = _this$_getHorizontalR[1];\n\n      var _this$_getVerticalRan = this._getVerticalRangeToRender(),\n          rowStartIndex = _this$_getVerticalRan[0],\n          rowStopIndex = _this$_getVerticalRan[1];\n\n      var items = [];\n\n      if (columnCount > 0 && rowCount) {\n        for (var _rowIndex = rowStartIndex; _rowIndex <= rowStopIndex; _rowIndex++) {\n          for (var _columnIndex = columnStartIndex; _columnIndex <= columnStopIndex; _columnIndex++) {\n            items.push(createElement(children, {\n              columnIndex: _columnIndex,\n              data: itemData,\n              isScrolling: useIsScrolling ? isScrolling : undefined,\n              key: itemKey({\n                columnIndex: _columnIndex,\n                data: itemData,\n                rowIndex: _rowIndex\n              }),\n              rowIndex: _rowIndex,\n              style: this._getItemStyle(_rowIndex, _columnIndex)\n            }));\n          }\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalHeight = getEstimatedTotalHeight(this.props, this._instanceProps);\n      var estimatedTotalWidth = getEstimatedTotalWidth(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: this._onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: estimatedTotalHeight,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: estimatedTotalWidth\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      var _this$props5 = this.props,\n          columnCount = _this$props5.columnCount,\n          onItemsRendered = _this$props5.onItemsRendered,\n          onScroll = _this$props5.onScroll,\n          rowCount = _this$props5.rowCount;\n\n      if (typeof onItemsRendered === 'function') {\n        if (columnCount > 0 && rowCount > 0) {\n          var _this$_getHorizontalR2 = this._getHorizontalRangeToRender(),\n              _overscanColumnStartIndex = _this$_getHorizontalR2[0],\n              _overscanColumnStopIndex = _this$_getHorizontalR2[1],\n              _visibleColumnStartIndex = _this$_getHorizontalR2[2],\n              _visibleColumnStopIndex = _this$_getHorizontalR2[3];\n\n          var _this$_getVerticalRan2 = this._getVerticalRangeToRender(),\n              _overscanRowStartIndex = _this$_getVerticalRan2[0],\n              _overscanRowStopIndex = _this$_getVerticalRan2[1],\n              _visibleRowStartIndex = _this$_getVerticalRan2[2],\n              _visibleRowStopIndex = _this$_getVerticalRan2[3];\n\n          this._callOnItemsRendered(_overscanColumnStartIndex, _overscanColumnStopIndex, _overscanRowStartIndex, _overscanRowStopIndex, _visibleColumnStartIndex, _visibleColumnStopIndex, _visibleRowStartIndex, _visibleRowStopIndex);\n        }\n      }\n\n      if (typeof onScroll === 'function') {\n        var _this$state3 = this.state,\n            _horizontalScrollDirection = _this$state3.horizontalScrollDirection,\n            _scrollLeft = _this$state3.scrollLeft,\n            _scrollTop = _this$state3.scrollTop,\n            _scrollUpdateWasRequested = _this$state3.scrollUpdateWasRequested,\n            _verticalScrollDirection = _this$state3.verticalScrollDirection;\n\n        this._callOnScroll(_scrollLeft, _scrollTop, _horizontalScrollDirection, _verticalScrollDirection, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getHorizontalRangeToRender = function _getHorizontalRangeToRender() {\n      var _this$props6 = this.props,\n          columnCount = _this$props6.columnCount,\n          overscanColumnCount = _this$props6.overscanColumnCount,\n          overscanColumnsCount = _this$props6.overscanColumnsCount,\n          overscanCount = _this$props6.overscanCount,\n          rowCount = _this$props6.rowCount;\n      var _this$state4 = this.state,\n          horizontalScrollDirection = _this$state4.horizontalScrollDirection,\n          isScrolling = _this$state4.isScrolling,\n          scrollLeft = _this$state4.scrollLeft;\n      var overscanCountResolved = overscanColumnCount || overscanColumnsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getColumnStartIndexForOffset(this.props, scrollLeft, this._instanceProps);\n      var stopIndex = getColumnStopIndexForStartIndex(this.props, startIndex, scrollLeft, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || horizontalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || horizontalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(columnCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    _proto._getVerticalRangeToRender = function _getVerticalRangeToRender() {\n      var _this$props7 = this.props,\n          columnCount = _this$props7.columnCount,\n          overscanCount = _this$props7.overscanCount,\n          overscanRowCount = _this$props7.overscanRowCount,\n          overscanRowsCount = _this$props7.overscanRowsCount,\n          rowCount = _this$props7.rowCount;\n      var _this$state5 = this.state,\n          isScrolling = _this$state5.isScrolling,\n          verticalScrollDirection = _this$state5.verticalScrollDirection,\n          scrollTop = _this$state5.scrollTop;\n      var overscanCountResolved = overscanRowCount || overscanRowsCount || overscanCount || 1;\n\n      if (columnCount === 0 || rowCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getRowStartIndexForOffset(this.props, scrollTop, this._instanceProps);\n      var stopIndex = getRowStopIndexForStartIndex(this.props, startIndex, scrollTop, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || verticalScrollDirection === 'backward' ? Math.max(1, overscanCountResolved) : 1;\n      var overscanForward = !isScrolling || verticalScrollDirection === 'forward' ? Math.max(1, overscanCountResolved) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(rowCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return Grid;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    useIsScrolling: false\n  }, _temp;\n}\n\nvar validateSharedProps = function validateSharedProps(_ref5, _ref6) {\n  var children = _ref5.children,\n      direction = _ref5.direction,\n      height = _ref5.height,\n      innerTagName = _ref5.innerTagName,\n      outerTagName = _ref5.outerTagName,\n      overscanColumnsCount = _ref5.overscanColumnsCount,\n      overscanCount = _ref5.overscanCount,\n      overscanRowsCount = _ref5.overscanRowsCount,\n      width = _ref5.width;\n  var instance = _ref6.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (typeof overscanCount === 'number') {\n      if (devWarningsOverscanCount && !devWarningsOverscanCount.has(instance)) {\n        devWarningsOverscanCount.add(instance);\n        console.warn('The overscanCount prop has been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (typeof overscanColumnsCount === 'number' || typeof overscanRowsCount === 'number') {\n      if (devWarningsOverscanRowsColumnsCount && !devWarningsOverscanRowsColumnsCount.has(instance)) {\n        devWarningsOverscanRowsColumnsCount.add(instance);\n        console.warn('The overscanColumnsCount and overscanRowsCount props have been deprecated. ' + 'Please use the overscanColumnCount and overscanRowCount props instead.');\n      }\n    }\n\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName && !devWarningsTagName.has(instance)) {\n        devWarningsTagName.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    switch (direction) {\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    if (typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Grids must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    }\n\n    if (typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Grids must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE = 50;\n\nvar getEstimatedTotalHeight = function getEstimatedTotalHeight(_ref, _ref2) {\n  var rowCount = _ref.rowCount;\n  var rowMetadataMap = _ref2.rowMetadataMap,\n      estimatedRowHeight = _ref2.estimatedRowHeight,\n      lastMeasuredRowIndex = _ref2.lastMeasuredRowIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredRowIndex >= rowCount) {\n    lastMeasuredRowIndex = rowCount - 1;\n  }\n\n  if (lastMeasuredRowIndex >= 0) {\n    var itemMetadata = rowMetadataMap[lastMeasuredRowIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = rowCount - lastMeasuredRowIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedRowHeight;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getEstimatedTotalWidth = function getEstimatedTotalWidth(_ref3, _ref4) {\n  var columnCount = _ref3.columnCount;\n  var columnMetadataMap = _ref4.columnMetadataMap,\n      estimatedColumnWidth = _ref4.estimatedColumnWidth,\n      lastMeasuredColumnIndex = _ref4.lastMeasuredColumnIndex;\n  var totalSizeOfMeasuredRows = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredColumnIndex >= columnCount) {\n    lastMeasuredColumnIndex = columnCount - 1;\n  }\n\n  if (lastMeasuredColumnIndex >= 0) {\n    var itemMetadata = columnMetadataMap[lastMeasuredColumnIndex];\n    totalSizeOfMeasuredRows = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = columnCount - lastMeasuredColumnIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedColumnWidth;\n  return totalSizeOfMeasuredRows + totalSizeOfUnmeasuredItems;\n};\n\nvar getItemMetadata = function getItemMetadata(itemType, props, index, instanceProps) {\n  var itemMetadataMap, itemSize, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    itemSize = props.columnWidth;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    itemSize = props.rowHeight;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    if (itemType === 'column') {\n      instanceProps.lastMeasuredColumnIndex = index;\n    } else {\n      instanceProps.lastMeasuredRowIndex = index;\n    }\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem = function findNearestItem(itemType, props, instanceProps, offset) {\n  var itemMetadataMap, lastMeasuredIndex;\n\n  if (itemType === 'column') {\n    itemMetadataMap = instanceProps.columnMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredColumnIndex;\n  } else {\n    itemMetadataMap = instanceProps.rowMetadataMap;\n    lastMeasuredIndex = instanceProps.lastMeasuredRowIndex;\n  }\n\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch(itemType, props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch(itemType, props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch = function findNearestItemBinarySearch(itemType, props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata(itemType, props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch = function findNearestItemExponentialSearch(itemType, props, instanceProps, index, offset) {\n  var itemCount = itemType === 'column' ? props.columnCount : props.rowCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata(itemType, props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch(itemType, props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getOffsetForIndexAndAlignment = function getOffsetForIndexAndAlignment(itemType, props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n  var size = itemType === 'column' ? props.width : props.height;\n  var itemMetadata = getItemMetadata(itemType, props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n  // To ensure it reflects actual measurements instead of just estimates.\n\n  var estimatedTotalSize = itemType === 'column' ? getEstimatedTotalWidth(props, instanceProps) : getEstimatedTotalHeight(props, instanceProps);\n  var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n  var minOffset = Math.max(0, itemMetadata.offset - size + scrollbarSize + itemMetadata.size);\n\n  if (align === 'smart') {\n    if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n      align = 'auto';\n    } else {\n      align = 'center';\n    }\n  }\n\n  switch (align) {\n    case 'start':\n      return maxOffset;\n\n    case 'end':\n      return minOffset;\n\n    case 'center':\n      return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n    case 'auto':\n    default:\n      if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n        return scrollOffset;\n      } else if (minOffset > maxOffset) {\n        // Because we only take into account the scrollbar size when calculating minOffset\n        // this value can be larger than maxOffset when at the end of the list\n        return minOffset;\n      } else if (scrollOffset < minOffset) {\n        return minOffset;\n      } else {\n        return maxOffset;\n      }\n\n  }\n};\n\nvar VariableSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(props, index, instanceProps) {\n    return getItemMetadata('column', props, index, instanceProps).offset;\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(props, scrollLeft, instanceProps) {\n    return findNearestItem('column', props, instanceProps, scrollLeft);\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(props, startIndex, scrollLeft, instanceProps) {\n    var columnCount = props.columnCount,\n        width = props.width;\n    var itemMetadata = getItemMetadata('column', props, startIndex, instanceProps);\n    var maxOffset = scrollLeft + width;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < columnCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('column', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  getColumnWidth: function getColumnWidth(props, index, instanceProps) {\n    return instanceProps.columnMetadataMap[index].size;\n  },\n  getEstimatedTotalHeight: getEstimatedTotalHeight,\n  getEstimatedTotalWidth: getEstimatedTotalWidth,\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('column', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(props, index, align, scrollOffset, instanceProps, scrollbarSize) {\n    return getOffsetForIndexAndAlignment('row', props, index, align, scrollOffset, instanceProps, scrollbarSize);\n  },\n  getRowOffset: function getRowOffset(props, index, instanceProps) {\n    return getItemMetadata('row', props, index, instanceProps).offset;\n  },\n  getRowHeight: function getRowHeight(props, index, instanceProps) {\n    return instanceProps.rowMetadataMap[index].size;\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(props, scrollTop, instanceProps) {\n    return findNearestItem('row', props, instanceProps, scrollTop);\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(props, startIndex, scrollTop, instanceProps) {\n    var rowCount = props.rowCount,\n        height = props.height;\n    var itemMetadata = getItemMetadata('row', props, startIndex, instanceProps);\n    var maxOffset = scrollTop + height;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < rowCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata('row', props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref5 = props,\n        estimatedColumnWidth = _ref5.estimatedColumnWidth,\n        estimatedRowHeight = _ref5.estimatedRowHeight;\n    var instanceProps = {\n      columnMetadataMap: {},\n      estimatedColumnWidth: estimatedColumnWidth || DEFAULT_ESTIMATED_ITEM_SIZE,\n      estimatedRowHeight: estimatedRowHeight || DEFAULT_ESTIMATED_ITEM_SIZE,\n      lastMeasuredColumnIndex: -1,\n      lastMeasuredRowIndex: -1,\n      rowMetadataMap: {}\n    };\n\n    instance.resetAfterColumnIndex = function (columnIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        columnIndex: columnIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterRowIndex = function (rowIndex, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instance.resetAfterIndices({\n        rowIndex: rowIndex,\n        shouldForceUpdate: shouldForceUpdate\n      });\n    };\n\n    instance.resetAfterIndices = function (_ref6) {\n      var columnIndex = _ref6.columnIndex,\n          rowIndex = _ref6.rowIndex,\n          _ref6$shouldForceUpda = _ref6.shouldForceUpdate,\n          shouldForceUpdate = _ref6$shouldForceUpda === void 0 ? true : _ref6$shouldForceUpda;\n\n      if (typeof columnIndex === 'number') {\n        instanceProps.lastMeasuredColumnIndex = Math.min(instanceProps.lastMeasuredColumnIndex, columnIndex - 1);\n      }\n\n      if (typeof rowIndex === 'number') {\n        instanceProps.lastMeasuredRowIndex = Math.min(instanceProps.lastMeasuredRowIndex, rowIndex - 1);\n      } // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref7) {\n    var columnWidth = _ref7.columnWidth,\n        rowHeight = _ref7.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'function') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      } else if (typeof rowHeight !== 'function') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar IS_SCROLLING_DEBOUNCE_INTERVAL$1 = 150;\n\nvar defaultItemKey$1 = function defaultItemKey(index, data) {\n  return index;\n}; // In DEV mode, this Set helps us only log a warning once per component instance.\n// This avoids spamming the console every time a render happens.\n\n\nvar devWarningsDirection = null;\nvar devWarningsTagName$1 = null;\n\nif (process.env.NODE_ENV !== 'production') {\n  if (typeof window !== 'undefined' && typeof window.WeakSet !== 'undefined') {\n    devWarningsDirection =\n    /*#__PURE__*/\n    new WeakSet();\n    devWarningsTagName$1 =\n    /*#__PURE__*/\n    new WeakSet();\n  }\n}\n\nfunction createListComponent(_ref) {\n  var _class, _temp;\n\n  var getItemOffset = _ref.getItemOffset,\n      getEstimatedTotalSize = _ref.getEstimatedTotalSize,\n      getItemSize = _ref.getItemSize,\n      getOffsetForIndexAndAlignment = _ref.getOffsetForIndexAndAlignment,\n      getStartIndexForOffset = _ref.getStartIndexForOffset,\n      getStopIndexForStartIndex = _ref.getStopIndexForStartIndex,\n      initInstanceProps = _ref.initInstanceProps,\n      shouldResetStyleCacheOnItemSizeChange = _ref.shouldResetStyleCacheOnItemSizeChange,\n      validateProps = _ref.validateProps;\n  return _temp = _class =\n  /*#__PURE__*/\n  function (_PureComponent) {\n    _inheritsLoose(List, _PureComponent);\n\n    // Always use explicit constructor for React components.\n    // It produces less code after transpilation. (#26)\n    // eslint-disable-next-line no-useless-constructor\n    function List(props) {\n      var _this;\n\n      _this = _PureComponent.call(this, props) || this;\n      _this._instanceProps = initInstanceProps(_this.props, _assertThisInitialized(_assertThisInitialized(_this)));\n      _this._outerRef = void 0;\n      _this._resetIsScrollingTimeoutId = null;\n      _this.state = {\n        instance: _assertThisInitialized(_assertThisInitialized(_this)),\n        isScrolling: false,\n        scrollDirection: 'forward',\n        scrollOffset: typeof _this.props.initialScrollOffset === 'number' ? _this.props.initialScrollOffset : 0,\n        scrollUpdateWasRequested: false\n      };\n      _this._callOnItemsRendered = void 0;\n      _this._callOnItemsRendered = memoizeOne(function (overscanStartIndex, overscanStopIndex, visibleStartIndex, visibleStopIndex) {\n        return _this.props.onItemsRendered({\n          overscanStartIndex: overscanStartIndex,\n          overscanStopIndex: overscanStopIndex,\n          visibleStartIndex: visibleStartIndex,\n          visibleStopIndex: visibleStopIndex\n        });\n      });\n      _this._callOnScroll = void 0;\n      _this._callOnScroll = memoizeOne(function (scrollDirection, scrollOffset, scrollUpdateWasRequested) {\n        return _this.props.onScroll({\n          scrollDirection: scrollDirection,\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: scrollUpdateWasRequested\n        });\n      });\n      _this._getItemStyle = void 0;\n\n      _this._getItemStyle = function (index) {\n        var _this$props = _this.props,\n            direction = _this$props.direction,\n            itemSize = _this$props.itemSize,\n            layout = _this$props.layout;\n\n        var itemStyleCache = _this._getItemStyleCache(shouldResetStyleCacheOnItemSizeChange && itemSize, shouldResetStyleCacheOnItemSizeChange && layout, shouldResetStyleCacheOnItemSizeChange && direction);\n\n        var style;\n\n        if (itemStyleCache.hasOwnProperty(index)) {\n          style = itemStyleCache[index];\n        } else {\n          var _offset = getItemOffset(_this.props, index, _this._instanceProps);\n\n          var size = getItemSize(_this.props, index, _this._instanceProps); // TODO Deprecate direction \"horizontal\"\n\n          var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n          var isRtl = direction === 'rtl';\n          var offsetHorizontal = isHorizontal ? _offset : 0;\n          itemStyleCache[index] = style = {\n            position: 'absolute',\n            left: isRtl ? undefined : offsetHorizontal,\n            right: isRtl ? offsetHorizontal : undefined,\n            top: !isHorizontal ? _offset : 0,\n            height: !isHorizontal ? size : '100%',\n            width: isHorizontal ? size : '100%'\n          };\n        }\n\n        return style;\n      };\n\n      _this._getItemStyleCache = void 0;\n      _this._getItemStyleCache = memoizeOne(function (_, __, ___) {\n        return {};\n      });\n\n      _this._onScrollHorizontal = function (event) {\n        var _event$currentTarget = event.currentTarget,\n            clientWidth = _event$currentTarget.clientWidth,\n            scrollLeft = _event$currentTarget.scrollLeft,\n            scrollWidth = _event$currentTarget.scrollWidth;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollLeft) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          }\n\n          var direction = _this.props.direction;\n          var scrollOffset = scrollLeft;\n\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // It's also easier for this component if we convert offsets to the same format as they would be in for ltr.\n            // So the simplest solution is to determine which browser behavior we're dealing with, and convert based on it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                scrollOffset = -scrollLeft;\n                break;\n\n              case 'positive-descending':\n                scrollOffset = scrollWidth - clientWidth - scrollLeft;\n                break;\n            }\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          scrollOffset = Math.max(0, Math.min(scrollOffset, scrollWidth - clientWidth));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollLeft ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._onScrollVertical = function (event) {\n        var _event$currentTarget2 = event.currentTarget,\n            clientHeight = _event$currentTarget2.clientHeight,\n            scrollHeight = _event$currentTarget2.scrollHeight,\n            scrollTop = _event$currentTarget2.scrollTop;\n\n        _this.setState(function (prevState) {\n          if (prevState.scrollOffset === scrollTop) {\n            // Scroll position may have been updated by cDM/cDU,\n            // In which case we don't need to trigger another render,\n            // And we don't want to update state.isScrolling.\n            return null;\n          } // Prevent Safari's elastic scrolling from causing visual shaking when scrolling past bounds.\n\n\n          var scrollOffset = Math.max(0, Math.min(scrollTop, scrollHeight - clientHeight));\n          return {\n            isScrolling: true,\n            scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n            scrollOffset: scrollOffset,\n            scrollUpdateWasRequested: false\n          };\n        }, _this._resetIsScrollingDebounced);\n      };\n\n      _this._outerRefSetter = function (ref) {\n        var outerRef = _this.props.outerRef;\n        _this._outerRef = ref;\n\n        if (typeof outerRef === 'function') {\n          outerRef(ref);\n        } else if (outerRef != null && typeof outerRef === 'object' && outerRef.hasOwnProperty('current')) {\n          outerRef.current = ref;\n        }\n      };\n\n      _this._resetIsScrollingDebounced = function () {\n        if (_this._resetIsScrollingTimeoutId !== null) {\n          cancelTimeout(_this._resetIsScrollingTimeoutId);\n        }\n\n        _this._resetIsScrollingTimeoutId = requestTimeout(_this._resetIsScrolling, IS_SCROLLING_DEBOUNCE_INTERVAL$1);\n      };\n\n      _this._resetIsScrolling = function () {\n        _this._resetIsScrollingTimeoutId = null;\n\n        _this.setState({\n          isScrolling: false\n        }, function () {\n          // Clear style cache after state update has been committed.\n          // This way we don't break pure sCU for items that don't use isScrolling param.\n          _this._getItemStyleCache(-1, null);\n        });\n      };\n\n      return _this;\n    }\n\n    List.getDerivedStateFromProps = function getDerivedStateFromProps(nextProps, prevState) {\n      validateSharedProps$1(nextProps, prevState);\n      validateProps(nextProps);\n      return null;\n    };\n\n    var _proto = List.prototype;\n\n    _proto.scrollTo = function scrollTo(scrollOffset) {\n      scrollOffset = Math.max(0, scrollOffset);\n      this.setState(function (prevState) {\n        if (prevState.scrollOffset === scrollOffset) {\n          return null;\n        }\n\n        return {\n          scrollDirection: prevState.scrollOffset < scrollOffset ? 'forward' : 'backward',\n          scrollOffset: scrollOffset,\n          scrollUpdateWasRequested: true\n        };\n      }, this._resetIsScrollingDebounced);\n    };\n\n    _proto.scrollToItem = function scrollToItem(index, align) {\n      if (align === void 0) {\n        align = 'auto';\n      }\n\n      var itemCount = this.props.itemCount;\n      var scrollOffset = this.state.scrollOffset;\n      index = Math.max(0, Math.min(index, itemCount - 1));\n      this.scrollTo(getOffsetForIndexAndAlignment(this.props, index, align, scrollOffset, this._instanceProps));\n    };\n\n    _proto.componentDidMount = function componentDidMount() {\n      var _this$props2 = this.props,\n          direction = _this$props2.direction,\n          initialScrollOffset = _this$props2.initialScrollOffset,\n          layout = _this$props2.layout;\n\n      if (typeof initialScrollOffset === 'number' && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          outerRef.scrollLeft = initialScrollOffset;\n        } else {\n          outerRef.scrollTop = initialScrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentDidUpdate = function componentDidUpdate() {\n      var _this$props3 = this.props,\n          direction = _this$props3.direction,\n          layout = _this$props3.layout;\n      var _this$state = this.state,\n          scrollOffset = _this$state.scrollOffset,\n          scrollUpdateWasRequested = _this$state.scrollUpdateWasRequested;\n\n      if (scrollUpdateWasRequested && this._outerRef != null) {\n        var outerRef = this._outerRef; // TODO Deprecate direction \"horizontal\"\n\n        if (direction === 'horizontal' || layout === 'horizontal') {\n          if (direction === 'rtl') {\n            // TRICKY According to the spec, scrollLeft should be negative for RTL aligned elements.\n            // This is not the case for all browsers though (e.g. Chrome reports values as positive, measured relative to the left).\n            // So we need to determine which browser behavior we're dealing with, and mimic it.\n            switch (getRTLOffsetType()) {\n              case 'negative':\n                outerRef.scrollLeft = -scrollOffset;\n                break;\n\n              case 'positive-ascending':\n                outerRef.scrollLeft = scrollOffset;\n                break;\n\n              default:\n                var clientWidth = outerRef.clientWidth,\n                    scrollWidth = outerRef.scrollWidth;\n                outerRef.scrollLeft = scrollWidth - clientWidth - scrollOffset;\n                break;\n            }\n          } else {\n            outerRef.scrollLeft = scrollOffset;\n          }\n        } else {\n          outerRef.scrollTop = scrollOffset;\n        }\n      }\n\n      this._callPropsCallbacks();\n    };\n\n    _proto.componentWillUnmount = function componentWillUnmount() {\n      if (this._resetIsScrollingTimeoutId !== null) {\n        cancelTimeout(this._resetIsScrollingTimeoutId);\n      }\n    };\n\n    _proto.render = function render() {\n      var _this$props4 = this.props,\n          children = _this$props4.children,\n          className = _this$props4.className,\n          direction = _this$props4.direction,\n          height = _this$props4.height,\n          innerRef = _this$props4.innerRef,\n          innerElementType = _this$props4.innerElementType,\n          innerTagName = _this$props4.innerTagName,\n          itemCount = _this$props4.itemCount,\n          itemData = _this$props4.itemData,\n          _this$props4$itemKey = _this$props4.itemKey,\n          itemKey = _this$props4$itemKey === void 0 ? defaultItemKey$1 : _this$props4$itemKey,\n          layout = _this$props4.layout,\n          outerElementType = _this$props4.outerElementType,\n          outerTagName = _this$props4.outerTagName,\n          style = _this$props4.style,\n          useIsScrolling = _this$props4.useIsScrolling,\n          width = _this$props4.width;\n      var isScrolling = this.state.isScrolling; // TODO Deprecate direction \"horizontal\"\n\n      var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n      var onScroll = isHorizontal ? this._onScrollHorizontal : this._onScrollVertical;\n\n      var _this$_getRangeToRend = this._getRangeToRender(),\n          startIndex = _this$_getRangeToRend[0],\n          stopIndex = _this$_getRangeToRend[1];\n\n      var items = [];\n\n      if (itemCount > 0) {\n        for (var _index = startIndex; _index <= stopIndex; _index++) {\n          items.push(createElement(children, {\n            data: itemData,\n            key: itemKey(_index, itemData),\n            index: _index,\n            isScrolling: useIsScrolling ? isScrolling : undefined,\n            style: this._getItemStyle(_index)\n          }));\n        }\n      } // Read this value AFTER items have been created,\n      // So their actual sizes (if variable) are taken into consideration.\n\n\n      var estimatedTotalSize = getEstimatedTotalSize(this.props, this._instanceProps);\n      return createElement(outerElementType || outerTagName || 'div', {\n        className: className,\n        onScroll: onScroll,\n        ref: this._outerRefSetter,\n        style: _extends({\n          position: 'relative',\n          height: height,\n          width: width,\n          overflow: 'auto',\n          WebkitOverflowScrolling: 'touch',\n          willChange: 'transform',\n          direction: direction\n        }, style)\n      }, createElement(innerElementType || innerTagName || 'div', {\n        children: items,\n        ref: innerRef,\n        style: {\n          height: isHorizontal ? '100%' : estimatedTotalSize,\n          pointerEvents: isScrolling ? 'none' : undefined,\n          width: isHorizontal ? estimatedTotalSize : '100%'\n        }\n      }));\n    };\n\n    _proto._callPropsCallbacks = function _callPropsCallbacks() {\n      if (typeof this.props.onItemsRendered === 'function') {\n        var itemCount = this.props.itemCount;\n\n        if (itemCount > 0) {\n          var _this$_getRangeToRend2 = this._getRangeToRender(),\n              _overscanStartIndex = _this$_getRangeToRend2[0],\n              _overscanStopIndex = _this$_getRangeToRend2[1],\n              _visibleStartIndex = _this$_getRangeToRend2[2],\n              _visibleStopIndex = _this$_getRangeToRend2[3];\n\n          this._callOnItemsRendered(_overscanStartIndex, _overscanStopIndex, _visibleStartIndex, _visibleStopIndex);\n        }\n      }\n\n      if (typeof this.props.onScroll === 'function') {\n        var _this$state2 = this.state,\n            _scrollDirection = _this$state2.scrollDirection,\n            _scrollOffset = _this$state2.scrollOffset,\n            _scrollUpdateWasRequested = _this$state2.scrollUpdateWasRequested;\n\n        this._callOnScroll(_scrollDirection, _scrollOffset, _scrollUpdateWasRequested);\n      }\n    }; // Lazily create and cache item styles while scrolling,\n    // So that pure component sCU will prevent re-renders.\n    // We maintain this cache, and pass a style prop rather than index,\n    // So that List can clear cached styles and force item re-render if necessary.\n\n\n    _proto._getRangeToRender = function _getRangeToRender() {\n      var _this$props5 = this.props,\n          itemCount = _this$props5.itemCount,\n          overscanCount = _this$props5.overscanCount;\n      var _this$state3 = this.state,\n          isScrolling = _this$state3.isScrolling,\n          scrollDirection = _this$state3.scrollDirection,\n          scrollOffset = _this$state3.scrollOffset;\n\n      if (itemCount === 0) {\n        return [0, 0, 0, 0];\n      }\n\n      var startIndex = getStartIndexForOffset(this.props, scrollOffset, this._instanceProps);\n      var stopIndex = getStopIndexForStartIndex(this.props, startIndex, scrollOffset, this._instanceProps); // Overscan by one item in each direction so that tab/focus works.\n      // If there isn't at least one extra item, tab loops back around.\n\n      var overscanBackward = !isScrolling || scrollDirection === 'backward' ? Math.max(1, overscanCount) : 1;\n      var overscanForward = !isScrolling || scrollDirection === 'forward' ? Math.max(1, overscanCount) : 1;\n      return [Math.max(0, startIndex - overscanBackward), Math.max(0, Math.min(itemCount - 1, stopIndex + overscanForward)), startIndex, stopIndex];\n    };\n\n    return List;\n  }(PureComponent), _class.defaultProps = {\n    direction: 'ltr',\n    itemData: undefined,\n    layout: 'vertical',\n    overscanCount: 2,\n    useIsScrolling: false\n  }, _temp;\n} // NOTE: I considered further wrapping individual items with a pure ListItem component.\n// This would avoid ever calling the render function for the same index more than once,\n// But it would also add the overhead of a lot of components/fibers.\n// I assume people already do this (render function returning a class component),\n// So my doing it would just unnecessarily double the wrappers.\n\nvar validateSharedProps$1 = function validateSharedProps(_ref2, _ref3) {\n  var children = _ref2.children,\n      direction = _ref2.direction,\n      height = _ref2.height,\n      layout = _ref2.layout,\n      innerTagName = _ref2.innerTagName,\n      outerTagName = _ref2.outerTagName,\n      width = _ref2.width;\n  var instance = _ref3.instance;\n\n  if (process.env.NODE_ENV !== 'production') {\n    if (innerTagName != null || outerTagName != null) {\n      if (devWarningsTagName$1 && !devWarningsTagName$1.has(instance)) {\n        devWarningsTagName$1.add(instance);\n        console.warn('The innerTagName and outerTagName props have been deprecated. ' + 'Please use the innerElementType and outerElementType props instead.');\n      }\n    } // TODO Deprecate direction \"horizontal\"\n\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n\n    switch (direction) {\n      case 'horizontal':\n      case 'vertical':\n        if (devWarningsDirection && !devWarningsDirection.has(instance)) {\n          devWarningsDirection.add(instance);\n          console.warn('The direction prop should be either \"ltr\" (default) or \"rtl\". ' + 'Please use the layout prop to specify \"vertical\" (default) or \"horizontal\" orientation.');\n        }\n\n        break;\n\n      case 'ltr':\n      case 'rtl':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"direction\" prop has been specified. ' + 'Value should be either \"ltr\" or \"rtl\". ' + (\"\\\"\" + direction + \"\\\" was specified.\"));\n    }\n\n    switch (layout) {\n      case 'horizontal':\n      case 'vertical':\n        // Valid values\n        break;\n\n      default:\n        throw Error('An invalid \"layout\" prop has been specified. ' + 'Value should be either \"horizontal\" or \"vertical\". ' + (\"\\\"\" + layout + \"\\\" was specified.\"));\n    }\n\n    if (children == null) {\n      throw Error('An invalid \"children\" prop has been specified. ' + 'Value should be a React component. ' + (\"\\\"\" + (children === null ? 'null' : typeof children) + \"\\\" was specified.\"));\n    }\n\n    if (isHorizontal && typeof width !== 'number') {\n      throw Error('An invalid \"width\" prop has been specified. ' + 'Horizontal lists must specify a number for width. ' + (\"\\\"\" + (width === null ? 'null' : typeof width) + \"\\\" was specified.\"));\n    } else if (!isHorizontal && typeof height !== 'number') {\n      throw Error('An invalid \"height\" prop has been specified. ' + 'Vertical lists must specify a number for height. ' + (\"\\\"\" + (height === null ? 'null' : typeof height) + \"\\\" was specified.\"));\n    }\n  }\n};\n\nvar DEFAULT_ESTIMATED_ITEM_SIZE$1 = 50;\n\nvar getItemMetadata$1 = function getItemMetadata(props, index, instanceProps) {\n  var _ref = props,\n      itemSize = _ref.itemSize;\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n\n  if (index > lastMeasuredIndex) {\n    var offset = 0;\n\n    if (lastMeasuredIndex >= 0) {\n      var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n      offset = itemMetadata.offset + itemMetadata.size;\n    }\n\n    for (var i = lastMeasuredIndex + 1; i <= index; i++) {\n      var size = itemSize(i);\n      itemMetadataMap[i] = {\n        offset: offset,\n        size: size\n      };\n      offset += size;\n    }\n\n    instanceProps.lastMeasuredIndex = index;\n  }\n\n  return itemMetadataMap[index];\n};\n\nvar findNearestItem$1 = function findNearestItem(props, instanceProps, offset) {\n  var itemMetadataMap = instanceProps.itemMetadataMap,\n      lastMeasuredIndex = instanceProps.lastMeasuredIndex;\n  var lastMeasuredItemOffset = lastMeasuredIndex > 0 ? itemMetadataMap[lastMeasuredIndex].offset : 0;\n\n  if (lastMeasuredItemOffset >= offset) {\n    // If we've already measured items within this range just use a binary search as it's faster.\n    return findNearestItemBinarySearch$1(props, instanceProps, lastMeasuredIndex, 0, offset);\n  } else {\n    // If we haven't yet measured this high, fallback to an exponential search with an inner binary search.\n    // The exponential search avoids pre-computing sizes for the full set of items as a binary search would.\n    // The overall complexity for this approach is O(log n).\n    return findNearestItemExponentialSearch$1(props, instanceProps, Math.max(0, lastMeasuredIndex), offset);\n  }\n};\n\nvar findNearestItemBinarySearch$1 = function findNearestItemBinarySearch(props, instanceProps, high, low, offset) {\n  while (low <= high) {\n    var middle = low + Math.floor((high - low) / 2);\n    var currentOffset = getItemMetadata$1(props, middle, instanceProps).offset;\n\n    if (currentOffset === offset) {\n      return middle;\n    } else if (currentOffset < offset) {\n      low = middle + 1;\n    } else if (currentOffset > offset) {\n      high = middle - 1;\n    }\n  }\n\n  if (low > 0) {\n    return low - 1;\n  } else {\n    return 0;\n  }\n};\n\nvar findNearestItemExponentialSearch$1 = function findNearestItemExponentialSearch(props, instanceProps, index, offset) {\n  var itemCount = props.itemCount;\n  var interval = 1;\n\n  while (index < itemCount && getItemMetadata$1(props, index, instanceProps).offset < offset) {\n    index += interval;\n    interval *= 2;\n  }\n\n  return findNearestItemBinarySearch$1(props, instanceProps, Math.min(index, itemCount - 1), Math.floor(index / 2), offset);\n};\n\nvar getEstimatedTotalSize = function getEstimatedTotalSize(_ref2, _ref3) {\n  var itemCount = _ref2.itemCount;\n  var itemMetadataMap = _ref3.itemMetadataMap,\n      estimatedItemSize = _ref3.estimatedItemSize,\n      lastMeasuredIndex = _ref3.lastMeasuredIndex;\n  var totalSizeOfMeasuredItems = 0; // Edge case check for when the number of items decreases while a scroll is in progress.\n  // https://github.com/bvaughn/react-window/pull/138\n\n  if (lastMeasuredIndex >= itemCount) {\n    lastMeasuredIndex = itemCount - 1;\n  }\n\n  if (lastMeasuredIndex >= 0) {\n    var itemMetadata = itemMetadataMap[lastMeasuredIndex];\n    totalSizeOfMeasuredItems = itemMetadata.offset + itemMetadata.size;\n  }\n\n  var numUnmeasuredItems = itemCount - lastMeasuredIndex - 1;\n  var totalSizeOfUnmeasuredItems = numUnmeasuredItems * estimatedItemSize;\n  return totalSizeOfMeasuredItems + totalSizeOfUnmeasuredItems;\n};\n\nvar VariableSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(props, index, instanceProps) {\n    return getItemMetadata$1(props, index, instanceProps).offset;\n  },\n  getItemSize: function getItemSize(props, index, instanceProps) {\n    return instanceProps.itemMetadataMap[index].size;\n  },\n  getEstimatedTotalSize: getEstimatedTotalSize,\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(props, index, align, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, index, instanceProps); // Get estimated total size after ItemMetadata is computed,\n    // To ensure it reflects actual measurements instead of just estimates.\n\n    var estimatedTotalSize = getEstimatedTotalSize(props, instanceProps);\n    var maxOffset = Math.max(0, Math.min(estimatedTotalSize - size, itemMetadata.offset));\n    var minOffset = Math.max(0, itemMetadata.offset - size + itemMetadata.size);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        return Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(props, offset, instanceProps) {\n    return findNearestItem$1(props, instanceProps, offset);\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(props, startIndex, scrollOffset, instanceProps) {\n    var direction = props.direction,\n        height = props.height,\n        itemCount = props.itemCount,\n        layout = props.layout,\n        width = props.width; // TODO Deprecate direction \"horizontal\"\n\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var itemMetadata = getItemMetadata$1(props, startIndex, instanceProps);\n    var maxOffset = scrollOffset + size;\n    var offset = itemMetadata.offset + itemMetadata.size;\n    var stopIndex = startIndex;\n\n    while (stopIndex < itemCount - 1 && offset < maxOffset) {\n      stopIndex++;\n      offset += getItemMetadata$1(props, stopIndex, instanceProps).size;\n    }\n\n    return stopIndex;\n  },\n  initInstanceProps: function initInstanceProps(props, instance) {\n    var _ref4 = props,\n        estimatedItemSize = _ref4.estimatedItemSize;\n    var instanceProps = {\n      itemMetadataMap: {},\n      estimatedItemSize: estimatedItemSize || DEFAULT_ESTIMATED_ITEM_SIZE$1,\n      lastMeasuredIndex: -1\n    };\n\n    instance.resetAfterIndex = function (index, shouldForceUpdate) {\n      if (shouldForceUpdate === void 0) {\n        shouldForceUpdate = true;\n      }\n\n      instanceProps.lastMeasuredIndex = Math.min(instanceProps.lastMeasuredIndex, index - 1); // We could potentially optimize further by only evicting styles after this index,\n      // But since styles are only cached while scrolling is in progress-\n      // It seems an unnecessary optimization.\n      // It's unlikely that resetAfterIndex() will be called while a user is scrolling.\n\n      instance._getItemStyleCache(-1);\n\n      if (shouldForceUpdate) {\n        instance.forceUpdate();\n      }\n    };\n\n    return instanceProps;\n  },\n  shouldResetStyleCacheOnItemSizeChange: false,\n  validateProps: function validateProps(_ref5) {\n    var itemSize = _ref5.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'function') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a function. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeGrid =\n/*#__PURE__*/\ncreateGridComponent({\n  getColumnOffset: function getColumnOffset(_ref, index) {\n    var columnWidth = _ref.columnWidth;\n    return index * columnWidth;\n  },\n  getColumnWidth: function getColumnWidth(_ref2, index) {\n    var columnWidth = _ref2.columnWidth;\n    return columnWidth;\n  },\n  getRowOffset: function getRowOffset(_ref3, index) {\n    var rowHeight = _ref3.rowHeight;\n    return index * rowHeight;\n  },\n  getRowHeight: function getRowHeight(_ref4, index) {\n    var rowHeight = _ref4.rowHeight;\n    return rowHeight;\n  },\n  getEstimatedTotalHeight: function getEstimatedTotalHeight(_ref5) {\n    var rowCount = _ref5.rowCount,\n        rowHeight = _ref5.rowHeight;\n    return rowHeight * rowCount;\n  },\n  getEstimatedTotalWidth: function getEstimatedTotalWidth(_ref6) {\n    var columnCount = _ref6.columnCount,\n        columnWidth = _ref6.columnWidth;\n    return columnWidth * columnCount;\n  },\n  getOffsetForColumnAndAlignment: function getOffsetForColumnAndAlignment(_ref7, columnIndex, align, scrollLeft, instanceProps, scrollbarSize) {\n    var columnCount = _ref7.columnCount,\n        columnWidth = _ref7.columnWidth,\n        width = _ref7.width;\n    var lastColumnOffset = Math.max(0, columnCount * columnWidth - width);\n    var maxOffset = Math.min(lastColumnOffset, columnIndex * columnWidth);\n    var minOffset = Math.max(0, columnIndex * columnWidth - width + scrollbarSize + columnWidth);\n\n    if (align === 'smart') {\n      if (scrollLeft >= minOffset - width && scrollLeft <= maxOffset + width) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(width / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastColumnOffset + Math.floor(width / 2)) {\n          return lastColumnOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollLeft >= minOffset && scrollLeft <= maxOffset) {\n          return scrollLeft;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollLeft < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getOffsetForRowAndAlignment: function getOffsetForRowAndAlignment(_ref8, rowIndex, align, scrollTop, instanceProps, scrollbarSize) {\n    var rowHeight = _ref8.rowHeight,\n        height = _ref8.height,\n        rowCount = _ref8.rowCount;\n    var lastRowOffset = Math.max(0, rowCount * rowHeight - height);\n    var maxOffset = Math.min(lastRowOffset, rowIndex * rowHeight);\n    var minOffset = Math.max(0, rowIndex * rowHeight - height + scrollbarSize + rowHeight);\n\n    if (align === 'smart') {\n      if (scrollTop >= minOffset - height && scrollTop <= maxOffset + height) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        // \"Centered\" offset is usually the average of the min and max.\n        // But near the edges of the list, this doesn't hold true.\n        var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n        if (middleOffset < Math.ceil(height / 2)) {\n          return 0; // near the beginning\n        } else if (middleOffset > lastRowOffset + Math.floor(height / 2)) {\n          return lastRowOffset; // near the end\n        } else {\n          return middleOffset;\n        }\n\n      case 'auto':\n      default:\n        if (scrollTop >= minOffset && scrollTop <= maxOffset) {\n          return scrollTop;\n        } else if (minOffset > maxOffset) {\n          // Because we only take into account the scrollbar size when calculating minOffset\n          // this value can be larger than maxOffset when at the end of the list\n          return minOffset;\n        } else if (scrollTop < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getColumnStartIndexForOffset: function getColumnStartIndexForOffset(_ref9, scrollLeft) {\n    var columnWidth = _ref9.columnWidth,\n        columnCount = _ref9.columnCount;\n    return Math.max(0, Math.min(columnCount - 1, Math.floor(scrollLeft / columnWidth)));\n  },\n  getColumnStopIndexForStartIndex: function getColumnStopIndexForStartIndex(_ref10, startIndex, scrollLeft) {\n    var columnWidth = _ref10.columnWidth,\n        columnCount = _ref10.columnCount,\n        width = _ref10.width;\n    var left = startIndex * columnWidth;\n    var numVisibleColumns = Math.ceil((width + scrollLeft - left) / columnWidth);\n    return Math.max(0, Math.min(columnCount - 1, startIndex + numVisibleColumns - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  getRowStartIndexForOffset: function getRowStartIndexForOffset(_ref11, scrollTop) {\n    var rowHeight = _ref11.rowHeight,\n        rowCount = _ref11.rowCount;\n    return Math.max(0, Math.min(rowCount - 1, Math.floor(scrollTop / rowHeight)));\n  },\n  getRowStopIndexForStartIndex: function getRowStopIndexForStartIndex(_ref12, startIndex, scrollTop) {\n    var rowHeight = _ref12.rowHeight,\n        rowCount = _ref12.rowCount,\n        height = _ref12.height;\n    var top = startIndex * rowHeight;\n    var numVisibleRows = Math.ceil((height + scrollTop - top) / rowHeight);\n    return Math.max(0, Math.min(rowCount - 1, startIndex + numVisibleRows - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref13) {\n    var columnWidth = _ref13.columnWidth,\n        rowHeight = _ref13.rowHeight;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof columnWidth !== 'number') {\n        throw Error('An invalid \"columnWidth\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (columnWidth === null ? 'null' : typeof columnWidth) + \"\\\" was specified.\"));\n      }\n\n      if (typeof rowHeight !== 'number') {\n        throw Error('An invalid \"rowHeight\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (rowHeight === null ? 'null' : typeof rowHeight) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\nvar FixedSizeList =\n/*#__PURE__*/\ncreateListComponent({\n  getItemOffset: function getItemOffset(_ref, index) {\n    var itemSize = _ref.itemSize;\n    return index * itemSize;\n  },\n  getItemSize: function getItemSize(_ref2, index) {\n    var itemSize = _ref2.itemSize;\n    return itemSize;\n  },\n  getEstimatedTotalSize: function getEstimatedTotalSize(_ref3) {\n    var itemCount = _ref3.itemCount,\n        itemSize = _ref3.itemSize;\n    return itemSize * itemCount;\n  },\n  getOffsetForIndexAndAlignment: function getOffsetForIndexAndAlignment(_ref4, index, align, scrollOffset) {\n    var direction = _ref4.direction,\n        height = _ref4.height,\n        itemCount = _ref4.itemCount,\n        itemSize = _ref4.itemSize,\n        layout = _ref4.layout,\n        width = _ref4.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var size = isHorizontal ? width : height;\n    var lastItemOffset = Math.max(0, itemCount * itemSize - size);\n    var maxOffset = Math.min(lastItemOffset, index * itemSize);\n    var minOffset = Math.max(0, index * itemSize - size + itemSize);\n\n    if (align === 'smart') {\n      if (scrollOffset >= minOffset - size && scrollOffset <= maxOffset + size) {\n        align = 'auto';\n      } else {\n        align = 'center';\n      }\n    }\n\n    switch (align) {\n      case 'start':\n        return maxOffset;\n\n      case 'end':\n        return minOffset;\n\n      case 'center':\n        {\n          // \"Centered\" offset is usually the average of the min and max.\n          // But near the edges of the list, this doesn't hold true.\n          var middleOffset = Math.round(minOffset + (maxOffset - minOffset) / 2);\n\n          if (middleOffset < Math.ceil(size / 2)) {\n            return 0; // near the beginning\n          } else if (middleOffset > lastItemOffset + Math.floor(size / 2)) {\n            return lastItemOffset; // near the end\n          } else {\n            return middleOffset;\n          }\n        }\n\n      case 'auto':\n      default:\n        if (scrollOffset >= minOffset && scrollOffset <= maxOffset) {\n          return scrollOffset;\n        } else if (scrollOffset < minOffset) {\n          return minOffset;\n        } else {\n          return maxOffset;\n        }\n\n    }\n  },\n  getStartIndexForOffset: function getStartIndexForOffset(_ref5, offset) {\n    var itemCount = _ref5.itemCount,\n        itemSize = _ref5.itemSize;\n    return Math.max(0, Math.min(itemCount - 1, Math.floor(offset / itemSize)));\n  },\n  getStopIndexForStartIndex: function getStopIndexForStartIndex(_ref6, startIndex, scrollOffset) {\n    var direction = _ref6.direction,\n        height = _ref6.height,\n        itemCount = _ref6.itemCount,\n        itemSize = _ref6.itemSize,\n        layout = _ref6.layout,\n        width = _ref6.width;\n    // TODO Deprecate direction \"horizontal\"\n    var isHorizontal = direction === 'horizontal' || layout === 'horizontal';\n    var offset = startIndex * itemSize;\n    var size = isHorizontal ? width : height;\n    var numVisibleItems = Math.ceil((size + scrollOffset - offset) / itemSize);\n    return Math.max(0, Math.min(itemCount - 1, startIndex + numVisibleItems - 1 // -1 is because stop index is inclusive\n    ));\n  },\n  initInstanceProps: function initInstanceProps(props) {// Noop\n  },\n  shouldResetStyleCacheOnItemSizeChange: true,\n  validateProps: function validateProps(_ref7) {\n    var itemSize = _ref7.itemSize;\n\n    if (process.env.NODE_ENV !== 'production') {\n      if (typeof itemSize !== 'number') {\n        throw Error('An invalid \"itemSize\" prop has been specified. ' + 'Value should be a number. ' + (\"\\\"\" + (itemSize === null ? 'null' : typeof itemSize) + \"\\\" was specified.\"));\n      }\n    }\n  }\n});\n\n// Pulled from react-compat\n// https://github.com/developit/preact-compat/blob/7c5de00e7c85e2ffd011bf3af02899b63f699d3a/src/index.js#L349\nfunction shallowDiffers(prev, next) {\n  for (var attribute in prev) {\n    if (!(attribute in next)) {\n      return true;\n    }\n  }\n\n  for (var _attribute in next) {\n    if (prev[_attribute] !== next[_attribute]) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-api.html#reactmemo\n\nfunction areEqual(prevProps, nextProps) {\n  var prevStyle = prevProps.style,\n      prevRest = _objectWithoutPropertiesLoose(prevProps, [\"style\"]);\n\n  var nextStyle = nextProps.style,\n      nextRest = _objectWithoutPropertiesLoose(nextProps, [\"style\"]);\n\n  return !shallowDiffers(prevStyle, nextStyle) && !shallowDiffers(prevRest, nextRest);\n}\n\n// It knows to compare individual style props and ignore the wrapper object.\n// See https://reactjs.org/docs/react-component.html#shouldcomponentupdate\n\nfunction shouldComponentUpdate(nextProps, nextState) {\n  return !areEqual(this.props, nextProps) || shallowDiffers(this.state, nextState);\n}\n\nexport { VariableSizeGrid, VariableSizeList, FixedSizeGrid, FixedSizeList, areEqual, shouldComponentUpdate };\n//# sourceMappingURL=index.esm.js.map\n"],"names":["now","performance","Date","cancelTimeout","timeoutID","cancelAnimationFrame","id","requestTimeout","callback","delay","start","requestAnimationFrame","tick","call","size","cachedRTLResult","getRTLOffsetType","recalculate","outerDiv","document","createElement","outerStyle","style","width","height","overflow","direction","innerDiv","innerStyle","appendChild","body","scrollLeft","removeChild","defaultItemKey","_ref","columnIndex","data","rowIndex","createGridComponent","_ref2","_class","_temp","getColumnOffset","getColumnStartIndexForOffset","getColumnStopIndexForStartIndex","getColumnWidth","getEstimatedTotalHeight","getEstimatedTotalWidth","getOffsetForColumnAndAlignment","getOffsetForRowAndAlignment","getRowHeight","getRowOffset","getRowStartIndexForOffset","getRowStopIndexForStartIndex","initInstanceProps","shouldResetStyleCacheOnItemSizeChange","validateProps","_PureComponent","Grid","props","_this","this","_instanceProps","_resetIsScrollingTimeoutId","_outerRef","state","instance","isScrolling","horizontalScrollDirection","initialScrollLeft","scrollTop","initialScrollTop","scrollUpdateWasRequested","verticalScrollDirection","_callOnItemsRendered","overscanColumnStartIndex","overscanColumnStopIndex","overscanRowStartIndex","overscanRowStopIndex","visibleColumnStartIndex","visibleColumnStopIndex","visibleRowStartIndex","visibleRowStopIndex","onItemsRendered","_callOnScroll","onScroll","_getItemStyle","_this$props","columnWidth","rowHeight","itemStyleCache","_getItemStyleCache","key","hasOwnProperty","_offset","isRtl","position","left","undefined","right","top","_","__","___","_onScroll","event","_event$currentTarget","currentTarget","clientHeight","clientWidth","scrollHeight","scrollWidth","setState","prevState","calculatedScrollLeft","Math","max","min","calculatedScrollTop","_resetIsScrollingDebounced","_outerRefSetter","ref","outerRef","current","_resetIsScrolling","getDerivedStateFromProps","nextProps","validateSharedProps","_proto","prototype","scrollTo","_ref3","scrollToItem","_ref4","_ref4$align","align","_this$props2","columnCount","rowCount","_this$state","scrollbarSize","div","offsetWidth","getScrollbarSize","estimatedTotalHeight","horizontalScrollbarSize","verticalScrollbarSize","componentDidMount","_this$props3","_callPropsCallbacks","componentDidUpdate","_this$state2","componentWillUnmount","render","_this$props4","children","className","innerRef","innerElementType","innerTagName","itemData","_this$props4$itemKey","itemKey","outerElementType","outerTagName","useIsScrolling","_this$_getHorizontalR","_getHorizontalRangeToRender","columnStartIndex","columnStopIndex","_this$_getVerticalRan","_getVerticalRangeToRender","rowStartIndex","rowStopIndex","items","_rowIndex","_columnIndex","push","estimatedTotalWidth","WebkitOverflowScrolling","willChange","pointerEvents","_this$props5","_this$_getHorizontalR2","_overscanColumnStartIndex","_overscanColumnStopIndex","_visibleColumnStartIndex","_visibleColumnStopIndex","_this$_getVerticalRan2","_overscanRowStartIndex","_overscanRowStopIndex","_visibleRowStartIndex","_visibleRowStopIndex","_this$state3","_horizontalScrollDirection","_scrollLeft","_scrollTop","_scrollUpdateWasRequested","_verticalScrollDirection","_this$props6","overscanColumnCount","overscanColumnsCount","overscanCount","_this$state4","overscanCountResolved","startIndex","stopIndex","overscanBackward","overscanForward","_this$props7","overscanRowCount","overscanRowsCount","_this$state5","PureComponent","defaultProps","_ref5","_ref6","rowMetadataMap","estimatedRowHeight","lastMeasuredRowIndex","totalSizeOfMeasuredRows","itemMetadata","offset","columnMetadataMap","estimatedColumnWidth","lastMeasuredColumnIndex","getItemMetadata","itemType","index","instanceProps","itemMetadataMap","itemSize","lastMeasuredIndex","i","findNearestItem","findNearestItemBinarySearch","findNearestItemExponentialSearch","high","low","middle","floor","currentOffset","itemCount","interval","getOffsetForIndexAndAlignment","scrollOffset","estimatedTotalSize","maxOffset","minOffset","round","VariableSizeGrid","resetAfterColumnIndex","shouldForceUpdate","resetAfterIndices","resetAfterRowIndex","_ref6$shouldForceUpda","forceUpdate","_ref7","defaultItemKey$1","createListComponent","getItemOffset","getEstimatedTotalSize","getItemSize","getStartIndexForOffset","getStopIndexForStartIndex","List","scrollDirection","initialScrollOffset","overscanStartIndex","overscanStopIndex","visibleStartIndex","visibleStopIndex","layout","isHorizontal","offsetHorizontal","_onScrollHorizontal","_onScrollVertical","_event$currentTarget2","validateSharedProps$1","_this$_getRangeToRend","_getRangeToRender","_index","_this$_getRangeToRend2","_overscanStartIndex","_overscanStopIndex","_visibleStartIndex","_visibleStopIndex","_scrollDirection","_scrollOffset","getItemMetadata$1","findNearestItemBinarySearch$1","estimatedItemSize","totalSizeOfMeasuredItems","VariableSizeList","findNearestItemExponentialSearch$1","findNearestItem$1","resetAfterIndex","FixedSizeGrid","lastColumnOffset","middleOffset","ceil","_ref8","lastRowOffset","_ref9","_ref10","numVisibleColumns","_ref11","_ref12","numVisibleRows","_ref13","FixedSizeList","lastItemOffset","numVisibleItems","shallowDiffers","prev","next","attribute","_attribute","areEqual","prevProps","prevStyle","prevRest","nextStyle","nextRest","shouldComponentUpdate","nextState"],"sourceRoot":""}