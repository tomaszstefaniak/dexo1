{"version":3,"file":"main-4.0.1-654.js","mappings":"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","sources":["webpack://@jup-ag/terminal/./node_modules/@jup-ag/react-hook/dist/index.mjs"],"sourcesContent":["// src/index.tsx\nimport {\n  createJupiterApiClient\n} from \"@jup-ag/api\";\nimport {\n  JUPITER_FEE_OWNER,\n  JUPITER_V6_ERRORS,\n  LAMPORTS_PER_SIGNATURE,\n  MARKETS_URL,\n  Owner,\n  SwapMode,\n  TOKEN_LIST_URL,\n  calculateTransactionDepositAndFeeV2,\n  executeTransaction,\n  getReferralTokenAccount,\n  getTransactionBlockhash\n} from \"@jup-ag/common\";\nimport { TransactionError, checkTxSize } from \"@mercurial-finance/optimist\";\nimport { TOKEN_PROGRAM_ID as TOKEN_PROGRAM_ID2, NATIVE_MINT as WRAPPED_SOL_MINT } from \"@solana/spl-token\";\nimport { PublicKey as PublicKey3, Transaction, VersionedTransaction } from \"@solana/web3.js\";\nimport JSBI2 from \"jsbi\";\nimport promiseRetry from \"promise-retry\";\nimport React, { createContext, useCallback, useContext, useEffect as useEffect2, useMemo, useRef, useState as useState2 } from \"react\";\nimport { create } from \"superstruct\";\n\n// src/debug.ts\nfunction getQuoteParamsOverrides() {\n  const overrides = {};\n  const quoteParamsJson = localStorage.getItem(\"quoteParams\");\n  if (quoteParamsJson) {\n    const quoteArgs = JSON.parse(quoteParamsJson);\n    Object.assign(overrides, quoteArgs);\n  }\n  const quoteArgsJson = localStorage.getItem(\"quoteArgs\");\n  if (quoteArgsJson) {\n    const quoteArgs = JSON.parse(quoteArgsJson);\n    for (const [name, value] of Object.entries(quoteArgs)) {\n      overrides[`quoteArg-${name}`] = value;\n    }\n  }\n  return overrides;\n}\n\n// src/error.tsx\nvar Errors = {\n  INITIALIZE_ERROR: \"INITIALIZE_ERROR\",\n  FETCH_ROUTES_ERROR: \"FETCH_ROUTES_ERROR\",\n  NO_ROUTES_ERROR: \"NO_ROUTES_ERROR\",\n  TOKEN_NOT_TRADABLE: \"TOKEN_NOT_TRADABLE\",\n  COULD_NOT_FIND_ANY_ROUTE: \"COULD_NOT_FIND_ANY_ROUTE\",\n  INVALID_REQUEST: \"INVALID_REQUEST\",\n  ROUTE_PLAN_DOES_NOT_CONSUME_ALL_THE_AMOUNT: \"ROUTE_PLAN_DOES_NOT_CONSUME_ALL_THE_AMOUNT\"\n};\n\n// src/utils/api.ts\nimport { array, coerce, instance, integer, number, string, type, enums, optional } from \"superstruct\";\nimport { PublicKey } from \"@solana/web3.js\";\nimport JSBI from \"jsbi\";\nvar PublicKeyFromString = coerce(instance(PublicKey), string(), (value) => new PublicKey(value));\nvar AmountFromString = coerce(instance(JSBI), string(), (value) => JSBI.BigInt(value));\nvar NumberFromString = coerce(string(), number(), (value) => new Number(value));\nvar SwapInfo = type({\n  ammKey: PublicKeyFromString,\n  label: string(),\n  inputMint: string(),\n  outputMint: string(),\n  inAmount: AmountFromString,\n  outAmount: AmountFromString,\n  feeAmount: AmountFromString,\n  feeMint: PublicKeyFromString\n});\nvar RoutePlanStep = type({\n  swapInfo: SwapInfo,\n  percent: integer()\n});\nvar RoutePlanWithMetadata = array(RoutePlanStep);\nvar QuoteResponse = type({\n  inputMint: PublicKeyFromString,\n  inAmount: AmountFromString,\n  outputMint: PublicKeyFromString,\n  outAmount: AmountFromString,\n  otherAmountThreshold: AmountFromString,\n  priceImpactPct: NumberFromString,\n  swapMode: enums([\"ExactIn\", \"ExactOut\"]),\n  routePlan: RoutePlanWithMetadata,\n  slippageBps: number(),\n  contextSlot: number(),\n  computedAutoSlippage: optional(number())\n});\n\n// src/utils/ata.ts\nimport { ASSOCIATED_TOKEN_PROGRAM_ID, TOKEN_PROGRAM_ID } from \"@solana/spl-token\";\nimport { PublicKey as PublicKey2 } from \"@solana/web3.js\";\nfunction getAssociatedTokenAddressSync(mint, owner, tokenProgramId = TOKEN_PROGRAM_ID) {\n  const [ata] = PublicKey2.findProgramAddressSync(\n    [owner.toBuffer(), tokenProgramId.toBuffer(), mint.toBuffer()],\n    ASSOCIATED_TOKEN_PROGRAM_ID\n  );\n  return ata;\n}\n\n// src/utils/useDebounce.ts\nimport { useEffect, useState } from \"react\";\nfunction useDebounce(value, delay) {\n  const [debouncedValue, setDebouncedValue] = useState(value);\n  useEffect(\n    () => {\n      const handler = setTimeout(() => {\n        setDebouncedValue(value);\n      }, delay);\n      return () => {\n        clearTimeout(handler);\n      };\n    },\n    [value, delay]\n    // Only re-call effect if value or delay changes\n  );\n  return debouncedValue;\n}\n\n// src/index.tsx\nimport { JUPITER_PROGRAM_V4_ID, JUPITER_PROGRAM_V6_ID, OPENBOOK_PROGRAM_ID } from \"@jup-ag/common\";\nvar JupiterContext = createContext(null);\nvar JupiterProvider = ({\n  onlyDirectRoutes,\n  userPublicKey,\n  jupiterQuoteApiUrl,\n  children,\n  ...jupiterLoadProps\n}) => {\n  const [programIdToLabelMap, setProgramIdToLabelMap] = useState2(/* @__PURE__ */ new Map());\n  const [error, setError] = useState2();\n  const [programIdsExcluded, setProgramIdsExcluded] = useState2(/* @__PURE__ */ new Set());\n  const platformFeeAndAccountsRef = useRef();\n  useEffect2(() => {\n    platformFeeAndAccountsRef.current = jupiterLoadProps.platformFeeAndAccounts;\n  }, [jupiterLoadProps.platformFeeAndAccounts]);\n  const setPlatformFeeAccount = useCallback((mint, platformFeeAccount) => {\n    if (!platformFeeAndAccountsRef.current) return;\n    if (!platformFeeAndAccountsRef.current.feeAccounts) platformFeeAndAccountsRef.current.feeAccounts = /* @__PURE__ */ new Map();\n    platformFeeAndAccountsRef.current.feeAccounts.set(mint, platformFeeAccount);\n  }, []);\n  const getPlatformFeeAccount = useCallback(async (platformFeeMint) => {\n    var _a;\n    const platformFeeAndAccounts = platformFeeAndAccountsRef.current;\n    const platformFeeAccount = (_a = platformFeeAndAccounts == null ? void 0 : platformFeeAndAccounts.feeAccounts) == null ? void 0 : _a.get(platformFeeMint);\n    const platformFeeBps = platformFeeAndAccounts == null ? void 0 : platformFeeAndAccounts.feeBps;\n    if (platformFeeAccount) return platformFeeAccount;\n    if (platformFeeAccount === null || !platformFeeBps) return;\n    if (platformFeeAndAccounts == null ? void 0 : platformFeeAndAccounts.referralAccount) {\n      const referralTokenAccount = await getReferralTokenAccount({\n        connection: jupiterLoadProps.connection,\n        referralAccount: platformFeeAndAccounts.referralAccount,\n        mint: new PublicKey3(platformFeeMint)\n      });\n      setPlatformFeeAccount(platformFeeMint, referralTokenAccount);\n      if (referralTokenAccount) return referralTokenAccount;\n    }\n    return;\n  }, []);\n  const jupiterApiClient = useMemo(() => {\n    if (jupiterQuoteApiUrl) {\n      return createJupiterApiClient({\n        basePath: jupiterQuoteApiUrl\n      });\n    }\n    return createJupiterApiClient();\n  }, [jupiterQuoteApiUrl]);\n  useEffect2(() => {\n    setProgramIdsExcluded((set) => {\n      if (set.size) {\n        return /* @__PURE__ */ new Set();\n      }\n      return set;\n    });\n  }, [jupiterLoadProps.asLegacyTransaction]);\n  useEffect2(() => {\n    async function fetchProgramIdToLabelMap() {\n      const programIdToLabel = await jupiterApiClient.programIdToLabelGet();\n      const programIdToLabelMap2 = new Map(Object.entries(programIdToLabel));\n      setProgramIdToLabelMap(programIdToLabelMap2);\n    }\n    fetchProgramIdToLabelMap();\n  }, [jupiterApiClient]);\n  return /* @__PURE__ */ React.createElement(\n    JupiterContext.Provider,\n    {\n      value: {\n        ...jupiterLoadProps,\n        getPlatformFeeAccount,\n        userPublicKey,\n        programIdToLabelMap,\n        jupiterApiClient,\n        error,\n        setError,\n        onlyDirectRoutes,\n        programIdsExcluded,\n        setProgramIdsExcluded,\n        whitelistedFeeMints: jupiterLoadProps.whitelistedFeeMints\n      }\n    },\n    children\n  );\n};\nvar useJupiterClient = () => {\n  const context = useContext(JupiterContext);\n  if (!context) {\n    throw new Error(\"JupiterProvider is required\");\n  }\n  return context.jupiterApiClient;\n};\nvar useJupiter = ({\n  amount,\n  inputMint,\n  outputMint,\n  autoSlippage,\n  maxAutoSlippageBps,\n  autoSlippageCollisionUsdValue,\n  slippageBps,\n  swapMode,\n  debounceTime = 250,\n  maxAccounts,\n  disabledProgramIds,\n  computeAutoSlippage,\n  minimizeSlippage,\n  preferLiquidDexes\n}) => {\n  const context = useContext(JupiterContext);\n  const [loading, setLoading] = useState2(false);\n  const [quoteResponseMeta, setQuoteResponseMeta] = useState2();\n  const [refreshCount, setRefreshCount] = useState2(0);\n  const lastRefreshCount = useRef(refreshCount);\n  const [debouncedAmount, debouncedInputMint, debouncedOutputMint, debouncedSwapMode] = useDebounce(\n    React.useMemo(() => {\n      if (JSBI2.greaterThan(amount, JSBI2.BigInt(0))) {\n        setLoading(true);\n      }\n      return [amount, inputMint, outputMint, swapMode];\n    }, [amount.toString(), inputMint == null ? void 0 : inputMint.toBase58(), outputMint == null ? void 0 : outputMint.toBase58(), swapMode]),\n    debounceTime\n  );\n  const lastRefreshTimestamp = useRef(0);\n  const lastQueryTimestamp = useRef(0);\n  if (!context) {\n    throw new Error(\"JupiterProvider is required\");\n  }\n  const {\n    error,\n    setError,\n    routeCacheDuration = 0,\n    onlyDirectRoutes,\n    jupiterApiClient,\n    userPublicKey,\n    wrapUnwrapSOL = true,\n    asLegacyTransaction,\n    platformFeeAndAccounts,\n    programIdToLabelMap,\n    setProgramIdsExcluded,\n    programIdsExcluded,\n    whitelistedFeeMints\n  } = context;\n  useEffect2(() => {\n    lastRefreshCount.current = -1;\n  }, [\n    [debouncedInputMint == null ? void 0 : debouncedInputMint.toString(), debouncedOutputMint == null ? void 0 : debouncedOutputMint.toString()].sort().join(\"-\"),\n    autoSlippage,\n    maxAutoSlippageBps,\n    autoSlippageCollisionUsdValue,\n    slippageBps\n  ]);\n  useEffect2(() => {\n    if (lastRefreshTimestamp.current && (/* @__PURE__ */ new Date()).getTime() - lastRefreshTimestamp.current >= routeCacheDuration) {\n      lastRefreshCount.current = -1;\n    }\n    if (JSBI2.greaterThan(debouncedAmount, JSBI2.BigInt(0))) {\n      setLoading(true);\n    } else {\n      setLoading(false);\n    }\n  }, [\n    refreshCount,\n    debouncedAmount,\n    slippageBps,\n    debouncedInputMint,\n    debouncedOutputMint,\n    onlyDirectRoutes,\n    asLegacyTransaction\n  ]);\n  const fetchQuote = useCallback(async () => {\n    try {\n      if (JSBI2.equal(debouncedAmount, JSBI2.BigInt(0)) || error === Errors.INITIALIZE_ERROR) {\n        return null;\n      } else if (debouncedAmount) {\n        if (!debouncedInputMint || !debouncedOutputMint) return null;\n        if (slippageBps && autoSlippage) throw new Error(\"Cannot set both slippageBps and autoSlippage\");\n        if (!autoSlippage && maxAutoSlippageBps) throw new Error(\"Cannot set maxAutoSlippageBps without autoSlippage\");\n        const inputMint2 = debouncedInputMint.toBase58();\n        const outputMint2 = debouncedOutputMint.toBase58();\n        if (swapMode === SwapMode.ExactOut && maxAccounts) {\n          console.warn(\"maxAccounts is not supported for ExactOut swap mode\");\n        }\n        let quoteResponse;\n        let original;\n        const excludeDexes = Array.from([...programIdsExcluded, ...disabledProgramIds || []]).map((id) => programIdToLabelMap.get(id)).filter((id) => Boolean(id));\n        const quoteParamsOverrides = getQuoteParamsOverrides();\n        const apiClient = new Proxy(jupiterApiClient, {\n          get: function(target, prop) {\n            if (prop === \"request\") {\n              return (context2, initOverrides) => {\n                if (Object.keys(quoteParamsOverrides).length) {\n                  console.log(\"Quoting with overrides:\", quoteParamsOverrides);\n                  Object.assign(context2.query, quoteParamsOverrides);\n                }\n                return target.request(context2, initOverrides);\n              };\n            }\n            return Reflect.get(target, prop);\n          }\n        });\n        const supportedMint = (swapMode === SwapMode.ExactOut ? [inputMint2] : [inputMint2, outputMint2]).filter(\n          (mint) => {\n            if (whitelistedFeeMints) {\n              return whitelistedFeeMints == null ? void 0 : whitelistedFeeMints.includes(mint);\n            }\n            return true;\n          }\n        );\n        const platformFeeBps = supportedMint.length > 0 ? platformFeeAndAccounts == null ? void 0 : platformFeeAndAccounts.feeBps : void 0;\n        const response = await promiseRetry(\n          (retry) => apiClient.quoteGet({\n            inputMint: inputMint2,\n            outputMint: outputMint2,\n            amount: debouncedAmount.toString(),\n            // making it number for u64.MAX would cause precision err\n            autoSlippage,\n            maxAutoSlippageBps,\n            autoSlippageCollisionUsdValue,\n            slippageBps,\n            swapMode,\n            excludeDexes: excludeDexes.length ? [excludeDexes.filter(Boolean).join(\",\")] : void 0,\n            onlyDirectRoutes,\n            asLegacyTransaction,\n            platformFeeBps,\n            maxAccounts,\n            computeAutoSlippage,\n            minimizeSlippage,\n            preferLiquidDexes\n          }).catch((e) => {\n            retry(e);\n          }),\n          {\n            retries: 1,\n            minTimeout: 100\n          }\n        );\n        original = Object.assign({}, response);\n        quoteResponse = create(response, QuoteResponse);\n        return { quoteResponse, original, timestamp: (/* @__PURE__ */ new Date()).getTime() };\n      }\n      return null;\n    } catch (error2) {\n      throw error2;\n    }\n  }, [\n    debouncedAmount,\n    debouncedInputMint,\n    debouncedOutputMint,\n    debouncedSwapMode,\n    slippageBps,\n    maxAutoSlippageBps,\n    swapMode,\n    maxAccounts,\n    userPublicKey,\n    wrapUnwrapSOL,\n    refreshCount,\n    onlyDirectRoutes,\n    asLegacyTransaction,\n    programIdsExcluded,\n    preferLiquidDexes\n  ]);\n  useEffect2(() => {\n    let requestAborted = false;\n    (async () => {\n      if (JSBI2.equal(debouncedAmount, JSBI2.BigInt(0)) || error === Errors.INITIALIZE_ERROR) {\n        setLoading(false);\n        setQuoteResponseMeta(void 0);\n      } else if (debouncedAmount) {\n        if (!debouncedInputMint || !debouncedOutputMint) return;\n        const lastUpdatedTime = (/* @__PURE__ */ new Date()).getTime();\n        lastQueryTimestamp.current = lastUpdatedTime;\n        lastRefreshTimestamp.current = lastUpdatedTime;\n        try {\n          const fetchedQuote = await fetchQuote();\n          if (!(fetchedQuote == null ? void 0 : fetchedQuote.quoteResponse) || !(fetchedQuote == null ? void 0 : fetchedQuote.original) || !(fetchedQuote == null ? void 0 : fetchedQuote.timestamp) || requestAborted)\n            return;\n          setQuoteResponseMeta({\n            quoteResponse: fetchedQuote.quoteResponse,\n            original: fetchedQuote.original\n          });\n          setError(void 0);\n        } catch (e) {\n          console.error(e);\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          const haveErrorCode = await (async () => {\n            try {\n              if (\"response\" in e && e.response instanceof Response) {\n                const errorObj = await e.response.json();\n                return errorObj.errorCode || null;\n              }\n            } catch (error2) {\n              console.log(\"Error parsing error response\", error2);\n              return null;\n            }\n          })();\n          if (haveErrorCode) {\n            setError(haveErrorCode);\n          } else {\n            setError(Errors.FETCH_ROUTES_ERROR);\n          }\n          setQuoteResponseMeta(void 0);\n        } finally {\n          if (lastQueryTimestamp.current !== lastUpdatedTime) {\n            return;\n          }\n          lastRefreshCount.current = refreshCount;\n          setLoading(false);\n        }\n      }\n    })();\n    return () => {\n      requestAborted = true;\n    };\n  }, [fetchQuote]);\n  const { exchange, fetchSwapTransaction } = useJupiterExchange(swapMode);\n  return {\n    exchange,\n    fetchQuote,\n    fetchSwapTransaction,\n    refresh: React.useCallback(() => {\n      if (!loading && lastRefreshTimestamp.current) {\n        setRefreshCount((refreshCount2) => refreshCount2 + 1);\n      }\n    }, [loading]),\n    lastRefreshTimestamp: lastRefreshTimestamp.current,\n    loading,\n    quoteResponseMeta,\n    error,\n    programIdToLabelMap,\n    setProgramIdsExcluded,\n    programIdsExcluded\n  };\n};\nvar useJupiterExchange = (swapMode) => {\n  const context = useContext(JupiterContext);\n  if (!context) {\n    throw new Error(\"JupiterProvider is required\");\n  }\n  const {\n    jupiterApiClient,\n    userPublicKey,\n    connection,\n    wrapUnwrapSOL = true,\n    asLegacyTransaction,\n    platformFeeAndAccounts,\n    useSharedAccounts,\n    getPlatformFeeAccount,\n    whitelistedFeeMints\n  } = context;\n  const fetchSwapTransaction = useCallback(\n    async ({\n      quoteResponseMeta,\n      userPublicKey: userPublicKey2,\n      wrapUnwrapSOL: propsWrapUnwrapSOL,\n      prioritizationFeeLamports,\n      allowOptimizedWrappedSolTokenAccount,\n      dynamicSlippage\n    }) => {\n      if (!userPublicKey2) throw new Error(\"User public key is required\");\n      const wrapAndUnwrapSol = Boolean(propsWrapUnwrapSOL ?? wrapUnwrapSOL ?? true);\n      const { inputMint, outputMint } = quoteResponseMeta.quoteResponse;\n      const supportedMints = (swapMode === SwapMode.ExactOut ? [inputMint] : [inputMint, outputMint]).filter((mint) => {\n        if (whitelistedFeeMints) {\n          return whitelistedFeeMints == null ? void 0 : whitelistedFeeMints.includes(mint.toString());\n        }\n        return true;\n      });\n      const feeAccount = supportedMints.length !== 0 ? await (async () => {\n        for (const mint of supportedMints) {\n          const account = await getPlatformFeeAccount(mint.toBase58());\n          if (account) {\n            return account;\n          }\n        }\n        return void 0;\n      })() : void 0;\n      const result = await promiseRetry(\n        (retry) => jupiterApiClient.swapPost({\n          swapRequest: {\n            quoteResponse: quoteResponseMeta.original,\n            userPublicKey: userPublicKey2.toBase58(),\n            wrapAndUnwrapSol,\n            feeAccount: feeAccount == null ? void 0 : feeAccount.toBase58(),\n            asLegacyTransaction,\n            useSharedAccounts,\n            dynamicComputeUnitLimit: true,\n            allowOptimizedWrappedSolTokenAccount,\n            prioritizationFeeLamports,\n            dynamicSlippage,\n            correctLastValidBlockHeight: true\n          }\n        }).catch(async (res) => {\n          try {\n            const { error } = await res.json();\n            return { error: new TransactionError(error) };\n          } catch (e) {\n            return retry({\n              error: new TransactionError(\"Unknown error\")\n            });\n          }\n        }),\n        {\n          retries: 1,\n          minTimeout: 100\n        }\n      );\n      if (\"error\" in result) {\n        return result;\n      }\n      const { swapTransaction: swapTransactionSerialized, lastValidBlockHeight } = result;\n      const swapTransactionBuffer = Buffer.from(swapTransactionSerialized, \"base64\");\n      const swapTransaction = asLegacyTransaction ? Transaction.from(swapTransactionBuffer) : VersionedTransaction.deserialize(swapTransactionBuffer);\n      checkTxSize(swapTransaction);\n      return {\n        swapTransaction,\n        blockhash: getTransactionBlockhash(swapTransaction),\n        lastValidBlockHeight,\n        dynamicSlippageReport: result.dynamicSlippageReport\n      };\n    },\n    [wrapUnwrapSOL, asLegacyTransaction, useSharedAccounts, getPlatformFeeAccount, jupiterApiClient]\n  );\n  const exchange = useCallback(\n    async ({\n      wallet,\n      quoteResponseMeta,\n      onTransaction,\n      prioritizationFeeLamports,\n      ...restExchangeProps\n    }) => {\n      if (!userPublicKey) throw new Error(\"User public key is required\");\n      if (!wallet) throw new Error(\"Wallet is required\");\n      const { inputMint, outputMint } = quoteResponseMeta.quoteResponse;\n      const wrapAndUnwrapSol = Boolean(restExchangeProps.wrapUnwrapSOL ?? wrapUnwrapSOL ?? true);\n      const [result, accountInfos] = await Promise.all([\n        fetchSwapTransaction({\n          quoteResponseMeta,\n          userPublicKey,\n          wrapUnwrapSOL: wrapAndUnwrapSol,\n          prioritizationFeeLamports,\n          ...restExchangeProps\n        }),\n        connection.getMultipleAccountsInfo([inputMint, outputMint])\n      ]);\n      if (\"error\" in result) {\n        return result;\n      }\n      const { blockhash, lastValidBlockHeight, swapTransaction } = result;\n      const [sourceAddress, destinationAddress] = [inputMint, outputMint].map(\n        (mint, idx) => {\n          var _a;\n          return getAssociatedTokenAddressSync(mint, userPublicKey, ((_a = accountInfos[idx]) == null ? void 0 : _a.owner) || TOKEN_PROGRAM_ID2);\n        }\n      );\n      return executeTransaction({\n        connection,\n        wallet,\n        onTransaction,\n        inputMint,\n        outputMint,\n        sourceAddress,\n        destinationAddress,\n        swapTransaction,\n        blockhashWithBlockHeight: { lastValidBlockHeight, blockhash },\n        owner: new Owner(userPublicKey),\n        wrapUnwrapSOL: wrapAndUnwrapSol\n      });\n    },\n    [userPublicKey, wrapUnwrapSOL, asLegacyTransaction, connection, platformFeeAndAccounts, jupiterApiClient, swapMode]\n  );\n  return { exchange, fetchSwapTransaction };\n};\nvar calculateFeeForSwap = (quoteResponse, mintToAtaMap, openbookMarketToOpenOrderMap, wrapUnwrapSOL, useSharedAccounts) => {\n  const atasToBeCreated = /* @__PURE__ */ new Set();\n  const openOrdersToBeCreated = /* @__PURE__ */ new Set();\n  const isInputMintSOL = Boolean(wrapUnwrapSOL && (quoteResponse == null ? void 0 : quoteResponse.inputMint.equals(WRAPPED_SOL_MINT)));\n  const walkRoutePlan = (routePlan) => {\n    if (!useSharedAccounts) {\n      routePlan.forEach((routeStep) => {\n        if (!mintToAtaMap.has(routeStep.swapInfo.outputMint)) {\n          atasToBeCreated.add(routeStep.swapInfo.outputMint);\n        }\n        if (routeStep.swapInfo.label === \"Openbook\") {\n          if (!openbookMarketToOpenOrderMap.has(routeStep.swapInfo.ammKey.toBase58())) {\n            openOrdersToBeCreated.add(routeStep.swapInfo.outputMint);\n          }\n        }\n      });\n    }\n  };\n  if (quoteResponse) {\n    if (useSharedAccounts) {\n      let numOfAtasToBeCreated = 0;\n      if (quoteResponse.inputMint.equals(WRAPPED_SOL_MINT) || quoteResponse.outputMint.equals(WRAPPED_SOL_MINT) && wrapUnwrapSOL && !mintToAtaMap.has(WRAPPED_SOL_MINT.toBase58())) {\n        numOfAtasToBeCreated = 1;\n      }\n      return calculateTransactionDepositAndFeeV2({\n        numOfAtasToBeCreated,\n        numOfOpenOrdersToBeCreated: 0,\n        isInputMintSOL\n      });\n    }\n    if (quoteResponse.inputMint.equals(WRAPPED_SOL_MINT) && wrapUnwrapSOL && !mintToAtaMap.has(WRAPPED_SOL_MINT.toBase58())) {\n      atasToBeCreated.add(WRAPPED_SOL_MINT.toBase58());\n    }\n    walkRoutePlan(quoteResponse.routePlan);\n  }\n  return calculateTransactionDepositAndFeeV2({\n    numOfAtasToBeCreated: atasToBeCreated.size,\n    numOfOpenOrdersToBeCreated: openOrdersToBeCreated.size,\n    isInputMintSOL\n  });\n};\nexport {\n  Errors,\n  JUPITER_FEE_OWNER,\n  JUPITER_PROGRAM_V4_ID,\n  JUPITER_PROGRAM_V6_ID,\n  JUPITER_V6_ERRORS,\n  JupiterProvider,\n  LAMPORTS_PER_SIGNATURE,\n  MARKETS_URL,\n  OPENBOOK_PROGRAM_ID,\n  Owner,\n  SwapMode,\n  TOKEN_LIST_URL,\n  calculateFeeForSwap,\n  useJupiter,\n  useJupiterClient,\n  useJupiterExchange\n};\n//# sourceMappingURL=index.mjs.map"],"names":["Errors","INITIALIZE_ERROR","FETCH_ROUTES_ERROR","NO_ROUTES_ERROR","TOKEN_NOT_TRADABLE","COULD_NOT_FIND_ANY_ROUTE","INVALID_REQUEST","ROUTE_PLAN_DOES_NOT_CONSUME_ALL_THE_AMOUNT","PublicKeyFromString","PublicKey","value","AmountFromString","NumberFromString","Number","SwapInfo","ammKey","label","inputMint","outputMint","inAmount","outAmount","feeAmount","feeMint","RoutePlanStep","swapInfo","percent","RoutePlanWithMetadata","QuoteResponse","otherAmountThreshold","priceImpactPct","swapMode","routePlan","slippageBps","contextSlot","computedAutoSlippage","JupiterContext","createContext","JupiterProvider","onlyDirectRoutes","userPublicKey","jupiterQuoteApiUrl","children","jupiterLoadProps","programIdToLabelMap","setProgramIdToLabelMap","useState","Map","error","setError","programIdsExcluded","setProgramIdsExcluded","Set","platformFeeAndAccountsRef","useRef","useEffect","current","platformFeeAndAccounts","setPlatformFeeAccount","useCallback","mint","platformFeeAccount","feeAccounts","set","getPlatformFeeAccount","async","platformFeeMint","_a","get","platformFeeBps","feeBps","referralAccount","referralTokenAccount","connection","jupiterApiClient","useMemo","basePath","size","asLegacyTransaction","programIdToLabel","programIdToLabelGet","programIdToLabelMap2","Object","entries","fetchProgramIdToLabelMap","Provider","whitelistedFeeMints","useJupiterClient","context","useContext","Error","useJupiter","amount","autoSlippage","maxAutoSlippageBps","autoSlippageCollisionUsdValue","debounceTime","maxAccounts","disabledProgramIds","computeAutoSlippage","minimizeSlippage","preferLiquidDexes","loading","setLoading","quoteResponseMeta","setQuoteResponseMeta","refreshCount","setRefreshCount","lastRefreshCount","debouncedAmount","debouncedInputMint","debouncedOutputMint","debouncedSwapMode","delay","debouncedValue","setDebouncedValue","handler","setTimeout","clearTimeout","useDebounce","toString","toBase58","lastRefreshTimestamp","lastQueryTimestamp","routeCacheDuration","wrapUnwrapSOL","sort","join","Date","getTime","fetchQuote","inputMint2","outputMint2","quoteResponse","original","ExactOut","console","warn","excludeDexes","Array","from","map","id","filter","Boolean","quoteParamsOverrides","overrides","quoteParamsJson","localStorage","getItem","quoteArgs","JSON","parse","assign","quoteArgsJson","name","getQuoteParamsOverrides","apiClient","Proxy","target","prop","context2","initOverrides","keys","length","log","query","request","Reflect","includes","response","retry","quoteGet","catch","e","retries","minTimeout","timestamp","error2","requestAborted","lastUpdatedTime","fetchedQuote","haveErrorCode","Response","json","errorCode","exchange","fetchSwapTransaction","useJupiterExchange","refresh","refreshCount2","useSharedAccounts","userPublicKey2","propsWrapUnwrapSOL","prioritizationFeeLamports","allowOptimizedWrappedSolTokenAccount","dynamicSlippage","wrapAndUnwrapSol","supportedMints","feeAccount","account","result","swapPost","swapRequest","dynamicComputeUnitLimit","correctLastValidBlockHeight","res","TransactionError","swapTransaction","swapTransactionSerialized","lastValidBlockHeight","swapTransactionBuffer","Buffer","Transaction","VersionedTransaction","deserialize","checkTxSize","blockhash","dynamicSlippageReport","wallet","onTransaction","restExchangeProps","accountInfos","Promise","all","getMultipleAccountsInfo","sourceAddress","destinationAddress","idx","owner","tokenProgramId","TOKEN_PROGRAM_ID","ata","findProgramAddressSync","toBuffer","ASSOCIATED_TOKEN_PROGRAM_ID","getAssociatedTokenAddressSync","blockhashWithBlockHeight","calculateFeeForSwap","mintToAtaMap","openbookMarketToOpenOrderMap","atasToBeCreated","openOrdersToBeCreated","isInputMintSOL","equals","numOfAtasToBeCreated","has","numOfOpenOrdersToBeCreated","add","forEach","routeStep"],"sourceRoot":""}